<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Chyezh&#x27;s Notes</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">C++</li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> C++ Concurrency In Action</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="C++/C++-Concurrency-In-Action/Managing-Threads.html"><strong aria-hidden="true">1.1.</strong> Managing Threads</a></li><li class="chapter-item expanded "><a href="C++/C++-Concurrency-In-Action/Shared-Data-Protection.html"><strong aria-hidden="true">1.2.</strong> Shared Data Protection</a></li><li class="chapter-item expanded "><a href="C++/C++-Concurrency-In-Action/Operation-Synchronization.html"><strong aria-hidden="true">1.3.</strong> Operation Synchronization</a></li><li class="chapter-item expanded "><a href="C++/C++-Concurrency-In-Action/Memory-Model-And-Atomic-Operation.html"><strong aria-hidden="true">1.4.</strong> Memory Model And Atomic Operation</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Effective Modern C++</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="C++/Effective-Modern-C++/Part1.html"><strong aria-hidden="true">2.1.</strong> Part1</a></li><li class="chapter-item expanded "><a href="C++/Effective-Modern-C++/Part2.html"><strong aria-hidden="true">2.2.</strong> Part2</a></li><li class="chapter-item expanded "><a href="C++/Effective-Modern-C++/Part3.html"><strong aria-hidden="true">2.3.</strong> Part3</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Multi Tenant</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Multi-Tenant/Multi-Tenant-Task-Scheduling.html"><strong aria-hidden="true">3.1.</strong> Multi Tenant Task Scheduling</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Chyezh&#x27;s Notes</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div style="break-before: page; page-break-before: always;"></div><h1 id="managing-threads"><a class="header" href="#managing-threads">Managing Threads</a></h1>
<h2 id="stdthread"><a class="header" href="#stdthread"><em>std::thread</em></a></h2>
<p>C++线程通过类<em>std::thread</em>来实现。有以下特点：</p>
<ul>
<li><em>std::thread</em>通过获得一个<em>callable object</em>（作为线程入口）构造。</li>
<li>当<em>std::thread</em>构造完成时，新线程开始运作。</li>
<li>当<em>std::thread</em>被销毁之前，必须手动保证其相关线程是<em>join</em>还是<em>detach</em>，否则触发<em>std::terminate</em>。</li>
<li>在决定<em>join or detach</em>之前，线程可能已经工作完毕。</li>
<li>如果一个线程是<em>detach</em>的，即使<em>std::thread</em>被销毁，线程也可以继续工作，但必须要保证线程所用的内存数据可用。</li>
</ul>
<h2 id="ensure-that-the-data-accessed-by-the-thread-is-valid"><a class="header" href="#ensure-that-the-data-accessed-by-the-thread-is-valid"><em>ensure that the data accessed by the thread is valid</em></a></h2>
<p>在整个线程的工作中，线程访问的数据必须是合法的，这一点和初始线程（以<em>main</em>为入口）一样。但这一点在多线程中更加复杂。</p>
<pre><code class="language-c++">struct func{
    int&amp; i;
    func(int&amp; i_):i(i_){}
    void operator()(){
        for(unsigned j=0;j&lt;1000000;++j){
            do_something(i);
        }
    }
};
void oops() {
    int some_local_state=0;
    func my_func(some_local_state);
    std::thread my_thread(my_func);
    my_thread.detach();
}
</code></pre>
<p>如上错误代码，<em>my_func</em>是一个<em>callable object</em>，其引用成员<em>i</em>绑定了一个局部变量<em>some_local_state</em>。然后<em>my_thread</em>使用<em>my_func</em>构造了一个新的线程并且<em>detach</em>。新线程中的引用<em>i</em>依旧指向局部变量<em>some_local_state</em>，如果<em>oops</em>先于新线程结束，并且销毁了局部变量，则新线程出现未定义行为。
最简单的办法就是避免<em>callable object</em>拷贝这些变量而不是和外部共享这些变量。在建立新线程时必须要注意<em>callable object</em>是否包含有<em>shared data</em>。</p>
<h2 id="join-or-detach"><a class="header" href="#join-or-detach"><em>join or detach</em></a></h2>
<p><em>join</em>就是等待线程完全结束，当线程结束时，线程相关的数据都会被销毁，对象<em>std::thread</em>和线程不再存在关系，即单个线程只能<em>join</em>一次，方法<em>joinable</em>会返回<em>false</em>。</p>
<p>当<em>std::thread</em>被销毁之前，必须对其<em>joinable</em>进行检查，不论其是由于正常还是异常遭到销毁：</p>
<pre><code class="language-c++">struct func;        // callable obj.

void f(){
    int local_state = 0;
    func my_func(local_state);
    std::thread t(my_func);
    try{
        do_something();
    }
    catch(...){
        t.join();
        throw;
    }
    t.join();
}
</code></pre>
<p>或者使用RAII风格的<em>guard</em>，避免了与异常打交道：</p>
<pre><code class="language-c++">class thread_guard{
public:
    thread_guard(std::thread&amp; _t):t(_t) {};
    thread_guard(const thread_guard&amp;) = delete;
    thread_guard&amp; opetator=(const thread_guard&amp;) = delete;
    ~thread_guard(){
        if(t.joinable()){
            t.join();
        }
    }
private:
    std::thread&amp; t;
};

struct func;        // callable obj.

void f(){
    int local_state = 0;
    func my_func(local_state);
    std::thread t(my_func);
    thread_guard g(t);
    do_something();
}
</code></pre>
<p><em>detach</em>就是使得线程与对象<em>std::thread</em>脱离关系，脱离之后将无法再在初线程中通过<em>std::thread</em>管理该线程，对象<em>std::thread</em>的方法<em>joinable</em>将会返回<em>false</em>。通过<em>detach</em>可以实现后台进程，后台进程依赖<em>C++ Runtime</em>脱离初线程自行运作。</p>
<h2 id="passing-arguments-to-a-thread-function"><a class="header" href="#passing-arguments-to-a-thread-function">Passing arguments to a thread function</a></h2>
<p><em>std::thread</em>的构造函数可以通过额外可变参数的方式来传递参数给其关联的线程函数：</p>
<pre><code class="language-c++">void foo(int i, const string&amp; s);

std::thread t(foo, 1, &quot;123&quot;);
</code></pre>
<p>但是值得注意的是，不管线程函数的参数列表如何表达，传入的额外参数总是“拷贝”的形式传给线程函数。以上代码看上去相当于调用了：</p>
<pre><code class="language-c++">foo(1, &quot;123&quot;);
</code></pre>
<p>但是实际上，通过<em>std::thread</em>的构造函数先按“拷贝”的方式将“123”的指针（类型为const char*）传入内部。见如下代码：</p>
<pre><code class="language-c++">void f(int i,std::string const&amp; s);
void oops(int some_param){
    char buffer[1024];
    sprintf(buffer, &quot;%i&quot;,some_param);
    std::thread t(f,3,buffer);
    t.detach();
}
</code></pre>
<p><em>std::thread</em>对象<em>t</em>的构造将参数<em>buffer</em>（类型为 char*）拷贝传入线程内部。线程函数<em>f</em>将会调用该指针副本构造函数参数<em>std::string</em>。但是构造<em>std::string</em>的时候指针副本所指向的buffer不一定还存在，初线程可能已经跳出<em>oops</em>并且销毁了栈数组<em>buffer</em>。线程将出现未定义行为。防止这类未定义行为的解决方案即在<em>buffer</em>尚未销毁前，构造<em>string</em>：</p>
<pre><code class="language-c++">void f(int i,std::string const&amp; s);
void oops(int some_param){
    char buffer[1024];
    sprintf(buffer, &quot;%i&quot;,some_param);
    std::thread t(f,3,std::string(buffer));
    t.detach();
} 
</code></pre>
<p>同样存在希望新线程能够改变初线程的状态，这时期望传入引用：</p>
<pre><code class="language-c++">void update_data_for_widget(widget_id w,widget_data&amp; data);
void oops_again(widget_id w){
    widget_data data;
    std::thread t(update_data_for_widget,w,data);
    display_status();
    t.join();
    process_widget_data(data);
}
</code></pre>
<p>由于<em>std::thread</em>的构造函数复制了<em>widget_data</em>对象data，函数<em>update_data_for_widget</em>更新的是<em>widget_data</em>对象的副本。<em>std::thread</em>的应用情景很像<em>std::bind</em>，解决方案就是使用<em>std::ref</em>：</p>
<pre><code class="language-c++">std::thread t(update_data_for_widget,w,std::ref(data));
</code></pre>
<p>这样以来<em>std::thread</em>的构造函数将会将<em>data</em>的引用而不是副本传入内部线程。</p>
<p><em>std::thread</em>对于线程函数的处理机制和<em>std::bind</em>是一样的，比如将成员函数作为线程函数：</p>
<pre><code class="language-c++">class X {
public:
    void func();
};

X x;
thread t(&amp;X::pp,&amp;x);
</code></pre>
<p>另一个应用场景是当传入参数只可以<em>move</em>，而不可以<em>copy</em>的情况，比如<em>std::unique_ptr</em>:</p>
<pre><code class="language-c++">void func(std::unique_ptr&lt;X&gt; pX);

std::unique_ptr&lt;X&gt; pX = make_unique&lt;X&gt;();
std::thread(func, std::move(pX));
</code></pre>
<p>这样pX所有的对象将会通过<em>move</em>的方式传入线程存储，再传给线程函数。值得注意的是，<em>std::thread</em>也是一种<em>move-only</em>类型，因为其管理一定资源，因此一个线程只能与一个<em>std::thread</em>关联。</p>
<h2 id="transferring-ownership-of-a-thread"><a class="header" href="#transferring-ownership-of-a-thread">Transferring ownership of a thread</a></h2>
<p><em>std::thread</em>对象是<em>moveable</em>的，当希望在两个对象之间传递对于线程的管理权限，比如函数内部生成了一个线程，但希望在函数结束后能够继续管理这个线程，就需要将线程的管理权传递给外层的<em>std::thread</em>。</p>
<p>转移线程所有权的操作通过<em>std::thread</em>的移动构造函数和移动复制操作符实现，但一个<em>std::thread</em>实例只能维护一个线程，否则将会终止程序：</p>
<pre><code class="language-c++">std::thread g(){
    void some_other_function(int);
    std::thread t(some_other_function,42);
    return t;
}

void f(std::thread t);

void some_func();
f(std::thread(some_func));
std::thread t(some_func);
f(std::move(t));
</code></pre>
<p>由于<em>std::thread</em>可以<em>move</em>，<em>thread_guard</em>也可以完全持有<em>std::thread</em>，而不用引用来管理<em>thread</em>：</p>
<pre><code class="language-c++">class scoped_thread{
public:
    scoped_thread(std::thread _t) :t(std::move(_t){
        if(!t.joinable())
            throw std::logic_error(&quot;no associated thread!&quot;);
    }
    scoped_thread(const scoped_thread&amp;) = delete;
    scoped_thread&amp; operator=(const scoped_thread&amp;) = delete;
    ~scoped_thread(){
        if(t.joinable)
            t.join();
    }
private:
    std::thread t;
}
</code></pre>
<p>可以使用容器管理线程：</p>
<pre><code class="language-c++">void func(i);

void f(){
    std::vector&lt;std::thread&gt; threads;
    for(int i = 0; i &lt; 10; ++i) {
        threads.emplace_back(func,i);   // direct construct thread.
        // threads.push_back(std::thread(func,i)); // move temp thread object to vector.
    }
    for(auto&amp;&amp; t : threads) {
        if(t.joinable())
            t.join();
    }
}
</code></pre>
<h2 id="choosing-the-number-of-threads-at-runtime"><a class="header" href="#choosing-the-number-of-threads-at-runtime">Choosing the number of threads at runtime</a></h2>
<p><em>hardware_concurrency</em>可以获取当前硬件可以进行的并行处理线程数量。如下实现一个并行加法：</p>
<pre><code class="language-c++">template &lt;typename Iterator&gt;
struct parallel_accumulate_block {
    void operator()(const Iterator&amp; _begin, const Iterator&amp; _end, typename Iterator::value_type&amp; _result) {
        _result = std::accumulate(_begin, _end, static_cast&lt;typename Iterator::value_type&gt;(0));
    }
};

template &lt;typename Iterator&gt;
typename Iterator::value_type parallel_accumulate(const Iterator&amp; _begin,
                                                const Iterator&amp; _end,
                                                typename Iterator::value_type _init) {
    auto arraySize = std::distance(_begin, _end);
    if(!arraySize)
        return _init;
    const unsigned int MinPerThread = 25;
    auto maxThread = (arraySize + MinPerThread - 1) / MinPerThread;
    auto numHardwareThread = std::thread::hardware_concurrency();
    auto numThread = std::min(numHardwareThread != 0?numHardwareThread:1, maxThread);
    auto blockSize = arraySize / numThread;

    std::vector&lt;std::thread&gt; threads;
    std::vector&lt;typename Iterator::value_type&gt; results;
    threads.reserve(numThread - 1);
    results.resize(numThread);

    auto iterBlockBegin = _begin;
    auto iterBlockEnd = iterBlockBegin;
    for(unsigned int i = 0; i &lt; numThread - 1; i++) {
        std::advance(iterBlockEnd, blockSize);
        threads.emplace_back(parallel_accumulate_block&lt;Iterator&gt;(), iterBlockBegin, iterBlockEnd, std::ref(results[i]));
        std::advance(iterBlockBegin, blockSize);
    }
    
    parallel_accumulate_block&lt;Iterator&gt;()(iterBlockBegin, _end, results[numThread - 1]);
    std::for_each(threads.begin(), threads.end(), std::mem_fn(&amp;std::thread::join));
    return std::accumulate(cbegin(results), cend(results), static_cast&lt;typename Iterator::value_type&gt;(_init));
}
</code></pre>
<p>值得注意的是，上述并行加法的实现对传入数据和迭代器具有一定要求：</p>
<ul>
<li>传入的数据类型的加法计算要求必须是没有特定结合性要求的。</li>
<li><em>std::accumulate</em>要求的迭代器是<em>InputIterator</em>，而<em>parallel_accumulate</em>要求是<em>ForwardIterator</em>。</li>
</ul>
<h2 id="identifying-threads"><a class="header" href="#identifying-threads">Identifying threads</a></h2>
<p><em>std::thread</em>通过<em>std::thread::id</em>来标识一个线程，<em>std::thread::id</em>通过默认构造指代一个无关联线程的<em>std::thread</em>，并且提供比较操作符，因此可以用于关联容器的键值、排序、比较等操作。</p>
<pre><code class="language-c++">std::thread::id masterThreadId;
void func() {
    if(std::this_thread::get_id == masterThreadId) {
        do_something();
    }
    do_otherthing();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="share-date-protection"><a class="header" href="#share-date-protection">Share Date Protection</a></h1>
<h2 id="problem-with-sharing-data-between-threads-and-race-condition"><a class="header" href="#problem-with-sharing-data-between-threads-and-race-condition">Problem with sharing data between threads and race condition</a></h2>
<p>当多个线程的共享数据是只读<em>readonly</em>的情况，是不会产生额外要分析的问题的。但当多个线程其中包含又对共享数据写权限的线程时候，就会产生额外的问题。</p>
<p>在编程过程中，往往有许多不变式<em>invariants</em>帮助我们理解代码的含义，但是这种不变式往往会在数值更新时被破坏，越是复杂的数据类型，越是在更新时进行多的操作的类型，这个破坏不变式的过程越容易在多线程编程中引发问题。</p>
<p>比如一个双向链表<em>doubly linked list</em>包含不定式：</p>
<ul>
<li>节点A的后向指针指向节点B，则有节点B的前向指针指向节点A。</li>
</ul>
<p>在某些链表操作就会短时间内破坏这个不定式，如删除节点N：</p>
<ol>
<li>找到节点N</li>
<li>将节点N的前节点的后向指针指向节点N的后节点</li>
<li>将节点N的后节点的前向指针指向节点N的前节点</li>
<li>删除节点N</li>
</ol>
<p>在步骤2-3之间，双向链表的一个重要的不定式被破坏。若在其他线程的逻辑中有用到该不定式的代码，该代码将会产生未定义后果。</p>
<p>这是在并发编程中常见的BUG原因：<em>race condition</em>，也称<em>data race</em>。</p>
<h3 id="race-condition-and-avoiding-problematic-race-conditions"><a class="header" href="#race-condition-and-avoiding-problematic-race-conditions">Race condition and avoiding problematic race conditions</a></h3>
<p><em>race condition</em>通常指代那些会导致BUG的竞争条件，其带来的BUG通常是未定义行为。</p>
<p><em>race condition</em>主要是各线程对共享数据的修改导致的。其带来的BUG对时间十分敏感，在DEBUG的模式下很容易被忽略。当修改操作被连续的计算机指令执行时，<em>race condition</em>的概率较低；随着计算机负荷的上升，有问题的竞争操作的发生概率也随之提高。</p>
<p>解决<em>race condition</em>的主要办法有以下几种：</p>
<ol>
<li>使用保护机制封装共享数据，保证只有一个线程能改变数据并且其他线程只能在该操作尚未发生或者已经结束的情况下访问数据，即<em>mutex</em>。</li>
<li>改造共享数据结构的设计，使得该结构进行的修改操作不会破坏数据结构的不变性，即<em>lock-free programing</em>。</li>
<li><em>software transactional memory</em>，STM</li>
</ol>
<h2 id="protecting-shared-data-with-mutexes"><a class="header" href="#protecting-shared-data-with-mutexes">Protecting shared data with mutexes</a></h2>
<p>解决<em>race condition</em>的一种通用方法就是将访问共享数据的代码块设置为互斥，即<em>mutually exclusive</em>。这样一来当有线程访问共享数据，其他线程就必须等待访问结束后再进行访问。</p>
<p>这一过程使用<em>mutex</em>来实现，在访问共享数据前，<em>lock</em>一个和该数据关联的<em>mutex</em>；在访问结束后，<em>unlock</em>这个<em>mutex</em>。</p>
<p>标准线程库保证了当一个线程锁定一个<em>mutex</em>，其他试图锁定该<em>mutex</em>的线程都要等候至该<em>mutex</em>被解锁。</p>
<p>互斥器<em>mutex</em>听起来十分简单，但非银弹：</p>
<ol>
<li>构造好代码结构保护目标数据</li>
<li>防止<em>race condition</em>在接口之间传递</li>
<li><em>mutex</em>自身存在<em>deadlock</em>等问题</li>
</ol>
<h3 id="using-mutexes-in-c"><a class="header" href="#using-mutexes-in-c">Using mutexes in C++</a></h3>
<p>C++标准库通过<em>std::mutex</em>实现<em>mutex</em>：</p>
<ul>
<li><em>lock()<em>锁定</em>mutex</em>，当不能锁定时阻塞。</li>
<li><em>unlock()<em>解锁</em>mutex</em>。</li>
</ul>
<p>并且有<em>RAII</em>风格的<em>std::lock_guard</em>来替代手动的<em>unlock</em>。</p>
<pre><code class="language-c++">    class listForThread {
    public:
        void pushToList(int _val) {
            std::lock_guard&lt;std::mutex&gt; lguark(m_mutexForList);
            m_list.push_back(_val);
        }
        bool findInList(int _val) {
            std::lock_guard&lt;std::mutex&gt; lguark(m_mutexForList);
            return std::find(std::begin(m_list), std::end(m_list), _val) != m_list.end();
        }
    private:
        std::list&lt;int&gt; m_list;
        std::mutex m_mutexForList;
    };
</code></pre>
<p>通过上述代码，实现了<em>list</em>的<em>find</em>和<em>push</em>两种操作的互斥。</p>
<p>但是需要非常注意的是，即使所有操作都使用<em>std::mutex</em>实现操作互斥，但是函数接口仍然有可能会将<em>race condition</em>泄露。比如：</p>
<pre><code class="language-c++">    class listForThread {
    public:
        typename std::list&lt;int&gt;::iterator beginOfList() {
            std::lock_guard&lt;std::mutex&gt; lguark(m_mutexForList);
            ...
            return m_list.begin();
        }
    }
</code></pre>
<p>该代码将内部数据的一个迭代器向外传递。外部代码则可以绕过类接口直接访问内部链表，导致<em>race condition</em>。因此函数接口涉及指针、引用和迭代器时，需要格外注意产生<em>race condition</em>的泄露。良好的互斥设计应该包含整个数据访问的过程，而不是仅仅是简单的函数开头与结尾。</p>
<h3 id="structuring-code-for-protecting-shared-data"><a class="header" href="#structuring-code-for-protecting-shared-data">Structuring code for protecting shared data</a></h3>
<p>使用<em>mutex</em>保护数据的代码设计十分复杂，不仅仅是使用<em>std::lock_guard</em>和注意函数是否有指针引用接口就完事的。某些隐藏性很强的接口也有可能会使得<em>race condition</em>泄露：</p>
<pre><code class="language-c++">    class data {
    public:
        void some_func();
    prvate:
        int i;
    };

    class data_wraper {
    public:
        template&lt;typename Func&gt;
        void someFunc(Func f) {
            std::lock_guard&lt;std::mutex&gt; g(m_mutex);
            f(m_data);
        }
    private:
        data m_data;
        std::mutex m_mutex;
    };

    data* p;
    void maliciousFunc(data&amp; _d) {
        p = &amp;_d;
    }

    void foo() {
        data_wraper d;
        d.someFunc(maliciousFunc);
        p-&gt;somefunc();
    }
</code></pre>
<p>这种<em>race condition</em>泄露的问题的根本原因是没有做到：将所有涉及访问目标数据块的操作标示为互斥。因此使用<em>std::mutex</em>遵守以下原则以避免<em>race condition</em>外泄：</p>
<ul>
<li>不要将被保护数据的指针和引用传出<em>mutex lock</em>的范围，不论是显式的还是隐式，比如传参、返回、传递给未知实现的函数。</li>
</ul>
<h3 id="spotting-race-conditions-inherent-in-interfaces"><a class="header" href="#spotting-race-conditions-inherent-in-interfaces">Spotting race conditions inherent in interfaces</a></h3>
<p>即使严格遵守了上述原则，函数接口依旧有可能导致潜在的<em>race condition</em>，这是由于函数本身的操作决定的，不仅仅发生在互斥设计中，也会发生在<em>lock-free programing</em>中。</p>
<p>因为并发实现中，可能会使某些函数失去原本的意义，该函数所得到的结果是不可信的，比如<em>stack</em>：</p>
<pre><code class="language-c++">    template&lt;typename T,typename Container=std::deque&lt;T&gt; &gt;
    class stack
    {
    public:
        explicit stack(const Container&amp;);
        explicit stack(Container&amp;&amp; = Container());
        template &lt;class Alloc&gt; explicit stack(const Alloc&amp;);
        template &lt;class Alloc&gt; stack(const Container&amp;, const Alloc&amp;);
        template &lt;class Alloc&gt; stack(Container&amp;&amp;, const Alloc&amp;);
        template &lt;class Alloc&gt; stack(stack&amp;&amp;, const Alloc&amp;);
        bool empty() const;
        size_t size() const;
        T&amp; top();
        T const&amp; top() const;
        void push(T const&amp;);
        void push(T&amp;&amp;);
        void pop();
        void swap(stack&amp;&amp;);
    };
</code></pre>
<p>栈的操作只有5种，在并发编程中，函数<em>empty</em>和<em>size</em>将不再可信。因为其一旦完成了操作，则其他线程就可以访问改变<em>stack</em>，在该线程所得的信息将失去意义。假设<em>stack</em>的5种操作都加上了互斥保护，存在以下接口的组合使用：</p>
<pre><code class="language-c++">    stack&lt;int&gt; s;
    if(!s.empty()) {
        const int i = s.top();  // 1
        s.pop();                // 2
        do_something(i);
    }
</code></pre>
<p>其他线程的操作可以插入上述每一行代码之间，导致未定义问题，甚至使程序崩溃。比如在代码1和2之间可以插入<em>pop</em>使得源代码的遍历功能失效。</p>
<p>想要将<em>pop</em>和<em>top</em>纳入互斥保护，就需要有新的实现接口来使得两个操作纳入一个互斥保护，但这又引入了新的异常安全的问题：</p>
<p>比如存在数据类型<em>stack&lt;vector&lt;int&gt;&gt;</em>。接口<em>topandpop</em>为了互斥保护，同时实现了<em>pop</em>和<em>top</em>的功能。但是<em>topandpop</em>为了返回被<em>pop</em>的对象，必须调用<em>std::vector</em>的构造函数，这一过程可能会抛出异常，但是抛出异常时，<em>stack</em>已经被改变。分离的<em>pop</em>和<em>top</em>操作不会有这样的问题，因为当<em>top</em>操作抛出异常时，<em>pop</em>操作还没有执行。为了解决<em>race condition</em>和<em>exception safety</em>纠缠的问题，需要设计好函数接口，有如下几种方法：</p>
<h4 id="pass-a-reference"><a class="header" href="#pass-a-reference">Pass a reference</a></h4>
<p>为了使得构造函数不在接口内部被调用，可以使用引用参数作为返回接口：</p>
<pre><code>std::vector&lt;int&gt; result;
some_stack.pop(result);
</code></pre>
<p>这样就要求用户代码必须先自行进行目标对象的构造，并且要求返回类型是可赋值类型。</p>
<h4 id="require-a-nothrow-copy-constructor-or-move-constructor"><a class="header" href="#require-a-nothrow-copy-constructor-or-move-constructor">Require a nothrow copy constructor or move constructor</a></h4>
<p>许多类型的复制构造函数是<em>nothrow</em>的，即使复制构造函数会抛出异常，还有许多类型的移动构造函数也是<em>nothrow</em>的。可以使用编译期检查<em>std::is_nothrow_copy_constructible</em>和<em>std::is_nothrow_move_constructible</em>。</p>
<h4 id="return-a-pointer-to-the-popped-item"><a class="header" href="#return-a-pointer-to-the-popped-item">Return a pointer to the popped item</a></h4>
<p>可以使用指针返回替代值返回，这样可以使得构造函数在改变<em>stack</em>之前被调用。但是这就涉及到了内存管理，而且对于简单类型而言，这样的开销甚至超出了简单的值返回。可以使用智能指针作为返回类型。</p>
<p>如下实现了引用参数返回和智能指针返回，解决了<em>race condition</em>和<em>exception safety</em>纠缠的问题：</p>
<pre><code class="language-c++">    struct empty_stack: std::exception{
        const char* what() const noexcept;
    };

    template&lt;typename T&gt;
    class threadsafe_stack {
    public:
        threadsafe_stack() {}
        threadsafe_stack(const threadsafe_stack&amp; _stack) {
            std::lock_guard&lt;std::mutex&gt; g(_stack.m);
            m_stack = _stack.m_stack;
        }
        threadsafe_stack&amp; operator=(const threadsafe_stack&amp;) = delete;

        void push(T _val) {
            std::lock_guard&lt;std::mutex&gt; g(m_mutex);
            m_stack.push(_val);
        }
        std::shared_ptr&lt;T&gt; pop() {
            std::lock_guard&lt;std::mutex&gt; g(m_mutex);
            if(m_stack.empty())
                throw empty_stack();
            std::shared_ptr&lt;T&gt; ret(std::make_shared&lt;T&gt;(m_stack.top()));
            m_stack.pop();
            return ret;
        }
        void pop(T&amp; _val) {
            std::lock_guard&lt;std::mutex&gt; g(m_mutex);
            if(m_stack.empty())
                throw empty_stack();
            _val = m_stack.top();
            m_stack.pop();
        }
        bool empty() const {
            std::lock_guard&lt;std::mutex&gt; g(m_mutex);
            return m_stack.empty();
        }

    private:
        std::mutex m_mutex;
        std::stack&lt;T&gt; m_stack;
    };
</code></pre>
<p>实现去除了<em>copy assginment operator</em>，保留了<em>copy constructor</em>。同时在<em>copy constructor</em>也使用了互斥保护。</p>
<p>以上描述的都是因为<em>mutex</em>保护范围不够充分导致<em>race condition</em>的情况，但是如果<em>mutex</em>保护范围过大，会导致线程阻塞时间过长，不仅抹除并发所带来的性能提升，甚至导致其性能还不如单线程实现。</p>
<p>当程序需要多个<em>mutex</em>协作阻塞时，比如同一个类的不同实例，有可能出现多个线程都被<em>mutex</em>阻塞，等待其他线程，即死锁<em>deadlock</em>。</p>
<h1 id="dead-lock"><a class="header" href="#dead-lock">Dead lock</a></h1>
<h2 id="dead-lock-problem-and-solution"><a class="header" href="#dead-lock-problem-and-solution">Dead lock problem and solution</a></h2>
<p>当并发编程中，使用了多个<em>mutex</em>用于竞争资源的管理，就有可能使得多个线程同时出现无限期的阻塞，即<em>dead lock</em>。比如线程1占用了资源1并阻塞等待资源2，线程2占用了资源2并阻塞等待资源1，那线程1和2都会无限期阻塞下去。</p>
<p>为了解决<em>dead lock</em>问题，最直接的手段就是确定一个<em>mutex</em>的执行顺序，并严格按照其进行：如果总是将锁定<em>mutex A</em>放在锁定<em>mutex B</em>之前，那么就不会出死锁。在<em>mutexes</em>具有不同的用途时，这种方法能够工作的很好。</p>
<p>但是存在多个<em>mutex</em>用于一个用途的情况，最常见的就是一个类型的不同实例。比如存在有两个实例进行交换的友元操作<em>swap</em>:</p>
<pre><code class="language-c++">    class obj;
    void swap(obj&amp;,obj&amp;);

    class X {
    private:
        obj data;
        std::mutex m;
    public:
        X(const obj&amp; _data) : data(_data) {}
        friend void swap(X&amp; lhs, X&amp; rhs) {
            if(&amp;lhs == &amp;rhs)
                return;
            std::lock_guard&lt;std::mutex&gt; g1(lhs.m);
            std::lock_guard&lt;std::mutex&gt; g2(rhs.m);
            swap(lhs.data, rhs.data);
        }
    };
</code></pre>
<p><em>swap</em>操作总是先锁定第一参数的<em>mutex</em>，后锁定第二参数的<em>mutex</em>。当有两个线程同时执行了对两个实例进行<em>swap</em>操作，但是参数顺序相反，就会出现死锁。为了解决该问题，标准库提供了<em>std::lock</em>解决该问题：</p>
<pre><code class="language-c++">    class X {
    public:
        friend void swap(X&amp; lhs, X&amp; rhs) {
            if(&amp;lhs == &amp;rhs)
                return;
            std::lock(lhs.m, rhs.m);            // 1
            std::lock_guard&lt;std::mutex&gt; g1(lhs.m, std::adopt_lock);     // 2
            std::lock_guard&lt;std::mutex&gt; g2(rhs.m, std::adopt_lock);     // 3
            swap(lhs.data, rhs.data);
        }
    }
</code></pre>
<p>代码1用于锁定两个<em>mutex</em>并且防止死锁，代码2和3用于创建<em>RAII</em>形式的<em>mutex</em>管理，<em>std::adopt_lock</em>指明<em>mutex</em>已经锁定，<em>std::lock_guard</em>只需要接管<em>mutex</em>即可。这样就可以保证函数不论是正常退出还是异常退出时，<em>mutex</em>被正确解锁；<em>std::lock</em>也有可能抛出异常，但是其保证抛出异常后所有<em>mutex</em>处于<em>unlock</em>状态。</p>
<p><em>std::lock</em>可以帮助解决多个<em>std::mutex</em>同时锁定时的<em>dead lock</em>问题，但是对于分离式的无能为力。多线程编程时遵循一些原则可以帮助实现<em>deadlock-free</em>的代码。</p>
<h2 id="further-guideline-for-avoiding-deadlock"><a class="header" href="#further-guideline-for-avoiding-deadlock">Further guideline for avoiding deadlock</a></h2>
<p><em>deadlock</em>不仅仅发生在<em>lock</em>的情况下，只要线程之间有可能出现存在彼此等待对方的情况就会存在死锁的情况，利用<em>join</em>就能创造出死锁：</p>
<pre><code class="language-c++">    void g(std::thread&amp; t) {
        std::this_thread::sleep_for(2s);
        t.join();
    }

    int main() {
        std::this_thread::sleep_for(2s);
        std::thread t1;
        std::thread t2(g, std::ref(t1));
        t1 = std::thread(g, std::ref(t2));
        while(t1.joinable()||t2.joinable())
            ;
    }
</code></pre>
<p>主线程创建了两个子线程，两个线程都在等待对方的join(),从而出现<em>deadlock</em>。</p>
<h3 id="avoid-nested-locks"><a class="header" href="#avoid-nested-locks">Avoid nested locks</a></h3>
<p>避免嵌套的<em>lock</em>，可以完全避免由锁定导致的<em>deadlock</em>。当使用多个<em>lock</em>时，使用<em>std::lock</em>来避免死锁。</p>
<h3 id="avoid-calling-user-supplied-code-while-holding-a-lock"><a class="header" href="#avoid-calling-user-supplied-code-while-holding-a-lock">Avoid calling user-supplied code while holding a lock</a></h3>
<p>在存在<em>lock</em>的情况下，避免使用用户提供的代码。这和避免<em>lock</em>嵌套是一个道理，因为用户代码可能会涉及<em>lock</em>操作。但是有时这也是无法避免的，比如泛型编程和函数式编程，永远不可能知道用户提供的类型和操作是怎样的。</p>
<h3 id="acquire-locks-in-a-fixed-order"><a class="header" href="#acquire-locks-in-a-fixed-order">Acquire locks in a fixed order</a></h3>
<p>如果的确需要进行多个<em>lock</em>操作，并且无法应用<em>std::lock</em>，就应当遵循“在所有线程中按固定顺序进行<em>lock</em>相关操作”的原则。</p>
<p>有时这种要求的实现是很简单的，比如之前的<em>thread_safe stack</em>。因为<em>stack</em>会调用用户代码，所以只要用户代码不会进行改变<em>stack</em>的结构就能保证锁定的稳定顺序。</p>
<p>但有时就很难保证，具有隐藏风险导致锁定顺序被破坏，比如之前因为用户代码的不同就会导致<em>swap</em>死锁。这种情况可以使用<em>std::lock</em>解决，但是有些情况就不行。比如使用一系列的<em>mutex</em>分别保护双向链表的每个节点，这样可以实现多个线程同时访问一个链表。所有操作总是先锁定靠前节点再锁定靠后节点，可以避免死锁的情况，但是这就不能实现反向遍历链表。</p>
<h3 id="use-a-lock-hierarchy"><a class="header" href="#use-a-lock-hierarchy">Use a lock hierarchy</a></h3>
<p>使用有层次的<em>mutex</em>，即使得<em>mutex</em>自身具有限制顺序的能力，比如不能够在拥有低层的<em>mutex</em>的情况锁定高层的<em>mutex</em>。</p>
<pre><code class="language-c++">    hierarchical_mutex high_level_mutex(10000);
    hierarchical_mutex low_level_mutex(5000);
    int do_low_level_stuff();
    int low_level_func() {
        std::lock_guard&lt;hierarchical_mutex&gt; lk(low_level_mutex);
        return do_low_level_stuff();
    }

    void high_level_stuff(int some_param);
    void high_level_func() {
        std::lock_guard&lt;hierarchical_mutex&gt; lk(high_level_mutex);
        high_level_stuff(low_level_func());
    }

    void thread_a(){
        high_level_func();
    }

    hierarchical_mutex other_mutex(100);
    void do_other_stuff();
    void other_stuff() {
        high_level_func();
        do_other_stuff();
    }

    void thread_b() {
        std::lock_guard&lt;hierarchical_mutex&gt; lk(other_mutex);
        other_stuff();
    }
</code></pre>
<p><em>thread_a</em>可以正常工作，而<em>thread_b</em>就会触发<em>hierarchical__mutex</em>的异常。</p>
<p><em>hierarchical_mutex</em>的实现也比较简单，相当于对<em>std::mutex</em>座一层封装，应当保持<em>std::mutex</em>应有的接口以保证和标准库的兼容：</p>
<pre><code class="language-c++">    class hierarchical_mutex {
    public:
        hierarchical_mutex() = delete;
        hierarchical_mutex(const hierarchical_mutex&amp;) = delete;
        explicit hierarchical_mutex(unsigned int _val) 
            :hierarchyValue(_val), previousHierarchyValue(0) {}
        ~hierarchical_mutex() {	}

        void lock() {
            checkForHierarchyRule();
            internalMutex.lock();
            updateHierarchyValue();
        }
        void unlock() {
            internalMutex.unlock();
            thisThreadHierarchyValue = previousHierarchyValue;
        }
        bool try_lock() {
            checkForHierarchyRule();
            if(!internalMutex.try_lock())
                return false;
            updateHierarchyValue();
            return true;
        }
    private:
        std::mutex internalMutex;
        unsigned int hierarchyValue;
        unsigned int previousHierarchyValue;
        static thread_local unsigned int thisThreadHierarchyValue;
        void checkForHierarchyRule() {
            if(hierarchyValue &gt;= thisThreadHierarchyValue) {
                throw std::logic_error(&quot;mutex hierarchy violated&quot;);
            }
        }
        void updateHierarchyValue() {
            previousHierarchyValue = thisThreadHierarchyValue;
            thisThreadHierarchyValue = hierarchyValue;
        }
    };

    thread_local unsigned int hierarchical_mutex::thisThreadHierarchyValue(UINT_MAX);
</code></pre>
<p><em>thisThreadHierarchyValue</em>是一个静态线程存储周期的类成员变量，用于记录线程层次，每个线程都各自拥有自己的记录，并初始化为最大值，为所有在该线程被使用的<em>mutex</em>共享：</p>
<p>每当有新的<em>hierarchical mutex</em>在该线程要求<em>lock</em>时，将会将<em>mutex</em>的层次和线程层次进行对比，若该线程层次已经高于<em>mutex</em>的层次，则正常进行<em>lock</em>操作；否则抛出异常进行异常处理。</p>
<p><em>try_lock</em>操作同理。</p>
<p>当一个<em>mutex</em>进行<em>unlock</em>操作时，线程层次将退回该<em>mutex</em>进行<em>lock</em>之前的值。</p>
<p>应当配合<em>std::lock_guard</em>或者<em>std::lock</em>来保证<em>hierarchical mutex</em>的正常使用。</p>
<p>当然这种实现也可以作为多线程设计的一种参考，即使不用于运行期检查。</p>
<h3 id="extending-these-guidelines-beyond-locks"><a class="header" href="#extending-these-guidelines-beyond-locks">Extending these guidelines beyond locks</a></h3>
<p><em>deadlock</em>不一定要求出现<em>lock</em>，任何同步构建的过程都有可能造成等待死循环，从而导致<em>deadlock</em>。所以应当将上述建议扩充，比如：避免在持有<em>lock</em>的情况下，进行等待其他线程的行为；尽量只在开启子线程的线程中进行该线程的<em>join</em>。</p>
<p>使用<em>std::lock_guard</em>和<em>std::lock</em>代替直接操作<em>std::mutex</em>。</p>
<h2 id="flexible-locking-with-stdunique_lock"><a class="header" href="#flexible-locking-with-stdunique_lock">Flexible locking with std::unique_lock</a></h2>
<p>标准库提供了比<em>std::lock_guard</em>更加灵活的<em>std::unique_lock</em>:它关联一个<em>std::mutex</em>而不像<em>std::lock_guard</em>完全持有。</p>
<p><em>std::unique_lock</em>提供了和<em>std::mutex</em>一样的一套<em>lock</em>操作，</p>
<p><em>std::unique_lock</em>提供了<em>std::defer_lock</em>，<em>std::defer_lock</em>使得<em>std::unique_lock</em>的构造函数不进行<em>lock</em>操作，可以延后手动进行<em>std::lock</em>操作。</p>
<p>但提供额外灵活性的同时<em>std::unique_lock</em>会要求更多的存储空间用于存储状态，以及稍慢的运行效率：</p>
<pre><code class="language-c++">    class some_big_object;
    void swap(some_big_object&amp; lhs,some_big_object&amp; rhs);

    class X {
    private:
        some_big_object some_detail;
        std::mutex m;
    public:
        X(some_big_object const&amp; sd):some_detail(sd){}
        friend void swap(X&amp; lhs, X&amp; rhs) {
            if(&amp;lhs==&amp;rhs)
                return;
            std::unique_lock&lt;std::mutex&gt; lock_a(lhs.m,std::defer_lock);
            std::unique_lock&lt;std::mutex&gt; lock_b(rhs.m,std::defer_lock);
            std::lock(lock_a,lock_b);
            swap(lhs.some_detail,rhs.some_detail);
        }
    }
</code></pre>
<p><em>std::unique_lock</em>还提供移动构造函数和移动赋值操作符来传递<em>std::mutex</em>的所有权，是典型的可移动不可拷贝对象。</p>
<p><em>std::lock_guard</em>提供了最简单<em>std::mutex</em>锁定管理的RAII实现，意味着其无法穿过其作用域发挥锁定作用，而<em>std::unique_lock</em>可以通过转移持有权来使得锁定穿越其生命周期：</p>
<pre><code class="language-c++">    std::unique_lock&lt;std::mutex&gt; get_lock() {
        extern std::mutex some_mutex;
        std::unique_lock&lt;std::mutex&gt; lk(some_mutex);
        prepare_data();
        return lk;
    }
    void process_data() {
        std::unique_lock&lt;std::mutex&gt; lk(get_lock());
        do_something();
    }
</code></pre>
<p>通过转移<em>std::mutex</em>的持有权，其锁定就可以连续的发生在两个函数的生命周期内，从process_data开始，穿过get_lock，直到process_data结束。</p>
<p>同时<em>std::unique_lock</em>也提供了提前解锁或者释放<em>std::mutex</em>的能力，这意味锁定可以在<em>std::unique_lock</em>的生命周期内结束。因为长时间的锁定会造成严重的性能问题，应当以“必要时锁定”为设计目标，<em>std::lock_guard</em>不具备这样的能力。</p>
<h1 id="alternative-facilities-for-protecting-shared-data"><a class="header" href="#alternative-facilities-for-protecting-shared-data">Alternative facilities for protecting shared data</a></h1>
<h2 id="lock-at-an-appropriate-granularity"><a class="header" href="#lock-at-an-appropriate-granularity">Lock at an appropriate granularity</a></h2>
<p>一个良好的多线程数据的互斥设计应该至少有以下两方面：</p>
<ol>
<li>锁的数据保护范围应该恰好只保护需要该锁保护的数据。（大小）</li>
<li>锁应当只保护那些需要其保护的操作。（时间）</li>
</ol>
<blockquote>
<p>Not only is it important to choose a sufficiently coarse lock granularity to ensure the required data is protected, but it’s also important to ensure
that a lock is held only for the operations that actually require it.</p>
</blockquote>
<p>即，如果多个线程都在等待同一个资源，如果一个线程在其不需要该资源的情况下持有该资源的互斥锁，就会增加整个系统的时间开销。因此在持有锁的情况下：不要进行高时间消耗的行为，比如I/O。</p>
<blockquote>
<p>In particular, don’t do any really time-consuming activities like file I/O while
holding a lock.</p>
</blockquote>
<p><em>std::unique_lock</em>的灵活性使得能够在必要的时候释放锁，进行不相关的耗时操作：</p>
<pre><code class="language-c++">    void get_and_process_data()
    {
        std::unique_lock&lt;std::mutex&gt; my_lock(the_mutex);
        some_class data_to_process=get_next_data_chunk();
        my_lock.unlock();
        result_type result=process(data_to_process);    // 1
        my_lock.lock();
        write_result(data_to_process,result);
    }
</code></pre>
<p>因为在代码1时，不用锁相关的资源，可以先释放锁，让其他线程可以访问该资源。</p>
<blockquote>
<p>In general, a lock should be held for only the
minimum possible time needed to perform the required operations</p>
</blockquote>
<p>为了多线程的效率，应该是锁尽可能的持续最短的时间，比如进行两个int型的比较，由于<em>int</em>的拷贝成本很低，可以将两者先拷贝再比较拷贝副本的的大小，避免在比较过程中持有两者的锁：</p>
<pre><code class="language-c++">    class Y
    {
    private:
        int some_detail;
        mutable std::mutex m;
        int get_detail() const {
            std::lock_guard&lt;std::mutex&gt; lock_a(m);
            return some_detail;
        }
    public:
        Y(int sd):some_detail(sd){}
        friend bool operator==(Y const&amp; lhs, Y const&amp; rhs) {
            if(&amp;lhs==&amp;rhs)
                return true;
            int const lhs_value=lhs.get_detail();
            int const rhs_value=rhs.get_detail();
            return lhs_value==rhs_value;
        }
    };
</code></pre>
<p>值得注意的是，通过以上的代码虽然减少了锁的持有时间，同时避免了死锁的出现，但同时也改变了这个操作的语义。</p>
<ul>
<li>原语义，锁定两个<em>int</em>后，比较锁定之后的值并返回比较结果并释放锁。</li>
<li>后语义，锁定一个<em>int</em>，取副本，释放锁；锁定另一个<em>int</em>，取副本，释放锁；比较两个副本的值并返回结果。</li>
</ul>
<p>这样两种语义下，其他线程可进行的操作是不一样的；比如前者无法在该操作中插入<em>swap</em>这样的操作，然而后者可以在两次取副本之间进行这样的操作:</p>
<blockquote>
<p>if you don’t hold the required locks for the entire duration of an operation, you’re exposing yourself to
race conditions</p>
</blockquote>
<p>互斥设计就是要找到一个合适的<em>granularity</em>，但是这种设计可能是不存在的，因为不同的线程需要的数据保护等级不同，仅仅靠基本的<em>std::mutex</em>难以实现。C++标准库提供了一些替代<em>std::mutex</em>和<em>lock</em>的机制。</p>
<h2 id="protecting-shared-data-during-initialization"><a class="header" href="#protecting-shared-data-during-initialization">Protecting shared data during initialization</a></h2>
<p>有一些初始化是十分消耗资源的，所以实现总是希望在真正需要的时候进行这样的初始化，比如打开数据库，申请大块内存等等操作。</p>
<p><em>lazy initialization</em>是一种常见的单线程代码：在使用资源前检查资源是否初始化，如若未初始化则初始化后使用：</p>
<pre><code class="language-c++">    std::shared_ptr&lt;resource&gt; resource_ptr;
    void foo() {
        if(!resource_ptr)
            resource_ptr.reset(std::make_shared&lt;resource&gt;());
        resource_ptr-&gt;do();
    }
</code></pre>
<p>如果资源类型<em>resource</em>自身能够保证线程安全，那上述代码转化成多线程代码只需要保护初始化即可：</p>
<pre><code class="language-c++">    std::shared_ptr&lt;resource&gt; resource_ptr;
    std::mutex resource_mutex;
    void foo() {
        std::unique_lock&lt;std::mutex&gt; lk(resource_mutex);
        if(!resource_ptr)
            resource_ptr.reset(std::make_shared&lt;resource&gt;());
        lk.unlock;          // because resource itself is safe for concurrency.
        resource_ptr-&gt;do();
    }
</code></pre>
<p>因为资源类型本身保证并发安全，所以在初始化之后就可以解开锁。</p>
<p>但上述代码有一个致命的缺陷，因为所有线程执行<em>foo</em>，都必然会先上锁，后检查资源是否初始化完成，这显然在初始化完毕后是不必要的，违反了多线程设计的原则：</p>
<blockquote>
<p>Not only is it important to choose a sufficiently coarse lock granularity to ensure the required data is protected, but it’s also important to ensure
that a lock is held only for the operations that actually require it.</p>
</blockquote>
<p>为了解决这个问题，有许多“更好”的办法被应用，比如<em>infamous</em>的<em>double checked locking</em>模式：</p>
<pre><code class="language-c++">    void UB_with_double_checked_locking() {
        if(!resource_ptr) {
            std::unique_lock&lt;std::mutex&gt; lk(resource_mutex);
            if(resource_ptr) {
                resource_ptr.reset(std::make_shared&lt;resource&gt;());
            }
        }
        resource_ptr-&gt;do();
    }
</code></pre>
<p>因为外部指针检查和内部的资源初始化不同步，有可能内部资源的初始化尚未完成，但指针检查已经指示资源已经初始化完成（空间分配完成），所以其他线程可能会在初始化未完成时执行<em>do</em>，造成<em>data race</em>，是一种未定义行为。</p>
<p>C++标准库提供了<em>std::once_flag</em>和<em>std::call_once</em>来处理这种情况，使用<em>std::once</em>一般可以比使用<em>lock</em>占用更少的消耗，特别是初始化完成后：</p>
<pre><code class="language-c++">    std::shared_ptr&lt;resource&gt; resource_ptr;
    std::once_flag resource_flag;

    void init_resource() {
        resource_ptr.reset(std::make_shared&lt;resource&gt;());
    }

    void foo() {
        std::call_once(resource_flag, init_resource);
        resource_ptr-&gt;do();
    }
</code></pre>
<p><em>std::call_once</em>保证同一个<em>std::once_flag</em>对象指示的可调用对象在多个线程中只会执行一次：</p>
<ul>
<li>可调用对象的参数由被选中执行的线程的<em>std::call_once</em>传入的参数决定。</li>
<li>异常引起的函数退出不会归入“执行一次”的范畴。</li>
<li>如果某线程被选中执行的函数因为异常退出，并会返回给调用者。其他线程中的函数会被选中继续执行，知道成功执行一次。</li>
</ul>
<p><em>std::call_once</em>也可以用于成员变量的初始化：</p>
<pre><code class="language-c++">    class X {
    public:
        void send(const data_packet&amp; data) {
            std::call_once(connection_init_flag, &amp;X::open_connection, this);
            connection.send(data);
        }
        void receive(data_packet&amp; data) {
            std::call_once(connection_init_flag, &amp;X::open_connection, this);
            connection.receive(data);
        }
    private:
        connection_info connection_details;
        connection_handle connection;
        std::once_flag connection_init_flag;
        void open_connection() {
            connection = connection_manager.open(connection_details);
        }
    };
</code></pre>
<p>另一个可能出现<em>data race</em>的初始化场景就是静态局部变量，因为静态局部变量在运行至其声明初进行初始化，不同的线程会出现<em>data race</em>，通过<em>std::call_once</em>可以避免：</p>
<pre><code class="language-c++">    class my_class;
    std::once_flag my_class_flag;
    my_class&amp; get_my_class_instance() {
        static my_class instance;
        return instance;
    }

    void foo() {
        std::call_once(my_class_flag, get_my_class_instance);
        ...
    }
</code></pre>
<h2 id="protecting-rarely-updated-data-structures"><a class="header" href="#protecting-rarely-updated-data-structures">Protecting rarely updated data structures</a></h2>
<p>“仅在初始化保护”其实是“保护稀少更新数据”的一种特殊情况。比如一样数据长时间只更新一次或者很少更新，平常表现基本等同于<em>read—only</em>数据。比如：</p>
<p>DNS储存着“域名-IP”的表，这种数据长时间不会进行更新。因此除去“写操作”以外，其他所有“读操作”可以同时访问数据并且不会出现<em>race condition</em>。那么就希望：</p>
<ul>
<li>“写操作”：只允许当前线程对数据进行访问，即<em>exclusive</em>。</li>
<li>“读操作”：允许其他线程一起对数据进行访问，即<em>shared</em>。</li>
</ul>
<p>如果使用<em>std::mutex</em>，因为<em>std::mutex</em>只有一种锁定状态，即“exclusive”。需要其他类型的<em>mutex</em>替代。</p>
<p>C++17提供了<em>std::shared_mutex</em>用于该控制（C++ concurrency in action举的是boost库的内容，因为那时<em>std::shared_mutex</em>未被纳入标准库），其具有两种锁定状态<em>shared</em>和<em>exclusive</em>：</p>
<pre><code class="language-c++">    #include &lt;map&gt;
    #include &lt;string&gt;
    #include &lt;mutex&gt;
    #include &lt;shared_mutex&gt;

    class dns_entry;
    class dns_cache {
    private:
        std::map&lt;std::string, dns_entry&gt; entries;
        mutable std::shared_mutex entry_mutex;
    public:
        dns_entry find_entry(const std::string&amp; domain) const {
            std::shared_lock&lt;std::shared_mutex&gt; slk(entry_mutex);
            auto it = entries.find(domain);
            return (it == entries.end())?dns_entry():it-&gt;second;
        }  // read operation

        void update_or_add_entry(const std::string&amp; domain, const dns_entry&amp; dns_details) {
            std::lock_guard&lt;std::shared_mutex&gt; lk(entry_mutex);
            entries[domain] = dns_details;
        }
    };
</code></pre>
<h2 id="recursive-locking"><a class="header" href="#recursive-locking">Recursive locking</a></h2>
<p>对已经锁定的<em>std::mutex</em>再次进行锁定是UB，但有些情况下期待能够递归锁定一个互斥器。C++标准库提供了<em>std::recursive_mutex</em>。一个线程可以反复给<em>std::recursive_mutex</em>多次上锁，但同时在释放锁时也是进行同样次数的解锁。比如一个类的成员函数彼此发生调用，使用<em>std::mutex</em>会导致UB，使用<em>std::recursive_mutex</em>可以避免。</p>
<p>多数情况下，<em>recursive_mutex</em>都是可以用其他<em>mutex</em>配合良好的设计替代，尽量不要使用<em>recursive_mutex</em>造成设计混乱。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operation-synchronization"><a class="header" href="#operation-synchronization">Operation Synchronization</a></h1>
<h1 id="waiting-for-events"><a class="header" href="#waiting-for-events">Waiting for events</a></h1>
<h2 id="why-do-not-use-shared-data-to-synchronize-operation"><a class="header" href="#why-do-not-use-shared-data-to-synchronize-operation">Why do not use shared data to synchronize operation</a></h2>
<p>并发编程中，经常会碰见多个线程之间的操作同步<em>operation synchronization</em>。实现操作同步很容易想到利用一个共享数据进行同步，即线程A会通过改变一个<em>flag</em>发出同步信号，使得线程B通过检查<em>flag</em>实现同步：</p>
<pre><code class="language-c++">    bool flag;
    std::mutex flag_mutex;

    void wait_flag() {
        std::unique_lock&lt;std::mutex&gt; lk(flag_mutex);
        while(!flag) {
            lk.unlock();
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
            lk.lock();
        }
        dosomething();
    }
</code></pre>
<p>线程B每隔100ms上一次锁并检查<em>flag</em>，如果<em>flag</em>为假，继续检查；如果<em>flag</em>为真，则执行<em>dosomething</em>。</p>
<p>但是这种设计有几大缺陷：</p>
<ol>
<li>检查时间间隔难以把握，如果时间太短，导致检查频繁，大量占用资源；如果时间太长，同步反应过慢，产生延迟。</li>
<li>设计逻辑难看</li>
</ol>
<h2 id="condition-variable"><a class="header" href="#condition-variable">Condition variable</a></h2>
<p><em>std::condition_variable</em>提供了在一个线程唤醒其他线程的特性。<em>std::condition_variable</em>通过可以通过一个<em>std::mutex</em>来提供同步功能；<em>std::condition_variable_any</em>可以通过任何一个<em>mutex-like</em>对象进行同步，但需要消耗额外资源。</p>
<pre><code class="language-c++">    std::mutex mut;
    std::queue&lt;data_chunk&gt; data_queue;
    std::condition_variable data_cond;
    // thread A
    void data_preparation_threadA() {
        while(more_data_to_prepare()) {
            data_chunk const data=prepare_data();
            std::lock_guard&lt;std::mutex&gt; lk(mut);
            data_queue.push(data);
            data_cond.notify_one();
        }
    }
    // thread B
    void data_processing_thread() {   
        while(true)
        {
            std::unique_lock&lt;std::mutex&gt; lk(mut) 
            data_cond.wait(lk,[]{return !data_queue.empty();});
            data_chunk data=data_queue.front();
            data_queue.pop();
            lk.unlock();        // unlock before processing
            process(data);
            if(is_last_chunk(data))
                break;
        }
    }
</code></pre>
<p>线程A作用是写入数据并在写入数据后唤醒线程B，线程B的作用是在线程A唤醒后执行数据处理。</p>
<p>线程A得到数据块后先申请队列的锁，上锁后将数据块<em>push</em>进入队列后，调用<em>notify_one</em>唤醒线程B，单次循环结束释放锁；</p>
<p>线程B进入循环，先要求申请队列的锁，然后调用<em>condition_variable</em>的<em>wait</em>，<em>wait</em>有两种形式：</p>
<pre><code class="language-c++">    void wait( std::unique_lock&lt;std::mutex&gt;&amp; lock );

    template&lt; class Predicate &gt;
    void wait( std::unique_lock&lt;std::mutex&gt;&amp; lock, Predicate pred );
</code></pre>
<p>其中第二中实现相当于：</p>
<pre><code class="language-c++">    while (!pred()) {
        wait(lock);
    }
</code></pre>
<p>每当调用<em>wait</em>时，wait先检验条件<em>pred</em>，如果<em>pred</em>为真则返回；否则调用<em>wait</em>第一种形式，释放锁并且阻塞当前线程直到被线程A唤醒，被唤醒后锁定并且继续检查<em>pred</em>，如果<em>pred</em>为真则返回。因为需要进行灵活的锁定控制，因此传入参数为<em>std::unique_lock</em>。</p>
<p>注意，在代码中调用一次<em>wait</em>时，<em>pred</em>可能会被调用任意次，不要使用一些带有边际效益的处理作为<em>pred</em>，因为存在<em>spurious wake</em>，即线程A并没有做唤醒操作，而线程B被唤醒了。</p>
<h2 id="thread-safe-queue"><a class="header" href="#thread-safe-queue">Thread safe queue</a></h2>
<pre><code class="language-c++">    template&lt;typename T&gt;
    class threadsafe_queue {
    public:
        typename std::queue&lt;T&gt;::size_type size() const {
            std::lock_guard&lt;std::mutex&gt; lk(data_mutex);
            return data.size();
        }

        bool empty() const {
            std::lock_guard&lt;std::mutex&gt; lk(data_mutex);
            return data.empty();
        }

        void push(T new_val) {
            std::lock_guard&lt;std::mutex&gt; lk(data_mutex);
            data.push(new_val);
            data_condition.notify_one();
        }

        bool try_pop(T&amp; val) {
            std::lock_guard&lt;std::mutex&gt; lk(data_mutex);
            if(data.empty())
                return false;
            val = data.front();
            data.pop();
            return true;
        }

        std::shared_ptr&lt;T&gt; try_pop() {
            std::lock_guard&lt;std::mutex&gt; lk(data_mutex);
            if(data.empty())
                return std::shared_ptr&lt;T&gt;();
            std::shared_ptr&lt;T&gt; ret = std::make_shared&lt;T&gt;(data.front());
            data.pop();
            return ret;
        }

        void wait_and_pop(T&amp; val) {
            std::unique_lock&lt;std::mutex&gt; ulk(data_mutex);
            data_condition.wait(ulk, [this] { return !data.empty(); });
            val = data.front();
            data.pop();
        }

        std::shared_ptr&lt;T&gt; wait_and_pop() {
            std::unique_lock&lt;std::mutex&gt; ulk(data_mutex);
            data_condition.wait(ulk, [this] { return !data.empty(); });
            std::shared_ptr&lt;T&gt; ret(std::make_shared&lt;T&gt;(data.front()));
            data.pop();
            return ret;
        }
    private:
        std::queue&lt;T&gt; data;
        mutable std::mutex data_mutex;
        std::condition_variable data_condition;
    };
</code></pre>
<p>注意成员函数中存在<em>const</em>成员函数、复制构造函数和复制赋值操作符，这类操作都会涉及到<em>std::mutex</em>的上锁，但是对<em>const std::mutex</em>上锁是不可能的，所以应该使用<em>mutable</em>修饰<em>std::mutex</em>。</p>
<h1 id="waiting-for-one-off-events"><a class="header" href="#waiting-for-one-off-events">Waiting for one-off events</a></h1>
<p>C++标准库使用<em>std::future</em>来标示一个一次性事件：</p>
<ul>
<li><em>std::future</em>本身是用于提供一个链接异步操作的途径，可以通过：<em>std::async</em>|<em>std::packaged_task</em>|<em>std::promist</em>来构造</li>
<li><em>std::future</em>可以绑定一个异步操作返回的数据块，<em>std::future</em>的持有线程可以通过<em>wait</em>|<em>get</em>|<em>valid</em>等方式进行操作，如果异步操作尚未产生返回，则该方法会产生阻塞。</li>
</ul>
<h2 id="stdasyncreturning-values-from-background-task"><a class="header" href="#stdasyncreturning-values-from-background-task">std::async,returning values from background task</a></h2>
<p><em>std::async</em>通过接受<em>function object</em>产生一个<em>std::future</em>。<em>std::async</em>有一个控制选项：</p>
<ul>
<li>std::launch::async</li>
<li>std::launch::deferred</li>
<li>std::launch::async|std::launch::deferred or default.</li>
</ul>
<p>选项一，总是启用新线程执行<em>callable object</em>（asynchronous execution）；<br />
选项二，在当前线程，第一次获取结果时执行<em>callable object</em>（lazy evaluation）；<br />
选项三，依赖实现。</p>
<p>如下代码实现并行加法：</p>
<pre><code class="language-c++">    template&lt;typename Iterator&gt;
    struct add_block {
        auto operator()(const Iterator _start, const Iterator _stop) {	
            return std::accumulate(_start, _stop, 0);
        }
    };

    template&lt;typename Iterator&gt;
    auto parallel_add(const Iterator _begin, const Iterator _end, typename Iterator::value_type _init) {
        auto arraySize = std::distance(_begin, _end);
        if(!arraySize)
            return _init;
        size_t maxNumHardwareThread = std::thread::hardware_concurrency();
        size_t minAmountPerBlock = 25;
        size_t maxNumSoftwareThread = (arraySize + minAmountPerBlock - 1) / minAmountPerBlock;
        auto numThread = std::min(maxNumSoftwareThread == 0?1:maxNumSoftwareThread, maxNumHardwareThread);
        auto amountPerBlock = arraySize / numThread;
        std::vector&lt;std::future&lt;typename Iterator::value_type&gt;&gt; vecResultPerFuture;
        vecResultPerFuture.reserve(numThread - 1);
        auto _start = _begin;
        auto _stop = _start;
        for(int i = 0; i &lt; numThread - 1; i++) {
            std::advance(_stop, amountPerBlock);
            vecResultPerFuture.emplace_back(std::async(std::launch::async,add_block&lt;Iterator&gt;(), _start, _stop));
            std::advance(_start, amountPerBlock);
        }
        std::vector&lt;typename Iterator::value_type&gt; vecResult;
        vecResult.resize(numThread);
        for(int i = 0; i &lt; numThread - 1;i++) {
            vecResult[i] = vecResultPerFuture[i].get();
        }
        vecResult[numThread - 1] = std::accumulate(_start, _end, _init);
        return std::accumulate(std::begin(vecResult), std::end(vecResult), 0);
    }
</code></pre>
<h2 id="stdpackaged_taskassociating-a-task-with-a-future"><a class="header" href="#stdpackaged_taskassociating-a-task-with-a-future">std::packaged_task，associating a task with a future</a></h2>
<p><em>std::packgaed_task</em>可以包装一个<em>callable object</em>来使得其可以异步调用，返回内容通过<em>std::future</em>来访问。可以用于构建线程池；以及其他任务管理。<br />
<em>std::packaged_task</em>的模板参数是一个函数类型（注意函数类型中存在隐式转换）。<br />
<em>std::packaged_task</em>自身也是一个<em>callable object</em>，可以进一步封装也可以直接调用。<br />
<em>std::packaged_task</em>是<em>movable</em>和<em>swapable</em>的。</p>
<pre><code class="language-c++">    std::mutex m;
    std::deque&lt;std::packaged_task&lt;void()&gt; &gt; tasks;
    bool gui_shutdown_message_received();
    void get_and_process_gui_message();
    void gui_thread()
    {
        while(!gui_shutdown_message_received())
        {
            get_and_process_gui_message();
            std::packaged_task&lt;void()&gt; task;
            {
                std::lock_guard&lt;std::mutex&gt; lk(m);
                if(tasks.empty())
                continue;
                task=std::move(tasks.front());
                tasks.pop_front();
            }
            task();
        }
    }
    std::thread gui_bg_thread(gui_thread);
    template&lt;typename Func&gt;
    std::future&lt;void&gt; post_task_for_gui_thread(Func f)
    {
        std::packaged_task&lt;void()&gt; task(f);
        std::future&lt;void&gt; res=task.get_future();
        std::lock_guard&lt;std::mutex&gt; lk(m);
        tasks.push_back(std::move(task));
        return res;
    }
</code></pre>
<p>来自书上的例子，<em>gui_thread</em>通过一个任务队列接收任务并且执行；<em>post_task_for_gui_thrad</em>通过向一个任务队列加入任务来发布任务，并且将该任务的<em>future</em>返回给外层，注意<em>get_future</em>对于一个任务只能调用一次。</p>
<h2 id="stdpromise-make-promises"><a class="header" href="#stdpromise-make-promises">std::promise, make promises</a></h2>
<p><em>std::promise</em>用于设置一个异步接受的值，<em>movable</em>。</p>
<pre><code class="language-c++">    void accumulate(std::vector&lt;int&gt;::iterator first,
                    std::vector&lt;int&gt;::iterator last,
                    std::promise&lt;int&gt; accumulate_promise)
    {
        int sum = std::accumulate(first, last, 0);
        accumulate_promise.set_value(sum);  // Notify future
    }
    
    void do_work(std::promise&lt;void&gt; barrier)
    {
        std::this_thread::sleep_for(std::chrono::seconds(1));
        barrier.set_value();
    }
    
    int main()
    {
        // Demonstrate using promise&lt;int&gt; to transmit a result between threads.
        std::vector&lt;int&gt; numbers = { 1, 2, 3, 4, 5, 6 };
        std::promise&lt;int&gt; accumulate_promise;
        std::future&lt;int&gt; accumulate_future = accumulate_promise.get_future();
        std::thread work_thread(accumulate, numbers.begin(), numbers.end(), std::move(accumulate_promise));
        accumulate_future.wait();  // wait for result
        std::cout &lt;&lt; &quot;result=&quot; &lt;&lt; accumulate_future.get() &lt;&lt; '\n';
        work_thread.join();  // wait for thread completion
        std::promise&lt;void&gt; barrier;
        std::future&lt;void&gt; barrier_future = barrier.get_future();
        std::thread new_work_thread(do_work, std::move(barrier));
        barrier_future.wait();
        new_work_thread.join();
    }
</code></pre>
<p>来自cppreference的例子，在当前线程使用一个<em>std::future</em>获取一个<em>std::promise</em>的未来结果，让后将<em>promise</em>移动给新线程。新线程执行完成后设置<em>promise</em>的值，当前线程可以通过<em>future</em>获得该值。</p>
<p>*std::promise&lt;void&gt;*用于不需要任何值的情况，可以单纯的用于阻塞或者定时或者标示某些代码块已经执行完成。</p>
<h2 id="saving-exception-for-the-future"><a class="header" href="#saving-exception-for-the-future">Saving exception for the future</a></h2>
<p><em>std::future</em>除了返回值以外也可以返回异常，将异常抛到当前<em>std::future</em>所在线程进行处理，有以下几种情况会使得<em>std::future</em>产生异常。</p>
<ul>
<li><em>std::async</em>和<em>std::packaged_task</em>执行的代码块抛出异常。</li>
<li><em>std::promise</em>设置异常。</li>
<li><em>std::packaged_task</em>和<em>std::promise</em>进行了非法操作。</li>
</ul>
<p>使用get(),重新抛出异常，比如情况一:</p>
<pre><code class="language-c++">    double sqrt_root(int i) { 
        if(i &lt; 
        0)
            throw std::out_of_range(&quot;i&lt;0&quot;);
        return sqrt(i);
    }

    void foo() {
        std::future&lt;double&gt; f = std::async(std::lauch::async, sqrt_root, -1);
        try {
            f.get();
        } catch(const std::out_of_range&amp; e){
            std::cout &lt;&lt; &quot;out_of_range: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;
        }
    }
</code></pre>
<p>情况二：</p>
<pre><code class="language-c++">    void some(std::promise&lt;double&gt; p) {
        try {
            p.set_value(some_func_may_throw());

        } catch(const std::exception&amp; e) {
            p.set_exception(std::current_exception());
        }
    }

    void foo() {
        std::promise&lt;double&gt; p;
        std::future&lt;double&gt; f = p.get_future();
        std::thread t1(some, std::move(p));
        try {
            f.get();
        } catch(const std::exception&amp; e) {
            std::cout &lt;&lt; &quot;out_of_range: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;
        }
    }
</code></pre>
<p>抛出<em>std::future_error</em>，情况三：</p>
<pre><code class="language-c++">    void foo() {
        std::future&lt;double&gt; f;
        {
            std::promise&lt;double&gt; p;
            f = p.get_future();
        }
        try {
            f.get();
        } catch(cosnt std::future_error&amp; e) {
            if(e.code() == std::future_errc::broken_promise)
			std::cout &lt;&lt; &quot;exception: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;
        }
    }
</code></pre>
<h2 id="waiting-from-multiple-threads"><a class="header" href="#waiting-from-multiple-threads">Waiting from multiple threads</a></h2>
<p><em>std::future</em>用于在线程间（或者非线程间）一次性传递各种结果，并且对一个实例的操作没有任何同步行为。如果在多个线程对同一个<em>std::future</em>进行操作就会产生<em>data race</em>。<br />
因此<em>std::future</em>被设计对持有数据为<em>unique ownership</em>，一次绑定只能进行一次<em>get</em>操作，不应该在多个线程引用一个<em>std::future</em>实例。</p>
<p>为了满足多个线程获取同一个消息，<em>std::shared_future</em>被设计为<em>shared ownership</em>。<em>std::future</em>只能被<em>move</em>，数据可以被传递并且只能被<em>get</em>一次。而<em>std::shared_future</em>可以被<em>copy</em>，多个<em>future</em>可以关联同一块数据。</p>
<p>注意为了多个线程访问一块数据不出现<em>data race</em>，应该在不同线程<em>copy</em>一个<em>std::shared_future</em>而不是引用它，因为对于一个实例的不同成员函数并没有同步，一个线程只应该保留一个<em>std::shared_future</em>。</p>
<pre><code class="language-c++">    std::promise&lt;std::string&gt; p;
    std::shared_future&lt;std::string&gt; sf(p.get_future());

    std::promise&lt;int&gt; p;
    std::future&lt;int&gt; f(p.get_future());
    std::shared_future&lt;int&gt; sf(std::move(f));
</code></pre>
<p>使用auto来推断<em>std::shared_future</em>类型：</p>
<pre><code class="language-c++">    std::promise&lt; std::map&lt; SomeIndexType, SomeDataType, SomeComparator,
    SomeAllocator&gt;::iterator&gt; p;
    auto sf=p.get_future().share()
</code></pre>
<h1 id="time-limit"><a class="header" href="#time-limit">Time limit</a></h1>
<h2 id="stdchrono"><a class="header" href="#stdchrono">std::chrono</a></h2>
<p><em>std::chrono</em>是C++11提供的时间库，其中有三个重要概念：</p>
<ul>
<li><em>clock</em>：表示时钟。 </li>
<li><em>duration</em>：表示时间间隔。</li>
<li><em>time_point</em>：表示时间点。</li>
</ul>
<h2 id="clocks"><a class="header" href="#clocks">clocks</a></h2>
<p>一个时钟至少要表达下列4个信息：</p>
<ul>
<li><em>now</em>，现在的时间点。</li>
<li><em>type of value</em>，表达时间的类型。</li>
<li><em>tick period</em>，计数表达的间隔。</li>
<li><em>is_steady</em>，是否可以看作稳定时钟。</li>
</ul>
<p>C++11标准库提供了3种时钟：</p>
<ul>
<li><em>std::chrono::system_clock</em></li>
<li><em>std::chrono::steady_clock</em></li>
<li><em>std::chrono::high_resolution_clock</em></li>
</ul>
<h3 id="stdchronosystem_clock"><a class="header" href="#stdchronosystem_clock">std::chrono::system_clock</a></h3>
<ul>
<li>方法<em>now</em>会返回当前操作系统时钟的时间点。</li>
<li>时钟的起始时刻不定，一般采用<em>Unix Time</em>。</li>
<li>是唯一可以与C标准库<em>std::time_t</em>进行转换的C++标准库时钟。</li>
<li>一般不稳定，因为系统时钟是可以随时更改的。</li>
</ul>
<p>一般用于获取系统时钟，日期，不适合做测量计时。</p>
<h3 id="stdchronosteady_clock"><a class="header" href="#stdchronosteady_clock">std::chrono::steady_clock</a></h3>
<ul>
<li>方法<em>now</em>会返回时钟的时间点。</li>
<li>时钟的起始时刻不定，和系统时钟无关。</li>
<li>总是稳定。</li>
</ul>
<p>一般用于测量计时。</p>
<h3 id="stdchronohigh_resolution_clock"><a class="header" href="#stdchronohigh_resolution_clock">std::chrono::high_resolution_clock</a></h3>
<ul>
<li>方法<em>now</em>会返回当前操作系统时钟的时间点。</li>
<li>提供当前系统最高精度的时钟，有可能会是<em>std::chrono::system_clock</em>和<em>std::chrono::steady_clock</em>别名。</li>
</ul>
<h2 id="duration"><a class="header" href="#duration">duration</a></h2>
<p><em>std::chrono::duration</em>模板用于表示时间段：第一个模板参数为表达时间段的类型，第二个模板参数为模板<em>std::ratio&lt;&gt;<em>用于各种类型的</em>duration</em>的转换以及表达<em>tick period</em>（分数/秒）。</p>
<p><em>std::chrono::duration</em>支持各种时间计算，以及不同时间类型的转换<em>duration_cast</em>。</p>
<p>以及常用的特化：</p>
<pre><code class="language-c++">    std::chrono::nanoseconds
    std::chrono::microseconds
    std::chrono::milliseconds
    std::chrono::seconds
    std::chrono::minutes
    std::chrono::hours
</code></pre>
<p>比如：</p>
<pre><code class="language-c++">    auto a_hour = hours(1);

	std::cout &lt;&lt; &quot;\n&quot; &lt;&lt; a_hour.count() &lt;&lt; &quot; hour is &quot;
		&lt;&lt; duration_cast&lt;minutes&gt;(a_hour).count() &lt;&lt; &quot; minutes\nis &quot;
		&lt;&lt; duration_cast&lt;seconds&gt;(a_hour).count() &lt;&lt; &quot; seconds\nis &quot;
		&lt;&lt; duration_cast&lt;milliseconds&gt;(a_hour).count() &lt;&lt; &quot; milliseconds\n&quot;;

    auto some_seconds = seconds(30);
	std::cout &lt;&lt; &quot;\n&quot; &lt;&lt; a_hour.count() &lt;&lt; &quot; hour minus &quot; &lt;&lt; some_seconds.count()
		&lt;&lt; &quot; seconds leaves &quot; &lt;&lt; (a_hour - some_seconds).count() &lt;&lt; &quot; seconds\n&quot;;
</code></pre>
<h2 id="time-point"><a class="header" href="#time-point">time point</a></h2>
<p>模板<em>std::chrono::time_point</em>用于表达时间点：第一个模板参数<em>Clock</em>用于表达时钟类型，第二个模板参数<em>Duration</em>使用<em>std::chrono::duration</em>的某个特化来表达从<em>epoch</em>开始的时间段（默认使用<em>Clock::duration</em>）。</p>
<p><em>time_point</em>通过某个时间点<em>epoch</em>为基准加上某时间段来表达某个时间点，调用<em>time_since_epoch</em>来返回这个时间间隔。</p>
<p><em>std::chrono::time_point</em>支持各种时间计算，以及不同时间类型的转换<em>duration_cast</em>。</p>
<p>比如：</p>
<pre><code class="language-c++">	using namespace std::chrono;

	time_point&lt;system_clock&gt; t1;
	time_point&lt;system_clock&gt; t2 = system_clock::now();

	// show system time now and epoch
	auto epoch_time = system_clock::to_time_t(t1);
	auto now_time = system_clock::to_time_t(t2);
	std::cout &lt;&lt; &quot;now &quot; &lt;&lt; std::ctime(&amp;now_time);
	std::cout &lt;&lt; &quot;epoch &quot; &lt;&lt; std::ctime(&amp;epoch_time);

	// time arithmetic
	time_point&lt;system_clock&gt; t3 = t2 - hours(24);

	// use time_since_epoch.
	std::cout &lt;&lt; &quot;hours since epoch: &quot;
		&lt;&lt; duration_cast&lt;std::chrono::hours&gt;(
			t2.time_since_epoch()).count()
		&lt;&lt; '\n';
	std::cout &lt;&lt; &quot;yesterday, hours since epoch: &quot;
		&lt;&lt; duration_cast&lt;std::chrono::hours&gt;(
			t3.time_since_epoch()).count()
		&lt;&lt; '\n';
</code></pre>
<h2 id="_until-and-_for"><a class="header" href="#_until-and-_for">_until and _for</a></h2>
<p>标准线程库提供了一系列带有*_until<em>和</em>_for<em>后缀的方法。包括</em>sleep*、<em>condition_variable</em>、<em>future</em>以及前面没有提到的<em>timed_mutex</em>。</p>
<ul>
<li><em>_until</em>表达直到某个时间点<em>std::chrono::time_point</em>。</li>
<li><em>_for</em>表达等待一个时间段<em>std::chrono::duration</em>。</li>
</ul>
<p>这类函数返回会是一个<em>bool</em>或者一个状态值，具体见库。</p>
<h1 id="using-synchronization-of-operations-to-simplify-code"><a class="header" href="#using-synchronization-of-operations-to-simplify-code">Using synchronization of operations to simplify code</a></h1>
<p>C++标准库提供了许多同步操作，通过这些同步操作可以简化多线程的代码并且提高可读性。以下是一些适合于多线程的编程范式。</p>
<h2 id="functional-programing-with-future"><a class="header" href="#functional-programing-with-future">Functional programing with future</a></h2>
<p>C++11中加入了许多函数式编程（<em>functional programing</em>）需要的特性，包括<em>lambda</em>、自动类型推断<em>auto</em>、更好用的合并<em>std::bind</em>。因为严格的函数没有副作用，只需要关心输入和输出，可以极大避免<em>race condition</em>。<br />
<em>std::future</em>的特性，使得多线程编程中使用函数范式更加简单，可以更加简单的将单线程函数式代码改造成多线程函数式代码：</p>
<p>比如一个快排程序：</p>
<pre><code class="language-c++">    template&lt;typename T&gt;
    std::list&lt;T&gt; sequential_qsort(std::list&lt;T&gt; input) {
        if(input.empty())
            return input;
        std::list&lt;T&gt; result;
        result.splice(result.begin(), input, input.begin());
        const T&amp; pivot = *result.begin();
        auto divide_point = std::partition(input.begin(), input.end(), [&amp;pivot](const T&amp; t) { return t &lt; pivot; });

        std::list&lt;T&gt; lower_group;
        lower_group.splice(lower_group.end(), input, input.begin(), divide_point);

        auto lower(sequential_qsort(std::move(lower_group)));
        auto higher(sequential_qsort(std::move(input)));

        result.splice(result.end(), higher);
        result.splice(result.begin(), lower);
        return result;
    }
</code></pre>
<p>函数的接口是FP形式的，但是为了避免过多的复制操作，内部操作并不是严格的函数式。为了将其改造成多线程代码，可以开辟出一个新线程负责划分后的一半数据的快排：</p>
<pre><code class="language-c++">    template&lt;typename T&gt;
    std::list&lt;T&gt; parallel_qsort(std::list&lt;T&gt; input) {
        if(input.empty())
            return input;
        std::list&lt;T&gt; result;
        result.splice(result.begin(), input, input.begin());
        const T&amp; pivot = *result.begin();
        auto divide_point = std::partition(input.begin(), input.end(), [&amp;pivot](const T&amp; t) { return t &lt; pivot; });

        std::list&lt;T&gt; lower_group;
        lower_group.splice(lower_group.end(), input, input.begin(), divide_point);

        bool flag = false;
        std::future&lt;std::list&lt;T&gt;&gt; lower_future;
        std::list&lt;T&gt; lower;
        if(lower_group.size() &gt; 1000) {
            lower_future = std::async(std::launch::async,
                                    &amp;parallel_qsort&lt;T&gt;,
                                    std::move(lower_group));
            flag = true;
        }
        else
            lower = parallel_qsort(std::move(input));


        auto higher(parallel_qsort(std::move(input)));

        result.splice(result.end(), higher);
        if(flag)
            result.splice(result.begin(), lower_future.get());
        else
            result.splice(result.begin(), lower);
        return result;
    }
</code></pre>
<p>这并不是并发快排的最佳实现，比如<em>std::partition</em>依旧是一个单线程操作。这样每一次递归调用快排就会开辟一个新的线程负责一半数据的快排，另一半在当前线程进行快排。但显然通过递归，线程数量会快速上升，导致<em>massive oversubcription</em>。（注意<em>std::async</em>的默认模式是取决于实现的）。另一方面使用封装的<em>spawn_task</em>会比<em>std::async</em>更好：</p>
<pre><code class="language-c++">    template&lt;typename F, typename A&gt;
    std::future&lt;std::result_of_t&lt;F(A&amp;&amp;)&gt;&gt;
    spawn_task(F&amp;&amp; f, A&amp;&amp; a) {
        using result_type = std::result_of_t&lt;F(A&amp;&amp;)&gt;;
        std::packaged_task&lt;result_type(A&amp;&amp;)&gt; task(std::move(f));
        std::future&lt;result_type&gt; res(task.get_future());
        std::thread t(std::move(task), std::move(a));
        t.detach();
        return res;
    }
</code></pre>
<p><em>spawn_task</em>使用<em>std::packaged_task</em>和<em>std::thread</em>封装了一个功能和<em>std::async</em>类似的类，虽然不能自动防止<em>massive oveersubscription</em>，但是更加适合扩展（比如加入线程池）。</p>
<h2 id="synchronizing-operations-with-message-passing"><a class="header" href="#synchronizing-operations-with-message-passing">Synchronizing operations with message passing</a></h2>
<p>CSP（<em>Communicating Sequential Processes</em>），即线程之间没有任何<em>shared data</em>，线程之间只有通过信道交换信息。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-model-and-atomic-operation"><a class="header" href="#memory-model-and-atomic-operation">Memory Model And Atomic Operation</a></h1>
<p>在C++中，内存是一块或者多块连续的<em>byte</em>序列，所有<em>byte</em>在程序中都有唯一的地址。</p>
<h2 id="byte"><a class="header" href="#byte">Byte</a></h2>
<p><em>Byte</em>是C++程序中最小的寻址单元，被定义为可以容纳256个不同的值以及<em>basic execution character set</em>的连续<em>bit</em>。C++支持8<em>bits</em>及以上的<em>byte</em>，可以使用<em>CHAR_BIT</em>或者<em>std::numeric_limits<unsigned char>::digits</em>来查询一个<em>byte</em>有多少<em>bit</em>（<em>char</em>、<em>unsigned char</em>、<em>signed char</em>保证只使用一个<em>byte</em>进行储存。）。</p>
<h2 id="obeject"><a class="header" href="#obeject">Obeject</a></h2>
<p><em>Object</em>是C++的基本概念，应当和OO中的<em>object</em>区分开来。<em>object</em>是一块包含以下特性的存储区域：</p>
<ol>
<li>size</li>
<li>aligment requirement</li>
<li>storage duration</li>
<li>lifetime</li>
<li>type</li>
<li>value</li>
<li>name（optional）</li>
</ol>
<p>类似于引用（<em>reference</em>）、位域（<em>bit field</em>）都不是<em>object</em>。</p>
<h3 id="object-representation-and-value-representation"><a class="header" href="#object-representation-and-value-representation">Object representation and value representation</a></h3>
<p>对象表达和值表达是两回事，对象表达更加“底层”：</p>
<ul>
<li><em>object representation</em>是指以<em>object</em>所在地址的一个<em>byte</em>序列。</li>
<li><em>object</em>的<em>value representation</em>是<em>object</em>所占区域的该类型的值。</li>
</ul>
<p>许多原因会导致两者的不一致，比如类型标准、内存对齐、位域，比如：</p>
<pre><code class="language-c++">    #include &lt;cassert&gt;
    struct S {
        char c;  // 1 byte value
                // 3 bytes padding
        float f; // 4 bytes value
        bool operator==(const S&amp; arg) const { // value-based equality
            return c == arg.c &amp;&amp; f == arg.f;
        }
    };
    assert(sizeof(S) == 8);
    S s1 = {'a', 3.14};
    S s2 = s1;
    reinterpret_cast&lt;char*&gt;(&amp;s1)[2] = 'b'; // change 2nd byte
    assert(s1 == s2); // value did not change
</code></pre>
<p>通过更改结构体的第二个字节从而改变了<em>object represention</em>，但是由于内存对齐，第二个字节对于类型S来说没有意义，所以<em>value representation</em>不变。</p>
<p>同样的例子还有浮点数规范中，多个<em>bit</em>序列对应值<em>NaN</em>。</p>
<h3 id="subobjects"><a class="header" href="#subobjects">Subobjects</a></h3>
<p>一个<em>object</em>内部可以包含若干<em>subobject</em>，比如：</p>
<ul>
<li>member objects</li>
<li>base class subobjects</li>
<li>array elements</li>
</ul>
<p>如果一个<em>object</em>不是其他的<em>subobject</em>，则可以称为<em>complete object</em>。</p>
<p><em>array elements</em>、<em>member objects</em>和<em>complete object</em>归类为<em>most derived object</em>，非位域的<em>most derived object</em>的<em>size</em>必然非零。</p>
<h3 id="polymorphic-objects"><a class="header" href="#polymorphic-objects">Polymorphic objects</a></h3>
<h3 id="alignment-requirement"><a class="header" href="#alignment-requirement">Alignment requirement</a></h3>
<p>内存对齐的由来：因为CPU对内存的随机访问是一个缓慢的过程，为了减少CPU对内存的访问次数出现了内存对齐（通过空间节省时间）。</p>
<p>比如一个32位的CPU字长为32bit、字节为8bit，其地址线就为30位，可以管理2^32字节的内存，其地址线最低两位总是为00。</p>
<p>该CPU希望访问一个地址为2的、大小为4字节的数据（即位于2、3、4、5）。那么CPU就要对内存进行两次访问，第一次取地址0(00)的数据并取2、3的数据，第二次取地址1(00)的数据并取4、5的数据。</p>
<p>但如果数据地址为4（即位于4、5、6、7），那么只需要进行一次对地址1(00)访。</p>
<ul>
<li>因此规定对齐要求为<em>alignment requirement</em>的片段必须位于地址偏移<em>offset</em>的位置，并满足<em>offset mod alignment requirement == 0</em>.</li>
</ul>
<p>即有：</p>
<pre><code class="language-c++">    struct T{
        char data1;     // size 1
        // padding 3
        int data2;      // size 4
        some_type data3;    // size 2
        // padding 2
        int data4;      // size 4
        char data5;     // size 1
    };
</code></pre>
<p>可以得出T的大小为17，但其实T的大小为20。因为<em>struct</em>自身可以作为一个数组的成员，而数组必然连续，会破坏后续的<em>struct</em>的内存对齐决策，比如：</p>
<pre><code class="language-c++">    T pp[2];
</code></pre>
<p>pp[0]的data5落在地址17的位置，而pp[1]的data2会落在21的位置，破坏了内存对齐。</p>
<ul>
<li>因此规定，struct的<em>size</em>必须为其成员中的最大对齐要求的整数倍。</li>
</ul>
<p>即有：</p>
<pre><code class="language-c++">    struct T{
        char data1;     // size 1
        // padding 3
        int data2;      // size 4
        some_type data3;    // size 2
        // padding 2
        int data4;      // size 4
        char data5;     // size 1
        // padding 3
    };
</code></pre>
<p>C++可以通过<em>alignof</em>获得一个类型的对齐要求，需要注意的是对齐要求和大小是不一样的，虽然对于内建类型一般相同。</p>
<p>比如结构体T的大小为20，但其对齐要求为4，因为其最大成员的对其要求为4。</p>
<p>归结为如下规律：</p>
<ol>
<li>内建类型 alignment requirement 和 size 一致。</li>
<li>成员的地址相对于结构地址的偏移为该成员alignment requirement的整数倍。</li>
<li>结构的大小应该为成员中最大的alignment requirement的整数倍，且结构的alignment requirement和成员中最大的alignment requirement相同。</li>
<li>注意考虑多态带来的额外成员。</li>
</ol>
<h2 id="memory-location"><a class="header" href="#memory-location">Memory location</a></h2>
<p><em>Memory location</em>是:</p>
<ul>
<li>an object of scalar type (arithmetic type, pointer type, enumeration type, or std::nullptr_t)</li>
<li>or the largest contiguous sequence of bit fields of non-zero length</li>
</ul>
<p>但注意有些语言特性会引入有些额外的<em>memory location</em>，比如虚函数和引用。</p>
<pre><code class="language-c++">    struct S {
        char a;     // memory location #1
        int b : 5;  // memory location #2
        int c : 11, // memory location #2 (continued)
              : 0,  // start new byte
            d : 8;  // memory location #3
        struct {
            int ee : 8; // memory location #4
        } e;
    } obj; // The object 'obj' consists of 4 separate memory locations
</code></pre>
<h2 id="threads-and-data-races"><a class="header" href="#threads-and-data-races">Threads and data races</a></h2>
<p>任何线程都可以访问程序中的任何<em>object</em>（包括线程自己的自动变量以及<em>threadlocal</em>变量，因为可以通过指针和引用访问）。</p>
<p>不同的线程可能在没有同步和几口要求的情况下，同时访问（包括读取和改变）不同的<em>memory location</em>。</p>
<p>当一个表达式的值去写一个<em>memory location</em>，而另一个表达式访问或者更改这个<em>memory location</em>，就出现冲突，这样的冲突会在除以下情况之外演化为<em>data race</em>：</p>
<ul>
<li>两个表达式操作在同一个线程或者同一个<em>signal handler</em>中执行</li>
<li>两个冲突表达式为原子操作(<em>std::atomic</em>)</li>
<li>其中一个操作比另一个操作先发生（<em>std::memory_order</em>）</li>
</ul>
<p>除此之外的冲突表达式都会引起<em>data race</em>，<em>data race</em>产生<em>undefined behaviour</em>。</p>
<pre><code class="language-c++">    std::atomic&lt;int&gt; cnt;
	auto f = [&amp;cnt] { for(int p = 0; p &lt; 100000; p++) cnt++; };
	std::thread t1(f), t2(f), t3(f);
	t1.join();
	t2.join();
	t3.join();  // OK.

    int cnt;
	auto f = [&amp;cnt] { for(int p = 0; p &lt; 100000; p++) cnt++; };
	std::thread t1(f), t2(f), t3(f);
	t1.join();
	t2.join();
	t3.join();  // undefined behaviour.
</code></pre>
<h2 id="memory-order"><a class="header" href="#memory-order">Memory order</a></h2>
<p>当一个线程从一个<em>memory location</em>读取一个值时，它可能会读到初始值、当前线程写入的值、其他线程写入的值。</p>
<p><em>std::memory_order</em>是用于描述通常非原子的内存的访问是如何围绕原子操作进行排序的。</p>
<h1 id="atomic-operation"><a class="header" href="#atomic-operation">Atomic operation</a></h1>
<p>原子操作是一种无法再分割的操作。如果对一个<em>object</em>的操作是<em>atomic</em>的，那所有对该<em>object</em>的操作都是<em>atomic</em>的。</p>
<p>另一方面，非原子操作是可以被半路切入的。因为CPU对内存的访问是一个多步过程，其中还涉及到相关的缓存，因此不同线程对一个<em>object</em>的非原子操作（包含有写操作）会导致<em>data race</em>。</p>
<h2 id="the-standard-atomic-types"><a class="header" href="#the-standard-atomic-types">The standard atomic types</a></h2>
<p>在C++标准库中，对<em>atomic type</em>的操作不一定是真正意义上的原子操作，即不一定是<em>lock free</em>的，是在对外的表达意义上为<em>atomic</em>，有可能借助<em>mutex</em>来实现原子性。注意有些非成员函数模板用于实现非<em>std::atomic</em>特化类型的原子操作，在标准库中仅有一处用到，即<em>std::shared_ptr</em>。</p>
<p>绝大部分的<em>atomic type</em>都提供了<em>is_lock_free</em>接口来查询。只有<em>std::atomic_flag</em>没有提供<em>is_lock_free</em>，其实是一个bool型，并且保证<em>lock free</em>。</p>
<p><em>std::atomic</em>提供了许多相应的原子操作，包括算术、逻辑、复合运算和位运算，并且对一个原子类型的可行操作和非原子类型一致。</p>
<p><em>std::atomic</em>的类型不具备传统意义上的拷贝和赋值语义，但是可以和内建类型进行转换实现类似的语义。通过load和store返回或者保存当前原子类型的值。</p>
<p>所有原子类型的操作都不会返回<em>object</em>本身，而是返回一个内建类型来避免通过引用实现对原子类型的非原子操作，导致<em>data race</em>，并且原子操作都保有一个<em>std::memory_order</em>的参数。</p>
<h2 id="operation-on-stdatomic_flag"><a class="header" href="#operation-on-stdatomic_flag">Operation on std::atomic_flag</a></h2>
<p><em>std::atomic_flag</em>是最简单的原子类型，并且保证<em>lock free</em>，本质是一个<em>boolean flag</em>，其具有两种状态：<em>set</em>和<em>clear</em>。</p>
<p><em>std::atomic_flag</em>应该使用<em>ATOMIC_FLAG_INIT</em>初始化，初始状态为<em>clear</em>。</p>
<pre><code class="language-c++">    std::atomic_flag f=ATOMIC_FLAG_INIT;
</code></pre>
<p><em>atomic_flag</em>不可进行复制操作，只能无异常默认构造，也不提供<em>load</em>和<em>store</em>操作。一旦<em>std::atomic_flag</em>构造完成，只能对其进行下列三个操作：</p>
<ul>
<li>析构销毁</li>
<li><em>clear</em>：将状态设置为<em>clear</em>，即<em>flag</em>为<em>false</em></li>
<li><em>test_and_set</em>：将<em>flag</em>设置为<em>true</em>，并且返回设置前的<em>flag</em></li>
</ul>
<p>有限的操作使得<em>std::atomic_flag</em>的应用场景很狭窄，一大用途就是用于实现自旋锁<em>spin lock</em>：</p>
<pre><code class="language-c++">    class spin_lock_mutex { 
    public:
        spin_lock_mutex() = default;
        spin_lock_mutex(const spin_lock_mutex&amp;) = delete;

        void lock() {
            while(inside_atomic_flag_.test_and_set(std::memory_order_acquire));
        }

        void unlock() {
            inside_atomic_flag_.clear(std::memory_order_release);
        }

    private:
        std::atomic_flag inside_atomic_flag_ = ATOMIC_FLAG_INIT;
    };
</code></pre>
<p>自旋锁在资源被其他线程占据时不会像互斥锁一样被挂起进入休眠，而是不断的检查内部的<em>flag</em>直到锁被释放。因此自旋锁的效率要比互斥锁高，但是会长时间占据CPU。如果资源占据时间较长，自旋锁消耗的CPU资源会比互斥锁高得多，反而降低了程序效率。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="item1-understand-template-type-dedution"><a class="header" href="#item1-understand-template-type-dedution">Item1: Understand Template Type Dedution</a></h1>
<p>函数模板的形式如下:</p>
<pre><code class="language-c++">    tmeplate&lt;typename T&gt;
    void foo(ParamType param);
</code></pre>
<p>函数调用的形式如下:</p>
<pre><code class="language-c++">    foo(expr);  //call foo with expresstion;
</code></pre>
<p>在编译期间，编译器会推断T和ParamType。ParParamType通常会包含一些修饰符，比如const、&amp;等，如下：</p>
<pre><code>template&lt;typename&gt;
void foo(const T&amp; param);
</code></pre>
<p>T的类型推断是由expr和ParamType共同决定的。如下根据ParamTpye分成三种情况：</p>
<ul>
<li>ParamType是一个指针和引用（非万能引用）。</li>
<li>ParamType是一个万能引用。</li>
<li>ParamType不是引用和指针。</li>
</ul>
<h2 id="case1-paramtype-is-a-reference-or-pointerbut-not-a-universal-reference"><a class="header" href="#case1-paramtype-is-a-reference-or-pointerbut-not-a-universal-reference">case1: ParamType is a Reference or Pointer,but not a Universal Reference</a></h2>
<p>在这种情况下,类型推断步骤如下：</p>
<ul>
<li>如果expr是一个引用，则忽略引用部分。</li>
<li>依赖ParamType模式匹配expr的类型，得到T。</li>
</ul>
<p>比如：</p>
<pre><code>template&lt;typename T&gt;
void foo(T&amp; param);

int x = 27;
const int cx = x;
const int&amp; crx = x;

foo(x);     //T is int, ParamType is int&amp;.
foo(cx);    //T is const int, ParamType is const int&amp;.
foo(crx);   //T is const int, ParamType is const int&amp;. reference-ness is ignored.
</code></pre>
<p>这种情况下，为了保证const变量的安全，const将成为T的一部分。如果param包含const修饰，如下：</p>
<pre><code>template&lt;typename T&gt;
void foo(const T&amp; param);

foo(x);     //T is int, ParamType is const int&amp;.
foo(cx);    //T is int, ParamType is const int&amp;.
foo(crx);   //T is int, ParamType is const int&amp;. reference-ness is ignored.
</code></pre>
<p>param为指针的表现与引用类似，如下：</p>
<pre><code>template&lt;typename T&gt;
void foo(T* param);
const int* cpx = &amp;x;

foo(&amp;x);    //T is int, ParamType is int*.
foo(&amp;cx);   //T is const int, ParamType is const int*.
foo(cpx);   //T is const int, ParamType is const int*.
</code></pre>
<h2 id="case2-paramtype-is-a-universal-reference"><a class="header" href="#case2-paramtype-is-a-universal-reference">case2: ParamType is a Universal Reference</a></h2>
<p>在这种情况下，推断原则如下：</p>
<ul>
<li>如果expr是一个左值，T和ParamType都被推断为左值引用。
（1.只有这种情况，T才有可能被推断为引用；2.ParamType被推断为左值引用而非右值引用。）</li>
<li>如果expr是一个右值，直接适用通用情况。</li>
</ul>
<p>比如：</p>
<pre><code>template&lt;typename T&gt;
void foo(T&amp;&amp; param);    //ParamType is a Universal Reference.

foo(x);     //T is int&amp;, ParamType is int&amp;.
foo(cx);    //T is const int&amp;, ParamType is const int&amp;.
foo(crx);   //T is const int&amp;, ParamType is const int&amp;.
foo(27);    //27 is int and rvalue, T is int, ParamType is int&amp;&amp;.
</code></pre>
<p>当ParamType是万能引用时，expr左值和右值表现并不一样。</p>
<h2 id="case3-parparamtype-is-neither-a-pointer-nor-a-reference"><a class="header" href="#case3-parparamtype-is-neither-a-pointer-nor-a-reference">case3： ParParamType is Neither a Pointer nor a Reference</a></h2>
<p>按值传递,这意味着param将是传入的一个copy。原则如下：</p>
<ul>
<li>如果expr是一个引用，则忽略引用。</li>
<li>如果忽略引用后，有const和volatile修饰，则亦忽略。</li>
</ul>
<p>如下：</p>
<pre><code>template&lt;typename T&gt;
void foo(T param);      //param is passing by value.

foo(x);     //T is a int, ParamType is a int.    
foo(cx);    //T is a int, ParamType is a int. const-ness is ignored.
foo(crx);   //T is a int, ParamType is a int. reference-ness and const-ness is ignored.
</code></pre>
<p>const被忽略的原因在于：param是一个copy，被copy对象不可变不代表其复制不可变。
这是按值传递和引用或指针传递不同的地方。
考虑以下情况：</p>
<pre><code>const char* const ptr = ... //ptr is a const pointer pointing to const.
foo(ptr);   //T is a const char*, ParamType is a const char*. 
            //top-level is ignored. but low-level should not be ignored.
</code></pre>
<p>由于按值传递的对象是指针。所以修饰指针本身的const（top-level）可以被忽略，
但是修饰指针所指向的obj的const不可以被忽略。</p>
<h2 id="array-argments"><a class="header" href="#array-argments">Array Argments</a></h2>
<p>值得注意数组和指针是不一样的，即时它们经常可以互相转换。
数组经常退化为指针（指向第一元素）：</p>
<pre><code>const char name[] = &quot;abcd&quot;;     //name's type is const char[13].
const char *ptr = name;         //array decays to pointer.
</code></pre>
<p>考虑数组作为expr的情况：</p>
<pre><code>template&lt;typename T&gt;
void foo(T param);      //by-value.

foo(name);  //T is const char*, param is const char*.
            //array decays to pointer.

template&lt;typename T&gt;
void foo(T&amp; param);      //by-reference.

foo(name);  //T is const char[5], ParamType is const char(&amp;)[5].

template&lt;typename T&gt;
void foo(T* param);      //by-pointer.

foo(name);  //T is const char, ParamType is const char*.
</code></pre>
<p>通过该特性，就可以实现以下模板：</p>
<pre><code>//aquire the size of an array at compile time.
template&lt;typename T, size_t N&gt;
constexpr size_t ArraySize(T (&amp;)[N]) noexcept {
    return N;
}
</code></pre>
<h2 id="function-argments"><a class="header" href="#function-argments">Function Argments</a></h2>
<p>函数也可以退还成函数指针。模板类型推断时的函数与数组表现类似。
如下：</p>
<pre><code>void func(int,double);   //type is void(int,double).

template&lt;typename T&gt;
void foo(T param);       //by-value.

foo(func);  //T is void(*)(int,double), ParamType is void(*)(int,double).

template&lt;typename T&gt;
void foo(T param);      //by-reference.

foo(func);  //T is void(int,double), ParamType is void(&amp;)(int,double).

template&lt;typename T&gt;
void foo(T* param);      //by-pointer.

foo(func);  //T is void(int,double),ParamType is void(*)(int,double).
</code></pre>
<h2 id="things-to-remember"><a class="header" href="#things-to-remember">Things to Remember</a></h2>
<ul>
<li>在模板类型推断中，argument的reference-ness被忽略。</li>
<li>对于universal reference parameter，lvalue arguments是具有特殊机制的。</li>
<li>对于by-value parameter，const和volatile是被忽略的。</li>
<li>对于array和funciton的arguments，除了reference parameter以外均退化为指针。</li>
</ul>
<h1 id="item2-understand-auto-type-dedution"><a class="header" href="#item2-understand-auto-type-dedution">Item2: Understand Auto Type Dedution</a></h1>
<p>Auto的类型推断与item1的模板类型推断基本一致。在auto推断中，auto相当于
模板中的T，整个类型修饰符相当于PramaType，初始化的值相当于expr。(有一点不同)</p>
<p>如下：</p>
<pre><code>auto x = 27;

template&lt;typename T&gt;
void funcx(T param);

funcx(27);      //T is int, so auto is int. ParamType is int.

const auto cx = x;

template&lt;typename T&gt;
void funccx(const T param);

funccx(x);      //T is int, so auto is int. ParamType is const int.


const auto&amp; crx = x;

template&lt;typename T&gt;
void funccrx(const T&amp; param);

funccrx(x);     //T is int, so auto is int. ParamType is const int&amp;.
</code></pre>
<h2 id="type-specifiers-have-effect-on-type-deduction"><a class="header" href="#type-specifiers-have-effect-on-type-deduction">Type Specifiers have effect on Type Deduction</a></h2>
<p>正如模板类型推断中的以PramaType分类讨论，auto类型推断可以将type specifier分成3类讨论，即：</p>
<ul>
<li>类型修饰符是引用或者指针（不包含万能引用）</li>
<li>类型修饰符是万能引用</li>
<li>类型修饰符不是指针和引用</li>
</ul>
<p>比如：</p>
<pre><code>auto x = 27；            //27 is int, x is int.
const auto cx = x;     //x is int, cx is const int. 
const auto&amp; crx = x;    //x is int, crx is const int&amp;.

auto&amp;&amp; urx = x;         //x is int(lvalue), urx is int&amp;.
auto&amp;&amp; urx = cx;        //cx is const int(lvalue), urx is const int&amp;.
auto&amp;&amp; urx = 27;        //27 is rvalue, urx is int&amp;&amp;.
</code></pre>
<h2 id="initializer-is-an-array-or-a-function"><a class="header" href="#initializer-is-an-array-or-a-function">Initializer is an Array or a function</a></h2>
<p>指针和数组作为初始化auto类型推断和模板类型推断一致。</p>
<pre><code>const char name[] = &quot;123456&quot;;   //name is const char[7].

auto arr1 = name;       //by-value, arr1 is const char*.
auto&amp; arr2 = name;      //by-lreference, arr2 is const char(&amp;)[7].

void func(int,double);          //func is void(int,double).

auto func1 = func;      //by-value, func1 is void(*)(int,double).
auto&amp; func2 = func;     //by-lreference, func2 is void(&amp;)(int,double).
</code></pre>
<h2 id="braced-initializer-and-parenthesis-initializer"><a class="header" href="#braced-initializer-and-parenthesis-initializer">Braced-Initializer and Parenthesis-Initializer</a></h2>
<p>barced-initializer_list是auto和template类型推断的唯一不同之处。template是不能直接推断出initializer-list的。
考虑以下定义：</p>
<pre><code>auto x1 = 27;           //type is int, value is 27.
auto x2(27);            //ditto.
auto x3 = { 27, 42 };   //type is initializer_list&lt;int&gt;, value is {27}.
auto x4{ 27 };          //type is int, value is 27.
auto x5{ 27, 42 };      //error, need =.
auto x6{ 1, 2, 3.0 };   //error, cannot deduce T for initializer_list.
</code></pre>
<p>注意直接初始化和赋值初始化对于{}initializer的区别。</p>
<pre><code>template&lt;typename T&gt;
void foo(T param);

foo({ 1, 2, 3 });       //error, connot deduce type for T.
</code></pre>
<p>想要实现对T的template推断，可以如下声明：</p>
<pre><code>template&lt;typename T&gt;
void foo(std::initializer_list&lt;T&gt; inilist);

f({1, 2, 3});           //valid, T is int, ParamType is initializer_list&lt;int&gt;.
</code></pre>
<p>同时值得注意的是，C++14允许函数返回值与lambda表达式参数通过使用auto进行类型推断，但是这种情景下的类型推断是模板类型推断，
而不是auto类型推断，比如：</p>
<pre><code>auto createList() {
    return { 1, 2, 3 };     //error: cannot deduce return type for { 1, 2, 3 }.
}

std::vector&lt;int&gt; v;
auto resetV = [&amp;v](const auto&amp; newvalue) {
    v = newvalue;           //C++ 14;
}
resetV({ 1, 2, 3 });        //error! cannot deduce parameter type for { 1, 2, 3 }.
</code></pre>
<h2 id="things-to-remember-1"><a class="header" href="#things-to-remember-1">Things to Remember</a></h2>
<ul>
<li>auto类型推断和template类型推断几乎一致，只是auto可以将braced-initializer推断为initializer_list，而template不接受这种推断。</li>
<li>auto在函数返回值和lambda表达式参数使用时，代表的是template推断，而不是auto。</li>
</ul>
<h1 id="item3-understand-decltype"><a class="header" href="#item3-understand-decltype">Item3: Understand <em>decltype</em></a></h1>
<p>decltype获取一个表达式，返回一个表达式的类型。
大多数情况其结果如常规想象，但是偶尔也会出一些令人意想不到的结果。</p>
<h2 id="typical-case"><a class="header" href="#typical-case">Typical Case</a></h2>
<p>这些情况下，decltype给出表达式确实的类型。</p>
<pre><code>const int i =0;             //decltype(i) is const int.
bool f(const widget&amp; w);    //decltype(f) is bool(const widget&amp;).
sturct Point {              //decltype(Point::x) is int.
    int x, y;
};
widget w;                   //decltype(w) is widget.

if(f(w))...                 //decltype(f(w)) is bool.

template&lt;typename T&gt;
class vector {
    public:
    T&amp; operator[](std::size_t index);
};

vector&lt;int&gt; v;              //decltype(v) is vector&lt;int&gt;.

if(v[0] == 0)...            //decltype(v[0]) is int&amp;.
</code></pre>
<p>在这些情况下，decltype乖乖的推导出expr的类型，不进行任何添油加醋。</p>
<h2 id="trailing-return-type-with-decltype"><a class="header" href="#trailing-return-type-with-decltype">Trailing Return Type with Decltype</a></h2>
<p>在C++11中，函数返回值可以采用trailing的方式，而且可以使用decltype.</p>
<p>比如：</p>
<pre><code>template&lt;typename Container, typename Index&gt;
auto access(Container&amp; c, Index i) -&gt;decltype(c[i]) {   
    ...
    return c[i];        //access c[i].
}

vetcor&lt;int&gt; veci{ 1, 2, 3, 4 };
access(veci,2) = 5;     //change the veci[2].
</code></pre>
<p>由于我们不知道容器Container以及索引Index的准确类型及其内容物类型，
我们直接拼写出返回的内容物的类型，需要通过类型推断。
一种方法是通过Container的内置类型成员(typename)，另一种就是利用decltype.
由于c与i的声明位置，所以需要使用trailing的方式。</p>
<p>这种情况下，auto是仅有占位功能，真正进行推断的是decltye，
decltype分辨出c[i]的类型是T&amp;，所以可以通过access读写c[i]。</p>
<h2 id="auto-return-type-deduction"><a class="header" href="#auto-return-type-deduction">Auto Return Type Deduction</a></h2>
<p>再看item2中提到的, 自C++14起，
允许为多语句lambda以及函数进行自动返回值推断。如下：</p>
<pre><code>template&lt;typename Container, typename Index&gt;
auto access(Container&amp; c, Index i) {   
    ...
    return c[i];        //omit the referenceness.
}

vetcor&lt;int&gt; veci{ 1, 2, 3, 4 };
access(veci,2) = 5;     //error, expression is a rvalue.
</code></pre>
<p>这种情况下，执行的template的类型推断，所以access返回的是T类型变量，是一个右值。</p>
<p>值得注意，所以为了实现access的原本功能，decltype trailing return type就不能忽略。</p>
<h2 id="use-decltypeauto"><a class="header" href="#use-decltypeauto">Use decltype(auto)</a></h2>
<p>同时在C++14中，提供了更加优雅的使用decltype的方式，
使得decltype类型推断被使用，如下：</p>
<pre><code>template&lt;typename Container, typename Index&gt;
decltype(auto) access(Container&amp; c, Index i) {   
    ...
    return c[i];        //use the decltype rules.
}

vetcor&lt;int&gt; veci{ 1, 2, 3, 4 };
access(veci,2) = 5;     //change the veci[2].
</code></pre>
<p>decltype(auto)不仅能用在函数返回推断上，也可以用在通常声明上，使得类型推断自行使用
decltype的规则。</p>
<pre><code>widget w;
const widget&amp; crw = w;
auto w2 = crw;              //auto type deduction, w2 is widget.
decltype(auto) w3 = crw     //decltype type deduction, w3 is const widget&amp;.
</code></pre>
<h2 id="decltypes-behaviour"><a class="header" href="#decltypes-behaviour">Decltype's Behaviour</a></h2>
<p>观察如下代码：</p>
<pre><code>int x = 0;      //decltype(x) is int.
int y = 0;      //decltype((x)) is int&amp;.

decltype(true?x:0) i;   //true?x:0 is rvalue-expression, i is int. 
decltype(true?x:y) i;   //true?x:y is lvalue-expression, i is int&amp;.
</code></pre>
<p>产生了意想不到的结果。
因为decltype对name和expression的效果是不一样的。
当decltype作用于name时，产生的类型是T。
当decltype作用于lvalue-expression时，产生的是T&amp;。</p>
<p>Trailing Return Type不容易出现类型的误写，
但decltype(auto)容易出现，如下：</p>
<pre><code>decltype(auto) foo() {
    int x = 0;
    return x;           //decltype（x） is int, so foo returns int.
}

decltype(auto) foo() {
    int x = 0;
    return (x);         //decltype((x)) is int&amp;, so foo returns int&amp;.
}
</code></pre>
<h2 id="things-to-remember-2"><a class="header" href="#things-to-remember-2">Things to Remember</a></h2>
<ul>
<li>decltype大多数情况产生类型与表达式相应的类型，不会有任何修正。</li>
<li>对于lvalue-expression，decltype会产生T&amp;.</li>
<li>C++14支持decltype(auto)，表达使用decltype原则进行类型推断。</li>
</ul>
<h1 id="item4-konw-how-to-view-deduced-type"><a class="header" href="#item4-konw-how-to-view-deduced-type">Item4: Konw How to View Deduced Type</a></h1>
<p>程序开发过程中，总共有3个阶段，会对推断类型感兴趣。</p>
<ul>
<li>during edit your code.</li>
<li>during compilation.</li>
<li>at runtime.</li>
</ul>
<h2 id="during-edit-your-code"><a class="header" href="#during-edit-your-code">During Edit Your Code</a></h2>
<p>通常IDE能够直接告诉你当前类型推断是什么，但是这往往针对类型比较简单的情况下。
IDE能够显式这类信息是，其内部的compiler正在运行。如果这个compiler对当前情
况进行足够的语法解析。那么IDE就难以给出这类信息。
简单类型推断往往是快速准确的，但是涉及到比较复杂的推断，这种方式往往难以给出
有效的信息。</p>
<h2 id="during-compilation"><a class="header" href="#during-compilation">During Compilation</a></h2>
<p>在编译过程中，可以通过故意制造编译错误，查看错误报告来获得推断结果。</p>
<p>如下：</p>
<pre><code>template&lt;typename T&gt;
class TD;               //TD means &quot;Type Display&quot;.
</code></pre>
<p>这是一个未定义的模板，对该模板的实例化会导致编译时错误。</p>
<p>比如：</p>
<pre><code>int x;
const int* y = &amp;x;
TD&lt;decltype(x)&gt; xType;
TD&lt;decltype(y)&gt; yType;
</code></pre>
<p>编译器报告编译错误：</p>
<blockquote>
<p>error C2079: 'xType' uses undefined class 'TD<int>'</p>
</blockquote>
<blockquote>
<p>error C2079: 'yType' uses undefined class 'TD&lt;const int *&gt;'</p>
</blockquote>
<h2 id="at-runtime"><a class="header" href="#at-runtime">At Runtime</a></h2>
<p>typeid与type_info支持程序识别自身的变量类型。
如下:</p>
<pre><code>std::cout&lt;&lt; typeid(x).name() &lt;&lt; std::endl;
std::cout&lt;&lt; typeid(y).name() &lt;&lt; std::endl;
</code></pre>
<p>于VS环境下可以获得：<br />
&gt;int</p>
<blockquote>
<p>int const *</p>
</blockquote>
<p>但是事情并没有这么简单，考虑以下例子：</p>
<pre><code>template&lt;typename T&gt;                //function to show T and param.
void f(const T&amp; param);

std::vector&lt;Widget&gt; createVec();    //factory function.

const auto vw = createVec();        

if(!vw.empty()){
    f(&amp;vw[0]);
}
</code></pre>
<p>然后我们通过f来获得上面类型推断的结果：</p>
<pre><code>template&lt;typename T&gt;
void f(const T&amp; param){
    std::coud &lt;&lt; &quot;T = &quot; &lt;&lt; typeid(T).name() &lt;&lt; '\n';
    std::cout &lt;&lt; &quot;param = &quot; &lt;&lt; typeid(param).name() &lt;&lt; '\n';
}
</code></pre>
<p>在VS中得到的结果如下：
&gt;T = class Widget const *</p>
<blockquote>
<p>param = class Widget const *</p>
</blockquote>
<p>很显然T和param推断出的类型应该是不一样的，因为param是const T&amp;。
所以type_info::name并不可靠，
这是因为标准要求type_info::name对模板函数传入均使用by—value的方式。</p>
<p>按照Item1，vw[0]的类型是一个const Widget&amp;，
&amp;vw[0]的类型便是const Widget *,
按值传递类型推断出T和ParamType均为const Widget *。</p>
<blockquote>
<p>此外还可以使用boost库</p>
</blockquote>
<h2 id="things-to-remember-3"><a class="header" href="#things-to-remember-3">Things to Remember</a></h2>
<ul>
<li>Deduced Types可以通过IDE，编译错误，以及type_info和Boost TypeIndex library查看.</li>
<li>结果可能并不是那么有效或者精确的，所以Item1的内容是至关重要的。</li>
</ul>
<h1 id="item5-prefer-auto-to-explicit-type-declartions"><a class="header" href="#item5-prefer-auto-to-explicit-type-declartions">Item5: Prefer auto to Explicit Type Declartions</a></h1>
<p>auto不仅能够减少拼写，同时也可以防止手写类型带来的性能和正确性问题。
有时，auto带来的类型推断契合于当前算法，但从程序的角度来说，却是错的。
所以引导auto得到想要的类型是十分关键的。</p>
<h2 id="auto-make-code-more-robust"><a class="header" href="#auto-make-code-more-robust">auto Make Code More Robust</a></h2>
<p>比如：</p>
<pre><code>int x；  // do not initialize x.
</code></pre>
<p>这行代码为初始化x，所以x可能是未定义的，也有可能是值初始化的，具体看环境。</p>
<pre><code>template&lt;typename It&gt;
void dwim(It b, It e) {
    for(;b != e; ++b) {
        typename std::iterator_traits&lt;It&gt;::value_type
        currValue = *b;         // Dereferce b and assgin it to currValue;
        ...
    }
}
</code></pre>
<p>这段代码用到了traits，仅仅是声明一个变量便要用到traits等模板编程技巧，易错而且复杂。
再看使用auto的实现版本：</p>
<pre><code>auto x；  // Wrong！ do not initialize x.

template&lt;typename It&gt;
void dwim(It b, It e) {
    for(;b != e; ++b) {
        auto currValue = *b;         // Dereferce b and assgin it to currValue;
        ...
    }
}
</code></pre>
<p>auto类型推断是从initializer开始的，所以auto修饰变量必须初始化，避免了局部变量未初始化带来
的未定义行为。</p>
<p>auto类型推断大大减少了各类typename的声明。</p>
<p>同时auto还能推断出那些只有编译器才能表达的类型，比如lambda，见下：</p>
<pre><code>auto derefUPLess =                              // Compare *p1 and *p2
    [](const std::unique_ptr&lt;Widget&gt;&amp; p1,
       const std::unique_ptr&lt;Widget&gt;&amp; p2)
       { return *p1 &lt; *p2; };
</code></pre>
<p>在C++14中，Lambda的参数也可以用auto表示（注意本质是模板）</p>
<pre><code>auto derefUPLess =                              // Compare *p1 and *p2
    [](auto&amp; p1, auto&amp; p2)
       { return *p1 &lt; *p2; };
</code></pre>
<h2 id="whats-a-stdfunction-object"><a class="header" href="#whats-a-stdfunction-object">What's a std::function Object</a></h2>
<p>std::function是C++11泛化化函数指针的产物。函数指针只能指向同型函数，但是
std::function可以代表任何callable对象。</p>
<pre><code>bool(const std::unique_ptr&lt;Widget&gt;&amp; p1,     // Signature for comparison function.
     const std::unique_ptr&lt;Widget&gt;&amp; p2)

std::function&lt;(const std::unique_ptr&lt;Widget&gt;&amp; p1,
       const std::unique_ptr&lt;Widget&gt;&amp; p2)&gt; func     // Create func.
</code></pre>
<p>lambda表达式是一个callable对象，所以也可以通过std::function refer to。</p>
<pre><code>std::function&lt;(const std::unique_ptr&lt;Widget&gt;&amp; p1,
       const std::unique_ptr&lt;Widget&gt;&amp; p2)&gt; 
    derefUPLess = [](const std::unique_ptr&lt;Widget&gt;&amp; p1,
       const std::unique_ptr&lt;Widget&gt;&amp; p2)
       { return *p1 &lt; *p2; };
</code></pre>
<p>所以std::function是可以替代auto的。</p>
<p>但是可见，拼写复杂度auto远低于std::funtion。更重要的是，
auto储存lambda表达式的闭包所需的空间与闭包大小相同，
然而std::function相当于实例模板产生了一个function对象，其中一个固定空间的变量储存有闭包，
当这个空间不足以包含这个闭包，function的构造函数在heap上为闭包申请空间。
所以std::function往往比auto占用更多的内存。
同时由于函数调用等等原因，std::function总比auto要慢，还有可能造成内存耗尽的异常。
测试如下：</p>
<pre><code>clock_t beg, ed;
beg = clock();
for (int i = 0; i &lt; 100000; ++i) {
    auto f = [](vector&lt;int&gt; v1, vector&lt;int&gt; v2) {return v1.size() &gt; v2.size(); };
}
ed = clock();
cout &lt;&lt; &quot;do not use auto:&quot; &lt;&lt; ed - beg &lt;&lt; endl;
beg = clock();
for (int i = 0; i &lt; 100000; ++i) {
    std::function&lt;bool(vector&lt;int&gt; v1, vector&lt;int&gt; v2)&gt; f =
        [](vector&lt;int&gt; v1, vector&lt;int&gt; v2) {return v1.size() &gt; v2.size(); };
}
ed = clock();
cout &lt;&lt; &quot;use auto:&quot; &lt;&lt; ed - beg &lt;&lt; endl;
</code></pre>
<blockquote>
<p>do not use auto:1</p>
</blockquote>
<blockquote>
<p>use auto:112</p>
</blockquote>
<h2 id="auto-prevents-type-shortcuts"><a class="header" href="#auto-prevents-type-shortcuts">auto Prevents &quot;type shortcuts&quot;</a></h2>
<pre><code>std::vector&lt;int&gt; v;
unsigned sz = v.size();
</code></pre>
<p>v.size()的返回值应该是std::vector<int>::size_type, 
在32位系统中，size_type和unsigned长度一致，均为32位。
但在64位系统中，则不，size_type为64位。
所以这行代码不具有移植性。
auto则没有任何问题。</p>
<pre><code>std::unordered_map&lt;std::string, int&gt; m;

for(const std::pair&lt;std::string,int&gt;&amp; p : m) {
    ...
}
</code></pre>
<p>这部分代码也有错误，因为std::unordered_map的key部分是const的，
所以遍历类型应该是std::pair&lt;const std::string,int&gt;。
所以上述代码相当于通过拷贝每个pair产生一个std::pair<a href="std::string,int">std::string,int</a>的临时对象，
然后p指向该对象。测试如下：</p>
<pre><code>std::unordered_map&lt;std::string, int&gt; m{ make_pair(&quot;123&quot;,1) };
clock_t beg, ed;
beg = clock();
for (int i = 0; i &lt; 100000; ++i) {
    for (const std::pair&lt;std::string, int&gt;&amp; p : m);     // Copy element.
}
ed = clock();
cout &lt;&lt; &quot;do not use auto:&quot; &lt;&lt; ed - beg &lt;&lt; endl;
beg = clock();
for (int i = 0; i &lt; 100000; ++i) {
    for (auto&amp; p : m);
}
ed = clock();
cout &lt;&lt; &quot;use auto:&quot; &lt;&lt; ed - beg &lt;&lt; endl;
</code></pre>
<blockquote>
<p>do not use auto:464</p>
</blockquote>
<blockquote>
<p>use auto:143</p>
</blockquote>
<p>这不仅仅带来的是性能上的提升，更多的是程序的合理性与正确性。
对p取地址：前者带来的是对临时对象，后者是对m中元素。
临时对象将会过程结束后销毁，带来指针操作上的隐患。</p>
<p>显式的拼写类型经常会带来类型转换和类型不匹配，带来性能和可靠性上的损耗。</p>
<p>同时auto也降低了重构成本，比如一个函数的返回值为int，而后改成long，
显式声明需要修改所有位置，而auto自动更新。</p>
<p>很显然auto也并不完美，auto类型推断依赖于initializer，
initializer expression可能并不是我们想要的类型。
同时auto也带来了可读性上的问题。</p>
<h2 id="things-to-remember-4"><a class="header" href="#things-to-remember-4">Things to Remember</a></h2>
<ul>
<li>auto使得变量必须初始化，免疫了类型不匹配带来的转换，进一步防止转换带来的可靠性和性能的问题，
方便于重构代码，减小拼写成本。</li>
<li>auto的使用也容易陷入一些陷阱，见Item2和Item6。</li>
</ul>
<h1 id="item6-use-the-explicitly-type-initializer-idiom-when-auto-deduce-undesired-types"><a class="header" href="#item6-use-the-explicitly-type-initializer-idiom-when-auto-deduce-undesired-types">Item6: Use the Explicitly Type Initializer Idiom When auto Deduce Undesired Types</a></h1>
<h2 id="proxy-class"><a class="header" href="#proxy-class">Proxy class</a></h2>
<p>auto具有许多优点，但是某些情况下，auto会产生一个非期望的结果。如下：</p>
<pre><code>vector&lt;bool&gt; features(const Widget&amp; w);     // A function return a vector&lt;bool&gt;.
</code></pre>
<p>bool的vector是一个特化类型，其中bool的存储是bit级别的。比如bit5指代了Widget优先级。</p>
<pre><code>Widget w;
...
bool highPriority = features(w)[5];        // Get the Priority of w.
...
process(w,highPriority);            // Do something with w.
</code></pre>
<p>这段代码没有任何问题。但如果使用auto去声明highPriority。</p>
<pre><code>auto highPriority = features(w)[5];        // Is auto giving the right type.

process(w,highPriority);            // Undefined behaviour.
</code></pre>
<p>该代码的运行结果是不确定的。</p>
<p>因为vector<bool>是vector的一个特化类型。出于储存空间的考虑，bool只是概念性的存在于vector容器中，
operator[]返回的并不是bool reference to element，而是vector<bool>::reference。这是一个嵌套在vector<bool>中的类。</p>
<blockquote>
<p>The std::vector<bool> specialization defines std::vector<bool>::reference as a publicly-accessible nested class.</p>
</blockquote>
<p>bool在vector<bool>中的存在方式是一个个的bit位。所以operator[]返回的是一个行为类似于bool的对象，该对象于bool之间存在隐式转换。
所以</p>
<pre><code>bool highPriority = features(w)[5];
auto highPriority = features(w)[5]; 
</code></pre>
<p>前者触发了隐式转换，而后者并没有。后者的值取决于std::vector<bool>::reference的实现。</p>
<p>比如reference中包含了一个指示bit位置的指针。由于features返回了一个vector<bool>的对象，该对象是临时的调用了operator[]，最终highPriority被初始化为reference。然而待语句结束后，vector<bool>的临时对象已经消失，highPriority中的指针悬空，造成了未定义行为(比如而后发生了bool的隐式转换)。</p>
<pre><code>process(w,highPriority);            // Undefined behaviour. highPriority implicit 
                                       convert to bool with dangling pointer.
</code></pre>
<p>proxy class: 代理类，是为了模仿和补强某些类型存在的。比如std::vector<bool>::reference对于bool和智能指针对于raw指针。
有些代理类是暴露给用户的，比如智能指针，有些是隐藏的，比如std::vector<bool>::reference。</p>
<p>某些C++库中，使用一种expression templates的技术。见下表达式:</p>
<pre><code>Matrix sum = m1 + m2 + m3 + m4;
</code></pre>
<p>可以直接实现运算符重载operator+返回一个Matrix对象，这样一来每个operator+都会产生一个临时变量，</p>
<p>但是使用expression templates技术可以提高效率。operator+不再返回一个Matrix对象，而是返回一个proxy class比如Sum&lt;Matrix，Matrix&gt;，这是一个可以隐式转换为Matrix对象的类，同时还允许Sum从表达式初始化，means：</p>
<pre><code>Sum&lt;Sum&lt;Sum&lt;Matrix，Matrix&gt;，Matrix&gt;，Matrix&gt;
</code></pre>
<p>这样一来，减少了临时变量的拷贝和生成，这项使用显然是对用户隐藏的。</p>
<p>auto与invisable proxy class的相性不好，因为大多数invisible proxy class都是设计为短寿命的。</p>
<p>所以应该避免以下情况:</p>
<pre><code>auto tmp = expression of invisable proxy class type;
</code></pre>
<h2 id="how-to-recognize-the-proxy-class-type"><a class="header" href="#how-to-recognize-the-proxy-class-type">How to Recognize the Proxy Class Type</a></h2>
<p>一是通过文档，二是通过源码。熟悉类的设计，可以大幅降低这方面的错误。</p>
<ul>
<li>explicitly typed initializer idiom</li>
</ul>
<p>auto并不是无法用在proxy class上的，如下：</p>
<pre><code>auto highPriority = static_cast&lt;bool&gt;(features(w)[5]);
</code></pre>
<p>feature(w)[5]返回了一个std::vector<bool>::operator[],然后应用强制转换成bool。
由于是在同一个语句中进行的，所以不会出现上述所言的悬空指针的情况，便不会出现undefined behaviour。
最后auto进行类型推断即可。</p>
<p>同时显式类型初始化语句也可以用于强调转换，使得某些隐式转换不被忽略。比如：</p>
<pre><code>double calcEpsilon();       // Return tolerance value.
auto ep = static_cast&lt;float&gt;(calcEpsilon());
</code></pre>
<h2 id="things-to-remember-5"><a class="header" href="#things-to-remember-5">Things to Remember</a></h2>
<ul>
<li>&quot;invisable&quot; proxy class types 可以造成auto类型推断出“某种意义上不对”的类型。</li>
<li>explicitly typed initializer idiom可以防止上述错误的发生。</li>
</ul>
<h1 id="item7-distinguish-between--and--when-creating-objects"><a class="header" href="#item7-distinguish-between--and--when-creating-objects">Item7: Distinguish Between () and {} when creating objects</a></h1>
<p>在modern C++中，初始化从语法上分类在大致有以下三种：parentheses、equals、braces。</p>
<pre><code>int x(0);       // Initializer is an int parentheses.
int y = 0;      // Initializer follows '='.
int z{ 0 };     // Initializer is in braces.
</code></pre>
<p>还可以见到：</p>
<pre><code>int z = { 0 }；      // Initializer uses '=' and braces.
</code></pre>
<p>这种情况在C++中和只用braces是一样的。</p>
<h2 id="initialization-is-not-assignment"><a class="header" href="#initialization-is-not-assignment">Initialization is not Assignment</a></h2>
<p>首先必须意识到，initialization并不是assignment。对于built-in类型，没有什么问题；但对于定义型的类型
区别赋值和初始化在于调用的函数的不同。</p>
<pre><code>Widget w1;          // Call default constructor.
Widget w2 = w1;     // Not an assignment; calls copy constructor.
w1 = w2;            // Assignment, calls copy assignment(operator=).
</code></pre>
<h2 id="uniform-initialization"><a class="header" href="#uniform-initialization">Uniform Initialization</a></h2>
<p>在C++98时期，没有语法支持一些初始化，比如STL容器内一系列值的初始化。
C++11为了解决这类问题，引入了一个uniform initialization，至少在概念上可以运用于所有初始化场景的初始化语法。在概念上可以称为&quot;uniform initialization&quot;,在句法上可以称为&quot;braced initialization&quot;。
比如：</p>
<pre><code>std::vector&lt;int&gt; v{ 1, 2, 3 };      // Initialize the vector with a particular set                                       // of value.
</code></pre>
<p>Braced-initialization还可以用于类成员非static对象的默认初始化。</p>
<pre><code>class ex {
    ...
private:
    int x{ 0 };     // Fine, braced-initialization.
    int y = 0;      // Fine, copy-initialization.
    int z(0);       // Wrong!
};
</code></pre>
<p>另一方面，不可复制对象(uncopyable)也可以用braced-initialization。</p>
<pre><code>std::atomic&lt;int&gt; ai1{ 0 };      // Fine.
std::atomic&lt;int&gt; ai2(0);        // Fine.
std::atomic&lt;int&gt; ai3 = 0;       // Wrong! Connot copy-initialization.
</code></pre>
<p>从上面的例子可以看出braced-initialization在所有情况的初始化下都是适用的。</p>
<p>值得注意一点：braced-initialization是不允许进行隐式缩窄转换(implicit narrowing convertion)。
(但是在clang中可以啊。。。)</p>
<pre><code>double x, y;
int sum1{ x + y};       // Error! Requiring a narrowing convertion. 
int sum2(x + y);        // Fine.
int sum3 = x + y;       // Fine.
</code></pre>
<p>还有一点有价值的内容是关于默认构造函数的。</p>
<pre><code>Widget w1(10);          // Calls the constructor with one argument 10.
Widget w2();            // Declare a function that return type is Widget, Do not                             // Calls the default constructor.
Widget w3{};            // Calls the default constructor.
</code></pre>
<p>可以看出braced-initialization防止了一些语法习惯带来的意外。</p>
<h2 id="some-superising-behaviour-about-braced-initialization"><a class="header" href="#some-superising-behaviour-about-braced-initialization">Some Superising Behaviour About Braced-initialization</a></h2>
<p>由于braced-initialization和std::initialize_list之间纠缠的关系，braced-initialization会出现一些出乎意料的情况。比如Item2中所言的auto问题（在C++17中有更改）。还有就是涉及到构造函数的调用问题：</p>
<pre><code>class Widget{
public:
    Widget(int i, bool b);
    Widget(int i, double b);
    ...
};

Widget w1(10, true);        // Calls first ctor.
Widget w2{10, true};        // Calls first ctor.
Widget w3(10, 5.0);         // Calls second ctor.
Widget w4{10, 5.0};         // Calls secong ctor.
</code></pre>
<p>如果说构造函数中没有涉及到任何initializer_list的parameter，那么{}和()的对于ctor的调用行为是一致的。
但是如果涉及了initializer_list的parameter，情况就不一样了：</p>
<pre><code>class Widget{
public:
    Widget(int i, bool b);
    Widget(int i, double b);
    Widget(std::initializer_list&lt;long double&gt; il);  // Initializer_list parameter.
    ...
};

Widget w1(10, true);        // Calls first ctor.
Widget w2{10, true};        // Calls third ctor. 
                            // 10 and true will convert to long double.
Widget w3(10, 5.0);         // Calls second ctor.
Widget w4{10, 5.0};         // Calls third ctor. 
                            10 and 5.0 will convert to long double.
</code></pre>
<p>在这种情况下，w2和w4会优先调用新的构造函数，即使该构造函数显然没有其他函数更加匹配传入参数的形式。
甚至拷贝和移动构造函数也会被Initializer_list-parameter-ctor劫持。</p>
<p>？？？此处貌似和程序验证不符合，未查明原因(MSVC和clang均不符合)</p>
<pre><code>class Widget{
public:
    Widget(int i, bool b);
    Widget(int i, double b);
    Widget(std::initializer_list&lt;long double&gt; il);  // Initializer_list parameter.
    operator float() const;         // Convert to float.
    ...
};

Widget w5(w4);              // Calls copy-ctor.
Widget w6{ w4 };              // Calls Initializer_list-parameter-ctor.
                            // w4 converts to float through operator float()
                            // then converts to long double.
Widget w7(std::move(w4));       // Calls move-ctor.
Widget w8{ std::move(w4) };     // Calls Initializer_list-parameter-ctor.
                                // w4 converts to float through operator float()
                                // then converts to long double.
</code></pre>
<h2 id="initializer_list-and-constructor"><a class="header" href="#initializer_list-and-constructor">Initializer_list and Constructor.</a></h2>
<p>当一个non-aggregate class类型braced-initialization，重载方案选择遵守以下两条规则：</p>
<ul>
<li>如果有initializer-list ctor，则候选函数只有initializer-list ctor，并且{}列表至少有一个元素
则整个参数列表作为initializer_list传入ctor。</li>
<li>如果没有initializer-list ctor匹配(包含转换)，其他所有构造函数都可以成为候选函数，参数列表分开传入ctor。</li>
</ul>
<p>如果{}为空并且类有默认构造函数，则跳过前一条原则。
如果是copy-list-initialization，如果选拔出的ctor是explicit的，则ill-formed。</p>
<pre><code>class Widget{
public:
    Widget(int i, bool b);
    Widget(int i, double b);
    Widget(std::initializer_list&lt;bool&gt; il);  // Initializer_list parameter.
    ...
};

Widget w{ 1, 5.0 };         // error! Requires narrowing conversion.
</code></pre>
<p>如上即使这里拥有完美配对的Widget(int i, double b)，但是该构造函数不在候选之中，
反而是使用了initializer_list ctor，同时缩窄转换带来错误。</p>
<p>如果初始化列表中的元素与initializer_list的元素不存在转换，则符合原则二：</p>
<pre><code>class Widget{
public:
    Widget(int i, bool b);
    Widget(int i, double b);
    Widget(std::initializer_list&lt;string&gt; il);  // Initializer_list parameter.
    ...
};

Widget w{ 1, 5.0 };         // Fine. Use non-initializer_list constructor.
</code></pre>
<p>由于1和5.0无法隐式转换为string，所以候选才加入了前两个构造函数。</p>
<p>接着如果是空的初始化列表并且有默认构造函数，则跳过原则一：</p>
<pre><code>class Widget{
public:
    Widget()；           // Default constructor.
    Widget(std::initializer_list&lt;string&gt; il);  // Initializer_list parameter.
    ...
};

Widget w1;          // Call the default ctor.
Widget w2{};        // Call the default ctor.
Widget w3();        // Define a function that return Widget.
Widget w4({});      // Call the initializer_list one.
Widget w5{{}};      // ditto.
</code></pre>
<p>在设计类的构造函数时应该尽量避免和vector类似的情况：</p>
<pre><code>std::vector&lt;int&gt; v1{ 10, 20 };  // Initialize v1 with two elements in the list.

std::vector&lt;int&gt; v2(10, 20);    // Initialize v2 with ten elements (20).
</code></pre>
<p>设计类时应当尽量使用户不论使用{}还是()都获得一样的结果。比如，原本类中不含有initializer_list ctor，但是后来添加了，如果像vector一样的设计，会导致原本用户的代码调用不同的构造函数。这与普通的重载不一样，因为initializer_list ctor总是trump其他构造函数，导致更大的问题。</p>
<h2 id="choose-braces-or-parentheses"><a class="header" href="#choose-braces-or-parentheses">Choose Braces or Parentheses</a></h2>
<p>作为类用户，选择Braces和Parentheses有两种方法，以其中一个为主，不到万不得已时使用另一个，并且持之以恒。
两种方法各有所长。</p>
<p>作为模板类设计，这个选择便十分关键了，见下：</p>
<pre><code>template&lt;typename T, typename... Ts&gt;
void doSome(Ts&amp;&amp;... params) {
    create local object from params.
}
</code></pre>
<p>可以有以下两种实现：</p>
<pre><code>T localobj(std::forward(params)...);        // Using paren.
T localobj{ std::forward(params)... };      // Using brace.
</code></pre>
<p>对于vector就会产生不同的效果：</p>
<pre><code>doSome&lt;std::vector&lt;int&gt;&gt;(10, 20);
</code></pre>
<p>前者生成10个元素，初始化为20；后者生成2个元素，初始化为10、20。
这个问题，在标准库设计中也存在，std::make_shared和std::make_unique。</p>
<h2 id="things-to-remember-6"><a class="header" href="#things-to-remember-6">Things to Remember</a></h2>
<ul>
<li>braced-initialization可以应用到更广泛的情景，避免缩窄转换(clang好像并不会)，避免某个混淆语句。</li>
<li>注意构造函数重载中，initializer_list constructor的特殊。</li>
<li>std::vector&lt; numeric type&gt;构造在选用{}和()的不同。</li>
<li>关注模板中使用{}和()进行实现的不同。</li>
</ul>
<h1 id="item8-prefer-nullptr-to-0-and-null"><a class="header" href="#item8-prefer-nullptr-to-0-and-null">Item8: Prefer <em>nullptr</em> to 0 and <em>NULL</em></a></h1>
<p>在C++中，字面值0是一个int，在contxet中，0有可能被解释为null pointer。
但是这是后置位的情形，0依旧是一个int而不是null pointer。</p>
<p>NLL这个宏依赖于实现，有可能是int(0),也有可能是long(0)，NULL对于指针也具有一样的问题。</p>
<p>在C++98中，对于指针和整数的参数重载具有存在陷阱：</p>
<pre><code>void f(int);
void f(bool);
void f(void*);

f(0);       // Call f(int).

f(NULL);    // Depend on implementation, might not complie. but  
            // never calls f(void*).
</code></pre>
<p>因为NULL的实现可以是0，也可以是0L，而0L转换给void*，int，bool是平等的，导致歧义，造成报错。</p>
<p>另一方面，nullptr的好处在于其不具有整数值，它能够转换为指向任意类型的null pointer。使用nullptr，就能避免上述的重载问题。</p>
<pre><code>f(nullptr)  // Call f(void*).
</code></pre>
<p>同时使用nullptr，也可以增强代码可读性。</p>
<pre><code>auto result = find(/*arg*/);

if(result != 0)...

if(result != nullptr)...
</code></pre>
<p>很显然下面的代码表面了result是一个指针。</p>
<p>当模板进入代码时，nullptr的作用更加明显：</p>
<pre><code>int f1(std::shared_ptr&lt;Widget&gt; spw);
double f2(std::unique_ptr&lt;Widget&gt; upw);
bool f3(Widget* pw);

std::mutex f1m, f2m, f3m;

using MuxGuard = std::lock_guard&lt;std::mutex&gt;;
...
{
    MuxGuard g(f1m);
    auto result = f1(0);
}
...
{
    MuxGuard g(f2m);
    auto result = f2(NULL);
}
...
{
    MuxGuard g(f3m);
    auto result = f3(nullptr);
}
</code></pre>
<p>以上代码具有高度的重复性，可以将其模板化：</p>
<pre><code>template&lt;typename FuncType, typename MuxType, typename PtrType&gt;
decltype(auto) lockAndCall(FuncType func,
                            MuxType mutex,
                            PtrType ptr) {
    using MuxGuard = std::lock_guard&lt;MuxType&gt;;
    MuxGuard g(mutex);
    return func(ptr);
}

auto result1 = lockAndCall(f1, f1m, 0);         // error!
auto result1 = lockAndCall(f2, f2m, NULL);      // error!
auto result1 = lockAndCall(f3, f3m, nullptr);   // fine!
</code></pre>
<p>在第一个模板函数中，PrtType被推断为int，这就导致在模板内部func要接收一个int，
对于f1来说，相当于用一个int去初始化shared_ptr&lt;Widget&gt;，这是错误的(因为0可以指代指针，但是int是不可以的)，对于第二个也是类似的情况。</p>
<p>而nullptr是没有这方面的问题的。传入nullptr时，PrtType被推断为std::nullptr_t。而nullptr_t是可以转化为Widget*和shared_ptr&lt;Widget&gt;的。</p>
<h2 id="things-to-remember-7"><a class="header" href="#things-to-remember-7">Things to Remember</a></h2>
<ul>
<li>使用nullptr代替NULL和0。</li>
<li>避免重载整数和指针类型。</li>
</ul>
<h1 id="item9-prefer-alias-declarations-to-typedefs"><a class="header" href="#item9-prefer-alias-declarations-to-typedefs">Item9: Prefer Alias Declarations to typedefs</a></h1>
<p>别名是C++减少长类型名拼写的有效手段。<br />
在C++98中：</p>
<pre><code>typedef std::unique_str&lt;std::unordered_map&lt;std::string, std::string&gt;&gt; UPtrMapSS;
</code></pre>
<p>而在C++11中：</p>
<pre><code>using UPtrMapSS = std::unique_str&lt;std::unordered_map&lt;std::string, std::string&gt;&gt;；
</code></pre>
<p>以上两例，无法看出typedef和using的区别与差距，也看不出using的优势。<br />
但是当我们想为某些类型，比如函数指针、数组等起别名时，语义的表达性就不一样了：</p>
<pre><code>typedef void (*fp)(int, const std::string&amp;);     // typedef.

using fp = void(*)(int, const std::string&amp;);     // alias declaraiton.
</code></pre>
<p>显然using对于fp的表达更加直观，但这仍然不是alias declaration优于typedef的绝对理由。</p>
<h2 id="about-template-alias"><a class="header" href="#about-template-alias">About Template Alias</a></h2>
<p>using可以用于template(alias templates)，而typedef不可以。<br />
传统的将别名用于模板的做法是为typedef加上一层struct的封装：</p>
<pre><code>template&lt;typename T&gt;
typedef std::list&lt;T, MyAlloc&lt;T&gt;&gt; MyAllocList;   // error! canot typedef.

template&lt;typename T&gt;
struct MyAllocList {
    typedef std::list&lt;T, MyAlloc&lt;T&gt;&gt; type;      // Add struct outside. 
}

MyAllocList&lt;Widget&gt;::type lw;           // Client code.

template&lt;typename T&gt;
using MyAllocList = std::list&lt;T, MyAlloc&lt;T&gt;&gt; ;   // Fine.

MyAllocList&lt;Widget&gt; lw;                 // Client code.
</code></pre>
<p>using与typedef在用户代码上的差距就表现出来了。除此之外，还有一个using优于typedef的方面
，当我们在template中使用'typedef型'的模板别名时，::type是dependent type，编译器无法知道这是不是一个类型，就必须加typename来指示该名为类型成员：</p>
<pre><code>template&lt;typename T&gt;
class Widget {
private:
    typename MyAllocList&lt;T&gt;::type list;
}
</code></pre>
<p>而using不需要外部封装，就没有这方面的问题：</p>
<pre><code>template&lt;typename T&gt;
class Widget {
private:
    MyAllocList&lt;T&gt; list;
}
</code></pre>
<p>MyAllocList是一个类型别名，所以MyAllocList<T>必须是一个类型，而不是变量，所以MyAllocList<T>是non-dependent type，所以typename是可以忽略的。<br />
再看以下代码：</p>
<pre><code>class Wine { ... };

template&lt;&gt;                      // A specialization of MyAllocList.
class MyAllocList&lt;Wine&gt; {       // when T is wine.
private:
    enum class WineType
    { White, Red, Rose };       // Here type is data member, not type member.
    WineType type;
    ...
}
</code></pre>
<p>可以看到这里type是一个数据成员，而不是类型成员。如果Widget对T = Wine生成一个实例。那么::type
在Widget模板中就是一个数据名。这就是为何需要typename的原因。</p>
<p>C++11中提供了一系列类型处理的功能模板(base on TMP),&lt;type_traits&gt;</p>
<pre><code>std::remove_const&lt;T&gt;::type              // Yields T from const T.
std::remove_reference&lt;T&gt;::type          // Yields T from T&amp;.
std::add_lvalue_reference&lt;T&gt;::type      // Yields T&amp; from T.
</code></pre>
<p>这些模板的实现都是依赖于内嵌typedef的。</p>
<p>C++14给了更好的实现，依赖于using:</p>
<pre><code>std::remove_const_t&lt;T&gt;              // Yields T from const T.
std::remove_reference_t&lt;T&gt;          // Yields T from T&amp;.
std::add_lvalue_reference_t&lt;T&gt;      // Yields T&amp; from T.

template&lt;typename T&gt;
using remove_const_t = typename remove_const&lt;T&gt;::type;

template&lt;typename T&gt;
using remove_reference_t = typename remove_reference&lt;T&gt;::type;

template&lt;typename T&gt;
using add_lvalue_reference_t = typename add_lvalue_reference&lt;T&gt;::type;
</code></pre>
<h2 id="things-to-remember-8"><a class="header" href="#things-to-remember-8">Things to Remember</a></h2>
<ul>
<li>typedefs不支持模板化，但是using支持。</li>
<li>alais template避免了嵌套和::type的后缀，注意typename对于dependent type的作用。</li>
<li>C++14提供了traits的更好的实现。</li>
</ul>
<h1 id="item10-prefer-scoped-enums-to-unscoped-enums"><a class="header" href="#item10-prefer-scoped-enums-to-unscoped-enums">Item10: Prefer Scoped Enums to Unscoped Enums</a></h1>
<h2 id="scoped-and-avoid-converting"><a class="header" href="#scoped-and-avoid-converting">Scoped and Avoid Converting</a></h2>
<p>在一般的原则下，一个block{}代表了一个scope。但是enum是例外的，enum中的变量的作用域在enum所在的域中。</p>
<pre><code>enum Color { black, white, red };       // black, white..has the same scope as Color.

auto white = false;                     // error! white already declared in Color.
</code></pre>
<p>C++11中，提供了更加符合常理的enum：scoped-enum。</p>
<pre><code>enum class Color{ black, white, red };  // black, white...are scoped in Color.

auto white = false;                     // Fine. 

Color cc = white;                       // error, white is bool.

Color cc = Color::white;                // Fine.

auto cc = Color::white;                 // cc is Color.
</code></pre>
<p>通过scoped-enum来防止枚举变量的泄露。</p>
<p>同时enum具有和整型之间的隐式转换，而enum class则没有。</p>
<pre><code>enum Color { black, white, red };
std::vector&lt;std::size_t&gt; primeFactors(std::size_t x);

Color cc =red;

if(cc &lt; 14.5) {
    auto factors = primeFactors(cc);        // Implicitly convert happen.
}

enum class Color { black, white, red };

Color cc = Color::red;

if(cc &lt; 14.5) {                             // error! cannot convert.
    auto factors = primeFactors(cc);        // error! cannot convert.
}

if(static_cast&lt;double&gt;(cc) &lt; 14.5) {        // Fine.
    auto factors = primeFactors(static_cast&lt;std::size_t&gt;(cc));  // Fine.    
}
</code></pre>
<h2 id="forward-enum-declaration"><a class="header" href="#forward-enum-declaration">Forward enum Declaration.</a></h2>
<p>注意enum是一个编译期确定的量，scoped-enum的另一个优越性就是可以进行前置声明。</p>
<pre><code>enum Color;         // error！ cannot forward-declaration.

enum class Color;   // Fine.
</code></pre>
<p>这是不完全的，因为enum在C++11中也可以通过一些额外动作使得其可以进行前置声明。前置声明的好处在于可以减少编译。比如存在以下头文件：</p>
<pre><code>// file locstring.h
#include &lt;string&gt;
enum localized_string_id
{
/* very long list of ids */
};

std::istream&amp; operator&gt;&gt;(std::istream&amp; is, localized_string_id&amp; id);
std::string get_localized_string(localized_string_id id);
</code></pre>
<p>可以看到下方的两个函数是依赖于enum的。如果localized_string_id中的变量是频繁改变的。那所有包含了该头文件的组件都要重新编译，这要付出很高的成本。</p>
<p>如果使用前置声明，就可以直接在头文件中保留前置声明部分，并且为每一个编译单元实现各自的enum（注意enum是编译期确定的），一些不依赖于新加入的enumerator的单元就可以不用再次进行编译了。</p>
<h2 id="underlying-type"><a class="header" href="#underlying-type">Underlying-Type</a></h2>
<p>之所以在C++98中没有前置声明，是因为enum实现类似于一个打包宏定义。</p>
<pre><code>enum Color { black, white, red};

#define black 0;
#define white 1;
#define red 2;
</code></pre>
<p>所以enum其实是有一个底层实现的intergal type的，可以是int，char...具体依赖于编译器自己实现的。</p>
<p>unscoped-enum是不确定的，但是scoped-enum是确定的，默认为int，但是在c++11后，enum也可以进行强类型的声明。</p>
<pre><code>enum class status;      // Underlying type is int.

enum status;            // Unknown.

enum class status :uint8_t;     // Underlying type is uint8_t.

enum status :uint8_t;           // Underlying type is uint8_t.
</code></pre>
<h2 id="where-unscoped-enum-is-better-than-scoped-enum"><a class="header" href="#where-unscoped-enum-is-better-than-scoped-enum">Where Unscoped-enum is Better Than Scoped-enum</a></h2>
<p>虽然scoped-enum具有许多优点：防止隐式转换，防止命名空间的污染，具有前置声明之类的。但是有一个地方enum比scoped-enum更加适用-tuple：</p>
<pre><code>using UserInfo = std::tuple&lt;string,     // Name. 
                            string,     // Email.
                            size_t&gt;     // Reputation.

UserInfo uInfo;     // Object of UserInfo.
auto val = std::get&lt;1&gt;(uInfo);      // Get the field 1-email.
</code></pre>
<p>就和注释中所言，字段1代表了uInfo的email，但是1代表email总是不直观的。</p>
<pre><code>enum UserInfoField { uiName, uiEmail, uiReputation };
auto val = std::get&lt;uiEmail&gt;(uInfo);        // Get the field uiemail.
</code></pre>
<p>这就利用了enum的隐式转换，使用scoped-enum显然就要费事的多。</p>
<p>或许可以通过外加的包装实现更简单的语法，但是注意field-1是一个template parameter，这意味着值需要在编译期间确定，enum具有这样的能力（或者宏），所以这层包装就需要用到constexpr function:</p>
<pre><code>template&lt;typename E&gt;
constexpr auto
toUType(E enumerator) noexcept {
    return static_cast&lt;typename 
        std::underlyting_type&lt;E&gt;::type&gt;(enumerator);
}

enum class UserInfoField { uiName, uiEmail, uiReputation };

auto val = std::get&lt;toUType(uiEmail)&gt;(uInfo);
</code></pre>
<p>即使加上封装，还是不如enum来的简单，但是这又避免了污染命名空间。</p>
<h2 id="things-to-remember-9"><a class="header" href="#things-to-remember-9">Things to Remember</a></h2>
<ul>
<li>scoped-enum不会污染命名空间，而且只能通过cast转换为其他类型。</li>
<li>scoped-enum和unscoped-enum都具有指定underlying-type的方法，不同的是，scoped-enum具有默认的int，而unscoped-enum没有。</li>
<li>scoped-enum总是可以前置声明，而unscoped只有在指定underlying-type时才可以，注意enum工作在编译期。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="item11-prefer-deleted-functions-to-private-undefined-ones"><a class="header" href="#item11-prefer-deleted-functions-to-private-undefined-ones">Item11: Prefer deleted Functions to Private Undefined Ones</a></h1>
<p>在C++中，有一类成员函数是特殊的，这些成员函数在某些情况下会被编译器默认实现：'member function5'，即：默认构造函数、复制构造函数、复制赋值操作符、移动构造函数、移动赋值操作符。</p>
<p>但是有时候这类函数是不被需要的，所以需要从实现中删除该实现。</p>
<h2 id="declare-them-private-but-not-define-them-or-use--delete"><a class="header" href="#declare-them-private-but-not-define-them-or-use--delete">Declare Them private But Not Define Them or Use = delete.</a></h2>
<p>在C++98中，要实现上面所言的特性，可以通过在private访问控制下声明函数，同时不实现他们，就可以达到目的。比如basic_ios的复制构造函数和复制赋值操作符：</p>
<pre><code>template&lt;class charT, class traits = char_traits&lt;charT&gt;&gt;
class basic_ios : public ios_base {
public:
    ...
    
pirvate:
    basic_ios(const basic&amp;);                // copy-constructor.
    basic_ios&amp; operator=(const basic&amp;);     // copy-assginment.
}
</code></pre>
<p>C++11中提供了= delete来进行实现deleted function：</p>
<pre><code>template&lt;class charT, class traits = char_traits&lt;charT&gt;&gt;
class basic_ios : public ios_base {
public:
    ...
    basic_ios(const basic&amp;) = delete;                // copy-constructor.
    basic_ios&amp; operator=(const basic&amp;) = delete;     // copy-assginment.
}
</code></pre>
<p>使用= delete的好处在于：</p>
<ul>
<li>public的访问控制比private能够提供更好的纠错报告。</li>
<li>= delete可以在编译期发现，而老方法有可能要在link期才能发现</li>
</ul>
<h2 id="when-deleted-function-is-not-the-member-function"><a class="header" href="#when-deleted-function-is-not-the-member-function">When Deleted Function is Not the Member Function</a></h2>
<p>还有一个好处就是，= delete可以用在非成员函数上：</p>
<pre><code>bool isLucky(int number);       // Judge if a number is Lucky num.

isLucky('a');
isLucky(true);
isLucky(3.5);           // A series of unexpected usage.
</code></pre>
<p>由于隐式转换带来的非期望的使用方式，可以使用= delete禁止：</p>
<pre><code>bool isLucky(char) = delete;         // Reject char.
bool isLucky(bool) = delete;         // Reject bool.
bool isLucky(double) = delete;       // Reject double and float.
</code></pre>
<p>注意double参数的重载同时禁止了float，因为c++对于float进行隐式转换总是优先转换为double而不是int。
牢记被delete的函数是会参加函数重载匹配的，而且优先级不会有改变。</p>
<p>还有一个点deleted function的优越性在于可以禁止一个模板的某些实现：</p>
<pre><code>template&lt;typename T&gt;
void processPointer(T* ptr);        // Accept a pointer.

template&lt;&gt;
void processPointer&lt;void&gt;(void*) = delete;

template&lt;&gt;
void processPointer&lt;char&gt;(char*) = delete;
</code></pre>
<p>因为char*可以代表c风格的字符串，void*无法解除引用，需要将这两个实现禁止，以方便编译器报错。同样的，对于const指针也许也是不适用的：</p>
<pre><code>template&lt;&gt;
void processPointer&lt;const void&gt;(const void*) = delete;

template&lt;&gt;
void processPointer&lt;const char&gt;(const char*) = delete;
</code></pre>
<p>甚至对于const volatile void*也是不适合的：</p>
<pre><code>template&lt;&gt;
void processPointer&lt;const volatile void&gt;(const volatile void*) = delete;

template&lt;&gt;
void processPointer&lt;const volatile char&gt;(const volatile char*) = delete;
</code></pre>
<p>对于类内的模板函数也只能用delete，因为无法特化模板使之有不同的访问控制：</p>
<pre><code>class Widget {
public:
    ...
    template&lt;typename T&gt;
    void processPointer(T* ptr) {}
    ...
private:
    template&lt;&gt;
    void processPointer&lt;void&gt;(void*);       // error!
}

class Widget {
public:
    ...
    template&lt;typename T&gt;
    void processPointer(T* ptr) {}
    ...
}

template&lt;&gt;
void Widget::processPointer&lt;void&gt;(void*) = delete;
</code></pre>
<p>对于C++98的老方法，类外不能用，类内不一定能用，能用还可能在链接期才起作用，所以C++11的delete可以完全取代该方法。</p>
<h2 id="things-to-remember-10"><a class="header" href="#things-to-remember-10">Things to Remember</a></h2>
<ul>
<li>总是使用= delete。</li>
<li>所有function都可以被delete，包含模板的特化实现、非成员函数...</li>
</ul>
<h1 id="item12-declare-overriding-functions-override"><a class="header" href="#item12-declare-overriding-functions-override">Item12: Declare Overriding Functions <em>override</em></a></h1>
<p>C++中涉及OOP的主要包含了类、继承、虚函数。虚函数的概念相当于在子类中覆盖(override)了基类函数的实现，而这一机制常常出现错误。</p>
<p>因为&quot;overriding&quot;和&quot;overloading&quot;是非常易于混淆的。</p>
<pre><code>class Base {
public:
    virtual void doWork();      // Base class virtual func.
    ...
};

class Derived : public Base {
public:
    virtual void doWork();      // Derived class virtual func.
    ...
};

std::unique_ptr&lt;Base&gt; uqb =         // Create a ptr of Base-typed
    std::make_unique&lt;Derived&gt;();    // pointing to Derived-obj.

...
upb-&gt;doWork();                  // Call the doWork func.
</code></pre>
<h2 id="requirement-of-overriding"><a class="header" href="#requirement-of-overriding">Requirement of Overriding</a></h2>
<p>见上述代码，为了overriding机制生效，必须满足以下几个条件：</p>
<ul>
<li>基类的函数必须声明为<em>virtual</em></li>
<li>基类和子类的函数名必须一样(除了析构函数)</li>
<li>函数参数列表必须一样</li>
<li>函数constness必须一样</li>
<li>返回类型和异常修饰必须兼容</li>
</ul>
<p>以上为C++98的内容，C++11新添加了：</p>
<ul>
<li>reference限定符必须相同 </li>
</ul>
<p>包含有虚函数错误的代码往往是合法的，能够通过编译的，所以编译器往往不能提出警报：</p>
<pre><code>class Base {
public:
    virtual void mf1() const;
    virtual void mf2(int x);
    virtual void mf3() &amp;;
    void mf4() const;
};

class Derived : public Base {
public:
    virtual void mf1();
    virtual void mf2(unsigned int x);
    virtual void mf3() &amp;&amp;;
    void mf4() const;
};
</code></pre>
<p>以上代码不包含任何override机制的函数，都或多或少不满足要求。编译器可能不会提醒你，因为编译器也不明白你的需求是什么。</p>
<h2 id="override-and-final"><a class="header" href="#override-and-final"><em>override</em> And <em>final</em></a></h2>
<p>为了解决这一问题，C++11提供了显式要求override的方法，提供了关键字<em>override</em>：</p>
<pre><code>class Derived : public Base {
public:
    virtual void mf1() override;
    virtual void mf2(unsigned int x) override;
    virtual void mf3() &amp;&amp; override;
    void mf4() const override;
};
</code></pre>
<p>这样一来编译器必然报错，以上代码无法通过编译，因为编译器已经知道了你的需求是override，只有以下代码才能通过编译。</p>
<pre><code>class Base {
public:
    virtual void mf1() const;
    virtual void mf2(int x);
    virtual void mf3() &amp;;
    virtual void mf4() const;       // Add virtual
};

class Derived : public Base {
public:
    virtual void mf1() const override;
    virtual void mf2(int x) override;
    virtual void mf3() &amp; override;
    void mf4() const override;      // virtual is not necessary.
};
</code></pre>
<p>C++11中的<em>final</em>和<em>override</em>是contextual keywords。意味着这两个关键字可只在某些情况下被看作关键字。比如<em>override</em>只有在成员函数尾巴才是关键字。</p>
<h2 id="reference-qualifiers"><a class="header" href="#reference-qualifiers">Reference Qualifiers</a></h2>
<p>reference qualifiers可以理解为修饰*this的qualifier，这点和member function的const类似：</p>
<pre><code>void doSomething(Widget&amp; w);        // Accepts only lvalue.

void doSomething(Widget&amp;&amp; w);       // Accepts only rvalue.

class Widget {
public:
    void doWork() &amp;;        // Only when *this is lvalue.
    void doWork() &amp;&amp;;       // Only when *this is rvalue.
...
};

Widget makeWidget();
Widget w;

makeWidget().doWork();      // Use &amp;&amp; version.
w.doWork();                 // Use &amp; version.
</code></pre>
<p>再看以下代码：</p>
<pre><code>class Widget {
public:
    using DataType = std::vector&lt;double&gt;;
    ...
    DataType&amp; data() { return values; }
private:
    DataType values;
};

// Client code：
Widget w;
...
auto vals1 = w.data();      // Fine.copy the w.values to vals1.

Widget makeWidget();

auto vals2 = makeWidget().data();   // Copy too.
</code></pre>
<p>前一个用户代码，data()返回了一个value的左值引用，所以调用了copy-constructor，没有问题。第二个用户代码也是类似的操作，所以也没有问题。但是可以发现makeWidget()返回的是一个Widget的临时对象，是一个右值，在表达式结束后就被立刻销毁。所以使用拷贝整个values是浪费时间的，应该使用移动语义的方式节省时间，即调用vector的move-constructor:</p>
<pre><code>class Widget {
public:
    using DataType = std::vector&lt;double&gt;;
    ...
    DataType&amp; data() &amp; { return values; }
    DataType&amp;&amp; data() &amp;&amp; { return std::move(values); }
private:
    DataType values;
};

// Client code：
Widget w;
...
auto vals1 = w.data();      // Fine.copy the w.values to vals1.
                            // Use copy-constructor.
Widget makeWidget();

auto vals2 = makeWidget().data();   // Move the values to vals2.
                                    // Use move-constructor.
</code></pre>
<p>还有一点要注意的是，一旦一个member function被reference qualify，所有重载函数都要reference qualify。因为不进行qualify，就意味这重载函数不论左右值*this都可以使用，这些重载函数会对reference qualified one产生竞争，容易导致多义。</p>
<h2 id="things-to-remember-11"><a class="header" href="#things-to-remember-11">Things to Remember</a></h2>
<ul>
<li>使用<em>override</em>声明override function。</li>
<li>使用reference qualifier让左右值的对象有不同的行为。</li>
</ul>
<h1 id="item13-prefer-const_iterators-to-iterators"><a class="header" href="#item13-prefer-const_iterators-to-iterators">Item13: Prefer <em>const_iterator</em>s to <em>iterator</em>s</a></h1>
<p>在C++11中完善了对<em>const_iterator</em>的支持：</p>
<ul>
<li>
<p>对<em>const_iterator</em>的获取，即cbegin、cend等成员函数、以及C++14中的非成员函数。</p>
</li>
<li>
<p>iterator仅做指示作用的算法，如insert、erase对const_iterator支持。</p>
</li>
</ul>
<blockquote>
</blockquote>
<pre><code>std::vector&lt;int&gt; values; 
...
auto it = std::find(values.cbegin(), values.cend(), 1983);
values.insert(it, 1998);
</code></pre>
<p>这些对<em>const_iterator</em>的支持，也提升了泛型编程，以及C++标准化的水平：</p>
<pre><code>template&lt;typename C, typename V&gt;
void findAndInsert(C&amp; container,
                   const V&amp; targetV, 
                   const V&amp; insertV) {
    using std::cbegin;
    using std::cend;

    auto it = std::find(cbegin(container),      // Use non-member
        cend(container), targetV);              // version.
    
    container.insert(it,insertV);
}
</code></pre>
<p>使用非成员函数的cbegin..，该模板函数不仅对STL标准容器提供了支持，还对那些符合标准容器的第三方容器以及原生数组提供支持。</p>
<p>再看看cbegin非成员函数的实现方法：</p>
<pre><code>template&lt;typename C&gt;
decltype(auto) cbegin(const C&amp; container) {
    return std::begin(container);
}
</code></pre>
<p>令人奇怪的是函数最后返回的是begin而不是使用cbegin成员函数。解释如下：因为container是对传入容器的const引用，begin将会调用container的const版本的.begin()，最后返回的是<em>const_iterator</em>。这样既达到了目的，又实现了对没有cbegin成员函数的容器的适配，提高了泛型模板的覆盖面。</p>
<h2 id="things-to-remember-12"><a class="header" href="#things-to-remember-12">Things to Remember</a></h2>
<ul>
<li>尽量使用<em>const_iterator</em></li>
<li>在泛型编程中尽量使用non-member function形式的begin、end、rbegin...</li>
</ul>
<h1 id="item14-declare-functions-noexcept-if-they-wont-emit-exceptions"><a class="header" href="#item14-declare-functions-noexcept-if-they-wont-emit-exceptions">Item14: Declare Functions <em>noexcept</em> if They Won't Emit Exceptions</a></h1>
<p>C++98中的exception specifications带来糟糕的维护成本，在C++11中给出了更加简单直接的异常标识，就是直接指出代码是否会抛出异常，由此带来了关键字<em>noexcept</em>。代码是否会抛出异常关乎到用户代码的调用效率和异常安全。</p>
<pre><code>int foo() throw();          // C++98 style. less optimizable.
int foo() noexcept;         // C++11 style. most optimizable.
</code></pre>
<p>同时一个函数是否会抛出异常对于编译器优化也十分关键。比如foo抛出了异常，违反了无异常声明。noexcpt可能会在程序终止前进行栈展开，而throw版本必须进行栈展开。这就给予编译器更灵活的空间去优化。</p>
<h2 id="in-standard-library"><a class="header" href="#in-standard-library">In Standard Library</a></h2>
<p><em>noexcept</em>在C++标准库的优化也十分重要。</p>
<p>比如vector的push_back函数在需要reserve的情况下，需要将旧空间中的元素转移至新空间中。</p>
<p>在C++98中，一致使用copy。这样的好处是异常安全，因为即使抛出异常，原空间中的所有元素在完成copy之前都不会有改变；同时这样带来的开销也是巨大的。</p>
<p>在C++11中，将使用&quot;move if you can, but copy if you must&quot;的策略：move的方式可以带来更好的效率，但是move是异常不安全的，因为在移动过程中抛出异常而原本空间中的元素已经被改变，如果反向还原也有可能会抛出新的异常。</p>
<p>所以在C++11中，如果元素的move操作被标识不抛出异常，那这类函数(eg. deque::insert)就将采用move而非copy的方式转移元素。这样可以提高许多效率。</p>
<p>另一个例子是swap函数，swap函数的异常性质是由用户的swap函数的异常决定的。比如对于数组的swap：</p>
<pre><code>template&lt;class T, size_t N&gt;
void swap(T (&amp;a)[N], T (&amp;b)[N])
    noexcept(noexcept(swap(*a, *b)));
</code></pre>
<p>这里使用到了<em>conditionally noexcept</em> </p>
<h2 id="use-noexcept-with-caution"><a class="header" href="#use-noexcept-with-caution">Use <em>noexcept</em> With Caution</a></h2>
<p>许多函数其实是异常中立（<em>exception neutral</em>）的，即函数自己并不会抛出异常，但是其调用的函数会。最好不要为了使用noexcept去对外刻意隐藏这些异常，比如catch了所有异常、或者转换为错误码之类的方式，无疑会增加代码的复杂度，以及维护成本，换取的性能可能反而被这些处理所淹没。</p>
<p>对于一部分函数<em>noexcept</em>是十分重要的，所以这类函数默认为<em>noexcept</em>:</p>
<ul>
<li>memory deallocation function(i.e., operator delete\operator deletep[])</li>
<li>destructor</li>
</ul>
<p>在C++11中，这已经上升到了语言规则的层次，所有memory deallocation function和destructor，不论是编译自动生成还是用户定义的，都应该默认为<em>noexcept</em>（并不是必须，只是非常非常应该）。</p>
<p>只有一种情况，destructor非默认<em>noexcept</em>，即当有数据成员（包含基类）的destructor会抛出异常（e.g. &quot;noexcept(false)&quot;）。这种类型在使用标准库算法与容器时抛出异常都将是未定义行为。</p>
<h2 id="wide-contracts-and-narrow-contracts"><a class="header" href="#wide-contracts-and-narrow-contracts"><em>wide contracts</em> and <em>narrow contracts</em></a></h2>
<p>有些库会将函数区分为<em>wide contracts</em>和<em>narrow contracts</em>。<em>wide contracts</em>函数不对传入参数添加约束，不必照顾程序的状态。这类函数永远不会出现未定义行为，比如vector::size，我们申请了一块内存并将它强制转换为vector，但这个情况下size()的输出是合理的，符合定义的，但是该程序的行为确实没有定义保障。</p>
<p>而<em>narrow contracts</em>函数会对传入参数增加限制，并且需要照顾到程序状态。如果传入参数违反了限制，那么程序的结果是未定义的：</p>
<pre><code>void f(cosnt std::string&amp; s) noexcept;      // Prediction: s.size()&gt;=32.
</code></pre>
<p>如果传入string的长度小于32，那么该函数将会是未定义的。但是保证该前提是用户代码的义务，而不是f()的义务，所以f()不会进行参数检查，也不会抛出任何异常，所以声明<em>noexcept</em>的理由是充分的。</p>
<p>但是如果f()的实现进行了参数检查（防御式编程），因为处理异常往往比处理未定义行为要简单的多。所以f()将抛出异常，但是由于<em>noexcept</em>将会导致程序直接终止。</p>
<p>所以往往这种库设计时只会为<em>wide contracts</em>函数保留<em>noexcept</em>。</p>
<h2 id="compiler-offer-no-help-about-inconsistencies-between-implementations-and-exception-specifications"><a class="header" href="#compiler-offer-no-help-about-inconsistencies-between-implementations-and-exception-specifications">Compiler Offer no Help About Inconsistencies Between Implementations and Exception Specifications</a></h2>
<pre><code>void setup();            // Functions defined elsewhere.
void cleanup();

void doWork() noexcept {
    setup();
    ...
    cleanup();
}
</code></pre>
<p>doWork的异常声明和实现是矛盾的，因为setup和cleanup均没有声明<em>noexcept</em>。但是setup和cleanup却有可能在文档中说明了不会抛出任何异常，可能由于其他原因（比如库设计时间过去久远...）而没有声明<em>noexcept</em>，。所以doWork声明<em>noexcept</em>是完全合理的，编译器可能不会提出警告。</p>
<h2 id="things-to-remember-13"><a class="header" href="#things-to-remember-13">Things to Remember</a></h2>
<ul>
<li><em>noexcept</em>是函数接口的一部分，和<em>const</em>...一样，函数调用时可能会依赖于它。</li>
<li>编译器对<em>noexcept</em>函数的优化更强。</li>
<li><em>noexcept</em>对于swap和move操作等十分重要，对memory deallocation函数和destructor具有特殊的机制。</li>
<li>绝大多数函数都是异常中立的。</li>
<li>编译器对于函数的实现和异常声明上的矛盾有可能不会进行检查与警报。</li>
</ul>
<h1 id="item15-use-constexpr-whenever-possible"><a class="header" href="#item15-use-constexpr-whenever-possible">Item15: Use <em>constexpr</em> Whenever Possible</a></h1>
<p>从概念上来说，<em>constexpr</em>标识了一个值时，表明这是一个可以在编译期间就知道的值。但<em>constexpr</em>对于函数的意义并不像对于值一样简单。</p>
<p>constexpr function的返回值既不一定是const的，也不一定是编译期决定的。这可以理解为constexpr function的一项<em>feature</em>，因为这对于实现来说是非常友好的。</p>
<h2 id="constexpr-object"><a class="header" href="#constexpr-object"><em>constexpr</em> Object</a></h2>
<p>对于<em>constexpr</em>修饰的obj，既是<em>const</em>的，也是编译期决定的（其实更多的是在<em>translation</em>决定的，包含编译和链接）。</p>
<p>编译期决定的值是具有特殊性的：可以位于read—only memory；可以用于<em>integral constant expression</em>，比如数组大小、枚举值等。</p>
<pre><code>int sz;         // Non-constexpr variable.
constexpr auto arraySize1 = sz;     // error! sz's value not 
                                    // known at compilation.
std::array&lt;int, sz&gt; data1;          // error!
constexpr auto arraySize2 = 10;     // Fine, 10 is a const
                                    // expression
std::array&lt;int, arraySize2&gt; data2;  // Fine.
</code></pre>
<p>注意<em>const</em>并不提供编译期确定的保障：</p>
<pre><code>const auto arraySize = sz;          // Fine. arraySize is const.

std::array&lt;int, arraySize&gt; data;    // error!
</code></pre>
<p>即对于object，所有<em>constexpr</em>都是<em>const</em>的，但<em>const</em>的并不都是<em>constexpr</em>。</p>
<h2 id="constexpr-function"><a class="header" href="#constexpr-function"><em>constexpr</em> Function</a></h2>
<p>当<em>constexpr</em>用于function时，情况就变得复杂的多。</p>
<ul>
<li>
<p><em>constexpr</em>函数在传入参数均为编译期可确定参数将产生<em>constexpr</em>，即编译期返回值。</p>
</li>
<li>
<p><em>constexpr</em>函数在传入参数不全为编译期可确定参数，其行为和普通函数一致。即在运行期返回。<br />
&gt;</p>
<p>constexpr int pow(int base, int exp) noexcept { // pow's a func
...                                         // never throws.
}
constexpr auto numConds = 5;
std::array&lt;int, pow(3,numConds)&gt; results;       // Fine.</p>
</li>
</ul>
<p>pow()函数在该调用环境下产生了编译期可确定的变量。但如果传入的base和exp不全是编译期常量，那上述代码将会报错，因为array的模板参数有相应的要求：</p>
<pre><code>auto base = readFromDB(&quot;base&quot;);             // Get these values
auto exp = readFromDB(&quot;exponent&quot;);          // at runtime.
std::array&lt;int, pow(base, exp)&gt; results;    // error! call pow
                                            // at runtime.
</code></pre>
<p>所以为了满足在编译期返回常量，对<em>constexpr function</em>有实现的约束，而C++11和C++14中的约束不同。</p>
<p>在C++11中：<br />
<em>constexpr function</em>必须只存在一条<em>return</em>语句，不能存在其他任何语句，所以为了符合产生了许多不符合直觉的实现：（使用递归和?:）</p>
<pre><code>constexpr int pow(int base, int exp) noexcept {
    return (exp == 0 ? 1: base*pow(base, exp - 1));
}
</code></pre>
<p>在C++14中：<br />
这一约束被放宽，即：</p>
<pre><code>constexpr int pow(int base, int exp) noexcept {
    auto result = 1;
    for(int i = 0;i &lt; exp; ++i) result *= base;
    return result;
}
</code></pre>
<p><em>constexpr function</em>被限制只能够获取和返回<em>literal types</em>，即其值可以在编译期确定的类型。</p>
<p>在C++11中：<br />
所有内置类型（除了<em>void</em>）和用户定义类型都可以时<em>literal types</em>，因为构造函数与其他成员函数都可以是constexpr。</p>
<pre><code>class Point {
public:
    constexpr Point(double xVal = 0, double yVal = 0) noexcept
        : x(xVal), y(yVal){}
    constexpr double xValue() const noexcept { return x; }
    constexpr double yValue() const noexcept { return y; }
    
    void setX(double newX) noexcept { x = newX; }
    void setY(double newY) noexcept { y = newY; }
private:
    double x, y;
};
</code></pre>
<p>因为构造函数是<em>constexpr</em>，如果在构造Point时，传入的xVal和yVal都是编译期常量的话，那么Point也将会是编译期常量。</p>
<pre><code>constexpr Point p1(-9, 27.7);      // Fine. &quot;runs&quot; constexpr                                        // ctor during compilation.
constexpr double x = 28.8;
constexpr Point p2(x, 5.3);         // Ditto.
</code></pre>
<p>同样的Point相应的<em>constexpr</em>成员函数也能够产生<em>constexpr</em>。</p>
<pre><code>constexpr Point midPoint(const Point&amp; p1, const Point&amp; p2) noexcept {
    return { (p1.xValue() + p2.xValue())/2, 
             (p1.yValue() + p2.yValue())/2 };
}

constexpr auto mid = midPoint;      // Init constexpr object with
                                    // constexpr function.
</code></pre>
<p>这样的编程手段既完成了数据的抽象化，还通过<em>constexpr</em>将运行成本转移到编译期，提高程序的效率。同时还可以将这些数据直接创建在read-only-memory，使得这类数据可以用在<em>constant expression</em>中，用在数组长度、模板参数和枚举量这类参数上。</p>
<pre><code>p1.setX(1);             // error! p1 is const.
</code></pre>
<p>注意到两个set函数没有声明constexpr，因为在C++11中：所有constexpr成员函数默认const；函数返回值为void，非<em>literal type</em>。</p>
<p>但在C++14中，这两条也已经被忽略，可以进行这样的声明：</p>
<pre><code>constexpr void setX(double newX) noexcept {
    x = newX;
}

constexpr void setY(double newY) noexcept {
    y = newY;
}
</code></pre>
<p>这可能有些违背直觉：</p>
<pre><code>p1.setX(1);             // error! p1 is const.
</code></pre>
<p>该函数的使用依旧是报错的，因为直接在非<em>constexpr</em>环境下执行该操作，是非法的，p1已经是一个<em>constexpr object</em>，对其进行任何改变都是非法的，但可以进行这样的操作:</p>
<pre><code>constexpr Point reflection(const Point&amp; p) noexcept {
    Point result;                   // Create a non-const Point.
    result.setX(-p.xValue());
    result.setY(-p.yValue());
    return result;
}
</code></pre>
<p>该函数内部声明了一个non-const Point，这个Point可以使用setX和setY，如果传入的p是编译期常量，那么result的一系列操作也可以在编译期完成，所以最后返回值可以是一个编译期常量。</p>
<pre><code>constexpr auto reflec = reflection(p1);    // Create a constexpr.
std::array&lt;int, static_cast&lt;int&gt;(reflec.xValue())&gt; i;   // Fine.
</code></pre>
<h2 id="clear-why-use-constexpr-whenever-possible"><a class="header" href="#clear-why-use-constexpr-whenever-possible">Clear Why Use <em>constexpr</em> Whenever Possible</a></h2>
<ul>
<li><em>constexpr object</em>和<em>constexpr function</em>比普通变量和函数拥有更大的适用范围，更强大的效率。</li>
<li>注意<em>constexpr</em>是函数接口的一部分，既该函数可以用于常量表达式<em>constant expression</em>。</li>
<li>如果移除<em>constexpr</em>有可能导致大量代码非法。所以设计<em>constexpr</em>务必小心和慎用。</li>
</ul>
<h2 id="things-to-remember-14"><a class="header" href="#things-to-remember-14">Things to Remember</a></h2>
<ul>
<li><em>constexpr object</em>是<em>const</em>的，而且在编译期初始化。</li>
<li><em>constexpr function</em>产生<em>constexpr</em>当传入编译期常量时。</li>
<li><em>constexpr</em>变量和函数拥有更广的适用范围和减少运行期销耗。</li>
<li><em>constexpr</em>是函数和对象接口的一部分。</li>
</ul>
<h1 id="item16-make-const-member-functions-thread-safe"><a class="header" href="#item16-make-const-member-functions-thread-safe">Item16: Make <em>const</em> Member Functions Thread Safe</a></h1>
<h1 id="item17-understand-special-member-function-generation"><a class="header" href="#item17-understand-special-member-function-generation">Item17: Understand Special Member Function Generation</a></h1>
<p>对于C++类来说，有一些成员函数是特别的：<br />
在C++98中，包括默认构造函数(default constructor)、析构函数(destructor)、复制构造函数(copy constructor)、复制赋值操作符(copy assginment operator)。
这类函数在某些条件下，会由编译器自动生成，生成的函数隐含<em>public</em>和<em>inline</em>，而且总是非<em>virtual</em>的，除非基类函数的析构函数声明为<em>virtual</em>，则继承类的生成的析构函数为<em>virtual</em>。</p>
<p>在C++11中，这类函数又多了两个成员：移动构造函数(move constructor)、移动赋值操作符(move assignment operator)。其编译器生成的作用(与copy类似)是对非静态类成员进行&quot;memberwise moves&quot;，对于基类部分调用相应的移动方法。<br />
这些move操作并不是真正的move，该move操作是依赖与copy实现的，因为类型本身不存在move这个概念。</p>
<pre><code>class Widget {
public:
    Widget();           // default constructor.
    Widget(const Widget&amp;);      // copy constructor.
    Widget(Widget&amp;&amp;);           // move constructor.
    Widget&amp; operator=(const Widget&amp;);   // copy assignment operator.
    Widget&amp; operator=(Widget&amp;&amp;);    // move assignment operator.
};e
</code></pre>
<p>move的自动生成与copy有一点不同：</p>
<p>两个copy操作是独立的，如果自行实现其中一个，另一个依旧可以由编译器实现；但move不独立，自行实现其中一个，另一个将不会实现。理由是一旦你自行实现move，就意味着你将不使用默认的&quot;memberwise move&quot;的语义，那么编译器没有理由实现一个错误语义的move操作。</p>
<h1 id="item18-use-unique_ptr-for-exclusive-ownership-resource-management"><a class="header" href="#item18-use-unique_ptr-for-exclusive-ownership-resource-management">Item18: Use <em>unique_ptr</em> for Exclusive-ownership Resource Management</a></h1>
<h2 id="smart-pointers"><a class="header" href="#smart-pointers">Smart Pointers</a></h2>
<p>裸指针是强大的，但同时也是令人厌烦的：</p>
<ul>
<li>裸指针的声明没有指出其指向的是对象还是数组</li>
<li>裸指针的声明没有表明是否在完成使用后销毁其指向的对象，即声明没有指出该指针是否持有(<em>owns</em>)对象</li>
<li>即使需要销毁对象，裸指针也没有表明如何销毁该对象，是采用<em>delete</em>还是使用不同的销毁机制</li>
<li>使用<em>delete</em>时，不知道是使用<em>delete</em>还是<em>delete[]</em></li>
<li>对指针指向的对象使用析构函数时，很难保证只进行一次析构。错过析构导致内存泄漏，多次析构导致未定义行为</li>
<li>无从知道一个指针是否为野指针，指针指向的对象被析构后，指针仍然指向该内存产生野指针</li>
</ul>
<p>智能指针是一条解决上述问题的途径。智能指针是对裸指针的一次封装，保留指针特性的同时避免许多指针容易带来的错误。在C++11中，带来了4中智能指针：<em>std::auto_ptr std::unique_ptr std::shared_ptr std::weak_ptr</em>，用于管理对象的生命周期及资源，防止内存泄漏。</p>
<p><em>std::auto_ptr</em>是一个有设计缺陷的智能指针，在移动成为语义的同时，<em>std::unique_ptr</em>可以完全替代<em>std::auto_ptr</em>，而且更加强大高效。<em>std::auto_ptr</em>已经被标准所抛弃。</p>
<h2 id="stdunique_ptr"><a class="header" href="#stdunique_ptr"><em>std::unique_ptr</em></a></h2>
<ul>
<li><em>std::unique_ptr</em>默认情况下和裸指针具有一样的大小，大多数操作，同样的高效。</li>
<li><em>std::unique_ptr</em>表现为<em>exclusive ownership</em>(专属所有)语义。</li>
<li>一个非空的<em>std::unique_ptr</em>总是独立持有它所指向的对象。</li>
<li>移动一个<em>std::unique_ptr</em>意味着转让所有权，即dst指针获得对象，src指针设置为空指针。</li>
<li><em>std::unique_ptr</em>是<em>move-only</em>类型，不支持copy语义，因为<em>std::unique_ptr</em>不允许共享对象。</li>
<li>当<em>std::unique_ptr</em>被销毁时，其指向的对象将在这时刻前进行销毁。</li>
</ul>
<h2 id="common-use-for-stdunique_ptr"><a class="header" href="#common-use-for-stdunique_ptr">Common Use for <em>std::unique_ptr</em></a></h2>
<p><em>std::unique_ptr</em>可以用于工厂函数的返回类型。
比如我们拥有以下的层次结构：</p>
<pre><code>class Investment{...};
class Stock : public Investment{...};
class Bond : public Investment{...};
class RealEstate : public Investment{...};
</code></pre>
<p>工厂函数通常在堆上创建一个对象通过指针返回给用户，而用户需要对该对象的资源管理负责，通过使用<em>std::unique_ptr</em>，保证用户不需要该对象时，对象随着<em>std::unique_ptr</em>的销毁而销毁，防止内存泄漏。</p>
<pre><code>template&lt;typename... Targs&gt;
std::unique_ptr&lt;Investment&gt;
makeInvestment(Targs... params);
</code></pre>
<p>用户代码：</p>
<pre><code>{
    ...
    auto pInvestment = makeInvestment(argments);
    ...
}   // destroy *pInvestment.
</code></pre>
<p>同时<em>std::unique_ptr</em>也可以用于所有权交接的场景，比如工厂函数返回值移动至容器，容器按照序列移动给某对象的数据成员，最后这个对象会被销毁(带动<em>std::unique_ptr</em>销毁以及<em>std::unique_ptr</em>指向的对象销毁)。在这个交接过程中，如果出现非典型程序分支或者异常，使用裸指针带来非常高的资源管理成本，而使用<em>std::unique_ptr</em>就没有这个问题。</p>
<h2 id="use-custom-deleters"><a class="header" href="#use-custom-deleters">Use Custom <em>deleters</em></a></h2>
<p>通常，对象的销毁通过<em>delete</em>实现，但<em>std::unique_ptr</em>可以在构造时配置自定义的<em>deleter</em>。比如在对象被销毁之前，需要将对象信息记录进日志：</p>
<pre><code>auto delInvmt = [](Investment* pInvestment) {
    makeLog(pInvestment);
    delete pInvestment;
};

template&lt;typename... Targs&gt;
std::unique_ptr&lt;Investment, decltype(delInvmt)&gt;
makeInvestment(Targs&amp;&amp;... params) {
    std::unique_ptr&lt;Investment, decltype(delInvmt)&gt;
        pInv(nullptr, delInvmt);
    if(...){ 
        pInv.reset(new Stock(std::forward&lt;Targs&gt;(params)...));
    } else if(...){
        pInv.reset(new Bond(std::forward&lt;Targs&gt;(params)...));
    } else if(...){
        pInv.reset(new RealEstate(std::forward&lt;Targs&gt;(params)...));
    }
    return pInv;
}
</code></pre>
<p>以上程序有以下几个注意点：</p>
<ul>
<li>delInvmt是一个自定义的<em>deleter</em>。</li>
<li><em>std::unique_ptr</em>的第二个模板参数是<em>deleter</em>的类型。</li>
<li>将裸指针赋予<em>std::unique_ptr</em>是非法的。只可以通过初始化或者reset设置智能指针的内含指针。</li>
<li>使用完美转发传递参数。</li>
</ul>
<p>在C++14中，可以实现函数的返回值自动推断(Item3),可以实现更加优雅的表达：</p>
<pre><code>template&lt;typename... Targs&gt;
auto makeInvestment(Targs&amp;&amp;... params) {
    auto delInvmt = [](Investment* pInvestment) {
        makeLog(pInvestment);
        delete pInvestment;
    };
    std::unique_ptr&lt;Investment, decltype(delInvmt)&gt;
        pInv(nullptr, delInvmt);
    ...
    return pInv;
}
</code></pre>
<p>默认的<em>std::unique_ptr</em>使用<em>delete</em>作为<em>deleter</em>，这种情况下，<em>std::unique_ptr</em>和裸指针有同样的大小。当使用了自定义的<em>deleter</em>后，<em>std::unique_ptr</em>将会变大(两倍)。当使用<em>function</em>作为<em>deleter</em>时，<em>std::unique_ptr</em>将会多存储一个函数指针；而当使用<em>function object</em>时，膨胀将取决于对象；使用<em>stateless function object</em>时(E.g. 无捕获的lambda表达式)，不会有膨胀。所以相同的功能，使用<em>stateless function object</em>空间表现更好:</p>
<pre><code>auto delInvmt = [](Investment* pInvestment) {
    makeLog(pInvestment);
    delete pInvestment;
};
template&lt;typename... Targs&gt;
std::unique_ptr&lt;Investment, decltype(delInvmt1)&gt;    // Return type has sizeof(Investment*).
makeInvestment(Targs... args);

void delInvmt2(Investment* pInvestment) {
    makeLog(pInvestment);
    delete pInvestment;       
}
template&lt;typename... Targs&gt;
std::unique_ptr&lt;Investment, void(*)(Investment*)&gt;   // Return type has sizeof(Investment*)+sizeof(void(*)(Investment*)).
makeInvestment(Targs... args);
</code></pre>
<p><em>std::unique_ptr</em>还可以用于Pimpl(编译防火墙)的实现，见Item22。</p>
<h2 id="tips-of-stdunique_ptr"><a class="header" href="#tips-of-stdunique_ptr">Tips of <em>std::unique_ptr</em></a></h2>
<p><em>std::unique_ptr</em>拥有一个用于数组的特化类型：<em>std::unique_ptr&lt;T[]&gt;</em>,所以可以清楚的区分出一个<em>std::unique_ptr</em>是指向数组还是对象，防止API的混用：指向对象的<em>std::unique_ptr</em>没有下标访问操作(operator[])，数组则没有解除引用的操作(operator*和operator-&gt;)。</p>
<p>但通常容器类(<em>std::array</em> <em>std::vector</em>)是替代原生数组更好的方案。</p>
<p><em>std::unique_ptr</em>表达了<em>exclusive ownership</em>的语义，这可能局限了它的使用范围。但C++11提供更加实用和高效的方法，即<em>std::unique_ptr</em>可以转化为<em>std::shared_ptr</em>：</p>
<pre><code>std::shared_ptr&lt;Investment&gt; sp = makeInvestment(...);   // Converts std::unique_ptr to std::shared_ptr
</code></pre>
<p>所以<em>std::unique_ptr</em>十分适合用于工厂函数的返回值，因为工厂函数不管其生产的对象是共用的还是独有的。这样的转换使得<em>std::unique_ptr</em>的使用更加灵活。</p>
<h2 id="things-to-remember-15"><a class="header" href="#things-to-remember-15">Things to Remember</a></h2>
<ul>
<li><em>std::unique_ptr</em>是一个小型的、快速的、move-only的智能指针，用于<em>exclusive ownership</em>的对象的资源管理。</li>
<li>默认，<em>std::unique_ptr</em>使用<em>delete</em>作为<em>deleter</em>，<em>deleter</em>可以自定义；同时<em>stateful deleter</em>和<em>function pointer</em>会提高<em>std::unique_ptr</em>的大小，<em>stateless deleter</em>则不。</li>
<li><em>std::unique_ptr</em>可以转化为<em>std::shared_ptr</em></li>
</ul>
<h1 id="item19-use-shared_ptr-for-shared-ownership-resource-management"><a class="header" href="#item19-use-shared_ptr-for-shared-ownership-resource-management">Item19: Use <em>shared_ptr</em> for Shared-ownership Resource Management</a></h1>
<p>C++原始的手动生命周期管理(RAII)可以严格的控制变量的生命周期与资源管理。然而垃圾回收(garbage collection)机制是十分方便而且诱人的。<em>std::share_ptr</em>正是为了同时享受GC带来的方便与资源的可预测控制而设计的。</p>
<p><em>std::share_ptr</em>表达的是<em>shared-ownership</em>语义，即多个指针共享同一个对象，协同处理对象的销毁。使用GC机制，使得用户端不再需要手动管理对象的生命周期及资源的释放，同时保证了销毁的确定性和可预测性。</p>
<h2 id="reference-count"><a class="header" href="#reference-count">Reference Count</a></h2>
<p><em>std::share_ptr</em>使用<em>reference count</em>引用计数的方式，追踪管理对象的指针数量。当一个<em>std::share_ptr</em>被构造(除了移动构造)为指向某个对象，引用计数增加；当一个<em>std::share_ptr</em>被析构，引用计数减少；还有拷贝控制，也对引用计数产生影响。</p>
<p>移动操作使得旧<em>std::share_ptr</em>为空指针，不影响引用计数，所以移动操作比拷贝操作更加高效，包含构造、赋值的情形。</p>
<p>引用计数对<em>std::share_ptr</em>的性能有一定的影响：</p>
<ul>
<li><em>std::share_ptr</em>比裸指针大一倍，因为增加了一个指向引用计数的指针。</li>
<li>为了多个指针能够访问引用计数，引用计数被动态创建在堆上。因为指向的对象无法储存这个计数。Item21中会解释使用<em>std::make_shared</em>来避免动态分配对性能的影响。</li>
<li>增加和减少引用计数的操作必须为原子操作。因为不同线程中，对引用计数的读和写有可能同时发生。因为原子操作比非原子操作更慢，所以<em>std::share_ptr</em>一般比裸指针性能要差。</li>
</ul>
<h2 id="stdshare_ptrs-control-block"><a class="header" href="#stdshare_ptrs-control-block"><em>std::share_ptr</em>'s <em>Control Block</em></a></h2>
<p><em>std::share_ptr</em>默认采用<em>delete</em>作为<em>deleter</em>，但也支持自定义的<em>deleter</em>。但是与<em>std::unique_ptr</em>的设计不同，<em>deleter</em>的类型是<em>std::unique_ptr</em>类型的一部分，而<em>std::shared_ptr</em>不同：</p>
<pre><code>auto logingDel = [](Widget* pw) {
    makeLogEntry(pw);
    delete pw;  
};

std::unique_ptr&lt;Widget, decltype(logingDel)&gt; upw(new Widget, loggingDel);       // deleter type is part of ptr type.

std::shared_ptr&lt;Widget&gt; spw(new Widget, logingDel);     // deleter type is not part of ptr type.
</code></pre>
<p><em>std::shared_ptr</em>的设计更加灵活，考虑到两个<em>std::shared_ptr</em>可以拥有各自的自定义<em>deleter</em>:</p>
<pre><code>auto customDeleter1 = [](Widget* pw){...};
auto customDeleter2 = [](Widget* pw){...};

std::shared_ptr&lt;Widget&gt; pw1(new Widget, customDeleter1);
std::shared_ptr&lt;Widget&gt; pw2(new Widget, customDeleter2);
</code></pre>
<p>因为两个<em>std::shared_ptr</em>具有相同的类型，那么它们就可以放进同一个容器：</p>
<pre><code>std::vector&lt;std::shared_ptr&lt;Widget&gt;&gt; vpw{ pw1, pw2 };
</code></pre>
<p>同样的，就可以对具有不同的<em>deleter</em>但指向对象相同的两个<em>std::shared_ptr</em>进行赋值操作。</p>
<p>另一个不同点在于，使用自定义<em>deleter</em>并不会影响<em>std::shared_ptr</em>的大小，它始终包含两个指针。这意味这不论<em>deleter</em>有多大，都不影响<em>std::shared_ptr</em>的大小，因为<em>deleter</em>是被动态分配的(可能就在堆上，取决于allocator)。</p>
<p>其实<em>std::shared_ptr</em>包含有两个指针，其中一个指向目标对象，另一个指向的不仅仅是引用计数，而是一块控制块(control block)。这个控制块中包含了Reference count、Weak count、Other Data(e.g. custom deleter if specified, allocator if specified...)。Control Block的具体实现可能涉及虚函数和继承。</p>
<p>控制块在第一个<em>std::shared_ptr</em>构造时创建。一般来说，构造<em>std::shared_ptr</em>指向一个对象，构造函数无法获知这个对象是否已经被其他指针指向，所以对控制块有以下约定：</p>
<ul>
<li><em>std::make_shared</em>总是创建控制块。</li>
<li>当一个<em>std::shared_ptr</em>通过<em>std::unique_ptr</em>来构造时，总是创建控制块。</li>
<li>当一个<em>std::shared_ptr</em>通过一个裸指针来构造时，总是创建控制块。</li>
</ul>
<p>当希望构造<em>std::shared_ptr</em>不会产生新的控制块时，使用<em>std::shared_ptr</em>或者<em>std::weak_ptr</em>作为构造函数的参数。使用<em>std::shared_ptr</em>的原则就是一个对象只有一个control block，一个对象对应多个control block将会反复销毁一个对象，导致未定义行为。</p>
<p>因此最好不要尝试使用裸指针初始化<em>std::shared_ptr</em>，使用<em>std::make_shared</em>替代(见Item21)，当使用自定义<em>deleter</em>时，无法使用<em>std::make_shared</em>，使用new直接替代，以防止产生裸指针。</p>
<p>一个十分容易使用裸指针去初始化<em>std::shared_ptr</em>的场景就是使用this指针初始化智能指针：</p>
<pre><code>std::vector&lt;std::shared_ptr&lt;Widget&gt;&gt; processedWidgets;  // processedWidgets keep track of Widgets.

class Widget {
public:
    ...
    void process() {
        ...
        processedWidgets.emplace_back(this);    // Lead to 'raw pointer constructor'.
    }
    ...
}
</code></pre>
<p>这段代码可以通过编译，并且将this指针传入<em>std::shared_ptr</em>的构造函数，导致但对象多控制块，最终导致未定义行为。为了解决这个问题，引入<em>std::enable_shared_from_this</em>：</p>
<pre><code>class Widget : public std::enable_shared_from_this&lt;Widget&gt; {
public:
    ...
    void process() {
        ...
        processedWidgets.emplace_back(shared_from_this());
    }
    ...
};
</code></pre>
<p><em>std::enable_shared_from_this</em>是一个基类模板，它提供一个<em>shared_from_this</em>的方法，能够返回包装了this的<em>std::shared_ptr</em>，从而避免裸指针this初始化<em>std::shared_ptr</em>。</p>
<p>这样的设计样式称作<em>The Curiously Recurring Template Pattern(CRTP)</em>，即奇异递归模板样式。即通过使基类的模板参数包含了继承类型的信息，使得基类成员函数能够实现普通OO不能实现的功能。</p>
<p>在C++17中，<em>std::enable_shared_from_this</em>中包含了一个<em>std::weak_ptr</em>用于追踪和记录控制块。在使用<em>shared_from_this</em>获得指针之前，需要确保控制块已经存在。所以<em>std::weak_ptr</em>必须在调用<em>shared_from_this</em>之前记录控制块。</p>
<h2 id="about-stdshared_ptr"><a class="header" href="#about-stdshared_ptr">About <em>std::shared_ptr</em></a></h2>
<p><em>std::shared_ptr</em>涉及到动态分配控制块、可能大的<em>deleter</em>和空间分配器、虚函数机制、原子操作，所以在性能上和裸指针有着较大的差距，因为不存在没有完美的解决资源管理的方案。</p>
<p>在普通场景中，<em>std::shared_ptr</em>使用默认的<em>deleter</em>和<em>allocator</em>以及使用<em>std::make_shared</em>，控制块只有3个字的大小，性能依旧良好；常用操作比如解除引用的开销不比裸指针大；涉及引用计数改变的操作可能包含了1到2个原子操作，可能比非原子操作消耗更大，但是对于单个计算机指令，依旧为单指令；还有虚函数机制只发生一次，即对象销毁的时候。</p>
<p>通过以上代价实现了资源管理的自动化，所以使用<em>std::shared_ptr</em>在大多数场景下是合适的；同时在不需要<em>shared—ownership</em>的情况下，使用<em>std::unique_ptr</em>会有更好的表现，而且<em>std::unique_ptr</em>转化为<em>std::shared_ptr</em>也十分方便，但牢记反向转换是不允许的，即使计数值为1.</p>
<p>同时，<em>std::shared_ptr</em>不具备代替原生数组的能力，因为<em>std::shared_ptr</em>所有API都是面向对象实现的，不存在<em>std::shared_ptr&lt;T[]&gt;<em>的特化。注意通过设置包含</em>delete[]<em>的可调用对象作为</em>deleter</em>，将<em>std::shared_ptr</em>指向原生数组可以通过编译，但这并不是一个好主意：一方面，<em>std::shared_ptr</em>不提供下标访问，只能通过指针算术来实现访问；另一方面，<em>std::shared_ptr</em>保持继承类-基类指针转化，对于数组来说这样的操作是未知的。使用容器类替代数组是更好的方案。</p>
<h2 id="things-to-remember-16"><a class="header" href="#things-to-remember-16">Things to Remember</a></h2>
<ul>
<li><em>std::shared_ptr</em>提供了GC机制，用于管理资源和变量的生命周期。</li>
<li><em>std::shared_ptr</em>比<em>std::unique_ptr</em>更大，包含了控制块，要求原子性的引用计数操作。</li>
<li>默认析构操作采用<em>delete</em>，支持自定义<em>deleter</em>。<em>deleter</em>的类型不影响<em>std::shared_ptr</em>的类型。</li>
<li>尽量避免使用裸指针初始化<em>std::shared_ptr</em>。</li>
</ul>
<h1 id="item20-use-stdweak_ptr-for-stdshared_ptr-like-pointers-that-can-dangle"><a class="header" href="#item20-use-stdweak_ptr-for-stdshared_ptr-like-pointers-that-can-dangle">Item20: Use <em>std::weak_ptr</em> for <em>std::shared_ptr</em> Like Pointers That Can Dangle</a></h1>
<p>实现一个行为和<em>std::shared_ptr</em>相似，但不参加<em>shared—ownership</em>的智能指针在某些场景是很方便的，即这个指针不会影响引用计数。这种指针存在一个<em>std::shared_ptr</em>不存在的问题，就是指针悬空。一个真正的智能指针需要跟踪指针是否悬空，<em>std::weak_ptr</em>就是为了这个问题而实现的。</p>
<h2 id="about-stdweak_ptr"><a class="header" href="#about-stdweak_ptr">About <em>std::weak_ptr</em></a></h2>
<p><em>std::weak_ptr</em>的API很奇特，甚至不像一个指针：不能解除引用、不能进行指针运算、不能比较，<em>std::weak_ptr</em>更向是<em>std::shared_ptr</em>的一个增强。</p>
<p><em>std::weak_ptr</em>往往通过<em>std::shared_ptr</em>构造：</p>
<pre><code>auto spw = std::make_shared&lt;Widget&gt;();  // Create a share_ptr pointing to a Widget. ref_count set 1.
...

std::weak_ptr&lt;Widget&gt; wpw(spw);     // Create a weak_ptr pointting to the same Widget. ref_count is 1.

spw = nullptr;  // ref_count is 0. Widget is destroyed.

if(wpw.expired()) ...   // wpw is dangled.
</code></pre>
<p>我们可能希望检测一个<em>std::weak_ptr</em>是否为空，然后解除引用，但是<em>std::weak_ptr</em>没有解除引用操作。即使这里存在解除引用操作，但在检查与引用的操作间隔，另一个线程可能恰好销毁了对象，导致访问未定义行为。</p>
<p>因此在这里需要一个原子操作，使得检查和解除引用一气呵成。这可以通过使用<em>std::weak_ptr</em>构造一个<em>std::shared_ptr</em>实现：</p>
<pre><code>std::shared_ptr&lt;Widget&gt; spw1 = wpw.lock();  // If wpw dangles, spw1 is nullptr.

auto spw2 = wpw.lock();

std::shared_ptr&lt;Widget&gt; spw3(wpw);  // If wpw dangles，throw exception(std::bad_weak_ptr).
</code></pre>
<p>使用lock()来实现时，若wpw悬空，则<em>std::shared_ptr</em>为空指针；使用<em>std::shared_ptr</em>的构造函数实现时，若wpw悬空，则抛出异常<em>std::bad_weak_ptr</em>。</p>
<h2 id="how-can-stdweak_ptr-be-useful"><a class="header" href="#how-can-stdweak_ptr-be-useful">How can <em>std::weak_ptr</em> be Useful</a></h2>
<p>见如下函数：</p>
<pre><code>std::unique_ptr&lt;const Widget&gt; loadWidget(WidgetID id);
</code></pre>
<p>如果loadWidget是一个成本很高的call，而且同一个Id可能反复使用的。一个很可靠的优化方式就是缓存其返回值；但对每一个Widget进行阻塞缓存同样影响了性能，所以还可以进一步优化：销毁不再使用的Widget。</p>
<p>这种情形下，使用<em>std::unique_ptr</em>作为返回值不再合适，因为调用者希望获得缓存指针的同时，还可以自行决定缓存的生命周期。这个缓存指针需要报告指针是否悬空，因为使用者一旦完成了使用，就会销毁对象，见如下实现：</p>
<pre><code>std::shared_ptr&lt;const Widget&gt; fastLoadWidget(WidgetID id) {
    static std::unordered_map&lt;WidgetID, std::weak_ptr&lt;const　Wdiget&gt;&gt; cache;
    auto objPtr = cache[id].lock();
    if(!objPtr) {
        objPtr = loadWidget(id);
        cache[id] = objPtr;
    }
    return objPtr;
}
</code></pre>
<p>在该实现中，，cache是一个hash表，其中存储了id对应<em>std::weak_ptr</em>:</p>
<ul>
<li>当使用新的id读取时，表中没有id对应的key，构造一个空的<em>std::weak_ptr</em>，
lock()返回一个空<em>std::shared_ptr</em>初始化objPtr，调用loadWidget()获得Widget对象，并将刚构造的<em>std::weak_ptr</em>指向对象，最后返回objPtr；</li>
<li>当使用已经存在的id读取时，lock()返回一个指向对应对象的<em>std::shared_ptr</em>初始化objPtr并返回，大大提高了读取性能。</li>
</ul>
<p>值得注意的是，<em>std::weak_ptr</em>依赖于<em>std::shared_ptr</em>，所以返回值必然为<em>std::shared_ptr</em>。当客户端使用完id对应的最后一个<em>std::shared_ptr</em>，对象被销毁，再次使用该id时，需要重新调用loadWidget，因此依旧有重构空间。</p>
<p>再看另一个设计样式，观察者样式：发布者(subject)是一个会改变状态的对象，观测者(observer)是一个会接收改变通知并刷新通知的对象。通常发布者中包含指向观测者的指针保证能够在状态改变时，更改通知；但发布者不关心观测者的资源问题，只关心观测者是否还存在，以防止访问一个已经不存在的观测者。<em>std::weak_ptr</em>十分契合这样的需求，即发布者可以包含一个元素为指向发布者的<em>std::weak_ptr</em>的容器。</p>
<p>最后一个例子：如果存在A,B,C三个对象，A和C共享B(即AC中含有一个<em>std::shared_ptr</em>指向B)；B中也要含有一个指针指向A，那这个指针有如下几种选择：</p>
<ul>
<li>裸指针：如果A被析构了，而C存在，B依旧存在，但是该裸指针无从知道A是否已经析构，对该指针的解除引用将导致未定义行为。</li>
<li><em>std::shared_ptr</em>：在这个设计下，AB分别持有对方，即存在循环指针(A to B to A to B)，导致A和B都无法被析构(引用计数至少为1)，必然导致内存泄漏，</li>
<li><em>std::weak_ptr</em>：可以防止以上的问题，如果A被析构，B中的指针将会悬空，B可以检测到；A，B也可成功的依次析构，因为<em>std::weak_ptr</em>不影响引用计数。</li>
</ul>
<p>这种应用场景其实并不普遍。比如，一些严格层次的数据结构(树...)。子节点通常只被父节点持有，因此父节点中的指向子节点指针可以使用<em>std::unique_ptr</em>，而子节点中指向父节点的指针可以直接使用裸指针(因为父节点的生命周期总是比子节点更加长)。</p>
<p><em>std::weak_ptr</em>和<em>std::shared_ptr</em>性能相似，都使用一样的控制块，涉及原子操作。值得注意的是:<em>std::weak_ptr</em>不影响<em>shared ownership</em>的引用计数，但是影响<em>weak count</em>，详见Item21。</p>
<h2 id="things-to-remember-17"><a class="header" href="#things-to-remember-17">Things to Remember</a></h2>
<ul>
<li>使用<em>std::weak_ptr</em>，当指针表现为可悬空的情况下。</li>
<li><em>std::weak_ptr</em>常用在缓存、观察者列表、防止<em>shared_ptr</em>循环导致无法析构的错误。</li>
</ul>
<h1 id="item21-prefer-stdmake_unique-and-stdmake_shared-to-direct-use-of-new"><a class="header" href="#item21-prefer-stdmake_unique-and-stdmake_shared-to-direct-use-of-new">Item21: Prefer <em>std::make_unique</em> and <em>std::make_shared</em> to Direct Use of <em>new</em></a></h1>
<p><em>std::make_shared</em>和<em>std::make_unique</em>是三个<em>make</em>函数之二，还有一个函数是<em>std::allocate_shared</em>。<em>make</em>函数的作用是接收参数包，完美转发参数包给对象的构造函数用于动态内存申请，并且返回指向该对象的智能指针。<em>std::allocate_shared</em>工作与<em>std::make_shared</em>类似，但额外接收一个空间适配器用于分配动态空间。</p>
<h2 id="make-perform-better-when-writting-exception-safe-code"><a class="header" href="#make-perform-better-when-writting-exception-safe-code"><em>make</em> Perform Better When Writting Exception-Safe Code</a></h2>
<p>使用<em>make</em>比不使用<em>make</em>在构造智能指针时不同：</p>
<pre><code>auto upw1(std::make_unique&lt;Widget&gt;());      // With make.
std::unique_ptr&lt;Widget&gt; uwp2(new Widget);   // Without make.

auto spw1(std::make_shared&lt;Widget&gt;());      // With make.
std::shared_ptr&lt;Widget&gt; spw2(new Widget);   // Without make.
</code></pre>
<p>首先，使用new的方式需要重复对象的类型，make方式则不：源文件中重复类型导致编译成本提高，可能导致目标代码膨胀和代码不一致，同时也提高了拼写成本。第二个原因，<em>make</em>异常安全，而new不是，见下：</p>
<pre><code>void processWidget(std::shared_ptr&lt;Widget&gt; spw, int priority);

int computePriority();

processWidget(std::shared_ptr&lt;Widget&gt;(new Widget), computePriority());      // Potential resource leak.
</code></pre>
<p>当编译器将上述代码编译为目标代码：运行时，函数的调用必须要在函数参数评估完成后进行，所以在调用processWidget之前，下述操作必然已经发生：</p>
<ul>
<li>new Widget已经计算，Widget必然在堆上创建。</li>
<li>shared_ptr<Widget>已经构造完成，并且指向new出的Widget。</li>
<li>computePriority已经调用完毕。</li>
</ul>
<p>然而编译器并没有被要求依次进行上述操作，于是有可能发生下面的情况：&quot;new Widget&quot;的调用必须在shared_ptr<Widget>构造前进行；但是computePriority可以发生在两件事情的中间，之后或者之前:</p>
<ul>
<li>进行&quot;new Widget&quot;</li>
<li>进行computePriority</li>
<li>进行shared_ptr<Widget>的构造</li>
</ul>
<p>这样的目标代码显然不是异常安全的，一旦computePriority抛出异常，&quot;new Widget&quot;必然泄漏，因为shared_ptr<Widget>还没有构造出来去接管这个对象。但是使用<em>make</em>是异常安全的:</p>
<pre><code>processWidget(std::make_shared&lt;Widget&gt;(), computePriority());      // Exception safe.
</code></pre>
<p>运行时，不论两个函数那个先运行，都是异常安全的。当computePriority先行，并抛出异常，对象尚未构造；当computePriority后运行，新对象始终被一个智能指针所接管。因此<em>make</em>函数在异常安全方面比&quot;new&quot;的表现更好。</p>
<h2 id="stdmake_shared-is-more-efficient"><a class="header" href="#stdmake_shared-is-more-efficient"><em>std::make_shared</em> is More Efficient</a></h2>
<p>使用<em>std::make_shared</em>使得编译器能够产生更小更快的代码：</p>
<pre><code>std::shared_ptr&lt;Widget&gt; spw(new Widget);
</code></pre>
<p>该代码看上去进行了一次内存申请，其实进行了两次，因为<em>shared_ptr</em>额外需要一个控制块的申请；该申请会在构造函数中进行，所以直接使用&quot;new&quot;会进行两次内存申请，一个供给对象，一个供给控制块。</p>
<pre><code>auto spw = std::make_shared&lt;Widget&gt;();
</code></pre>
<p>如果使用<em>std::make_shared</em>，则只需要一次申请：这是因为<em>std::make_shared</em>直接申请了一块内存块，储存对象和控制块，提高了运行代码的速度。对<em>std::make_shared</em>的效率分析，同样适用与<em>std::allocate_shared</em>。</p>
<h2 id="circumstances-where-make-shouldnot-be-used"><a class="header" href="#circumstances-where-make-shouldnot-be-used">Circumstances Where <em>make</em> Shouldnot be Used</a></h2>
<ul>
<li><em>make</em>函数不能用于声明自定义<em>deleter</em></li>
<li><em>make</em>函数不能用于<em>braced—initializer</em></li>
</ul>
<p>如下代码，调用的是非initializer_list版本的构造函数：</p>
<pre><code>auto upv = std::make_shared&lt;std::vector&lt;int&gt;&gt;(10, 20);
auto spv = std::make_unique&lt;std::vector&lt;int&gt;&gt;(10, 20);
</code></pre>
<p>当使用<em>braced-initialzation</em>必须使用&quot;new&quot;，而不能使用<em>make</em>，除了直接调用<em>initializer</em>版本的构造函数：</p>
<pre><code>auto inilist = { 10, 20 };
auto spv = std::make_shared&lt;std::vector&lt;int&gt;&gt;(inilist);
</code></pre>
<p>以上两个场景就是对<em>std::unique_ptr</em>的限制，而对于<em>std::shared_ptr</em>还有更多限制。</p>
<p>有些类会重载它们的<em>operator new</em>和<em>operator delete</em>，那么全局的内存分配以及释放机制对这些类将不再适合。这个重载的实现往往只会申请一块对象大小的内存，只管理对象所需要的资源，而这样的实现是不适合std::shared_ptr的，因为申请的内存还要包含控制块的大小。所以<em>std::make_shared</em>使用类自定义的<em>operator new</em>和<em>operator delete</em>不是一个好主意。</p>
<p><em>std::make_shared</em>将对象的控制块放在同一块内存中，当引用计数归零，对象被析构，但是内存块并没有被释放，因为控制块还没有被析构。控制块中包含了引用计数等等信息，在引用计数归零后，控制块不一定就被销毁，因为控制块还有其他的登记记录，即第二个计数<em>weak count</em>,这个计数中记录了多少个<em>std::weak_ptr</em>指向这个内存块。因为<em>std::weak_ptr</em>需要通过查询控制块的<em>reference count</em>来知道自己是否悬空，所以只要有<em>std::weak_ptr</em>指向控制块，那么控制块就不能被析构，控制块所在的内存块就不能被释放。</p>
<p>如果对象本身是十分巨大的，而且最后一个<em>std::shared_ptr</em>和最后一个<em>std::weak_ptr</em>的析构的时间差也很明显，那么对象析构以及内存释放之间就会存在滞后：</p>
<pre><code>class ReallyBigType {...};

auto pBigObj = std::make_shared&lt;ReallyBigType&gt;();
... // Create std::weak_ptr and std::shared_ptr to obj.
... // final std::shared_ptr to obj and obj destroyed here.
    // but std::weak_ptr to it remain.
... // during this period, memory formerly occupied by large
    // obj remains allocate.
... // final std::weak_ptr to it desturyed here.
    // memory for control block and obj is freed.
</code></pre>
<p>但如果使用&quot;new&quot;，就不会存在这样的滞后，因为控制块和对象的内存块是分开的：</p>
<pre><code>std::shared_ptr&lt;ReallyBigType&gt; pBigObj(new ReallyBigType());
... // Create std::weak_ptr and std::shared_ptr to obj.
... // final std::shared_ptr to obj destroyed here.
    // obj is destoryed and memory for obj is freed.
    // but std::weak_ptr to it remain.
... // during this period, memory formerly occupied by large
    // obj remains allocate.
... // final std::weak_ptr to it desturyed here.
    // memory for control block is freed.
</code></pre>
<p>当然为了异常安全，在使用&quot;new&quot;直接生成智能指针，务必保证new出的裸指针马上被传给智能指针的构造函数，即该语句中不要再做其他事情来防止编译器产生顺序不合适的代码:</p>
<pre><code>void processWidget(std::shared_ptr&lt;Widget&gt; spw, int priority);

void cusDel(Widget* ptr);

processWidget(std::shared_ptr&lt;Widget&gt;(new Widget,cusDel), computePriority());     // Exception unsafe.

std::shared_ptr&lt;Widget&gt; spw(new Widget, cusDel);
processWidget(spw, computePriority())      // Safe. but not optimal.
</code></pre>
<p>将构造放在单独的一条语句中，可以避免异常不安全。即使构造函数抛出异常(比如控制块的申请出现异常)，可以保证cusDel用于析构对象，并且释放内存。</p>
<p>但是从性能影响上看，内存不安全版本更好，因为其传入构造的是一个右值，而异常安全版本是一个左值。右值构造使用的是move，而左值进行的是copy；而copy一个<em>std::shared_ptr</em>要求原子操作的引用增加，削弱性能表现。</p>
<pre><code>processWidget(std::move(spw), computePriority());   // both efficient and exception safe.
</code></pre>
<p>使用std::move可以兼顾性能与异常安全，但是原指针将被设置为空指针。</p>
<h2 id="things-to-remember-18"><a class="header" href="#things-to-remember-18">Things to Remember</a></h2>
<ul>
<li>对比&quot;new&quot;，<em>make</em>函数减少代码膨胀，加强异常安全，<em>make_shared</em>和<em>allocate_shared</em>还有更好的性能表现和更小的代码。</li>
<li>不使用<em>make</em>的情形：需要使用自定义<em>deleter</em>或者<em>braced-initializer</em>。</li>
<li>对于<em>std::shared_ptr</em>，不使用<em>make</em>的情景还有：对象具有自定义的内存管理机制、(出于内存空间的考虑)对于非常大的类型同时<em>std::shared_ptr</em>和<em>std_weak_ptr</em>析构时间差很大的情况。</li>
</ul>
<h1 id="item22-when-using-the-pimpl-idiom-difine-special-member-functions-in-the-implementation-file"><a class="header" href="#item22-when-using-the-pimpl-idiom-difine-special-member-functions-in-the-implementation-file">Item22: When Using the <em>Pimpl</em> Idiom, Difine Special Member Functions in the Implementation File</a></h1>
<h2 id="the-pimpl-idiom"><a class="header" href="#the-pimpl-idiom">the <em>Pimpl</em> Idiom</a></h2>
<p><em>Pimpl</em>(pointer to implementation)是一门用于减少编译成本的技术：</p>
<pre><code>class Widget {          // In header &quot;Widget.h&quot;
public:
    Widget();
    ...
private:
    std::string name;
    Gadget g;           // User-defined type.
}
</code></pre>
<p>Widget是一个拥有std::string, Gadget类型成员变量的类，定义在&quot;Widget.h&quot;中；任何需要调用Widget的源代码都需要包含这个头文件，在包含这个头文件的同时也就包含了声明Gadget的头文件，如果&quot;Gadget.h&quot;是一个经常改变内容的头文件，那么就大大增加了编译成本。</p>
<pre><code>class Widget {          // In header &quot;Widget.h&quot;.
public:
    Widget();
    ~Widget();
    ...
private：
    struct Impl;        // Declare implementation struct.
    Impl *pImpl;        // and pointer to it.
}
</code></pre>
<p>使用Pimpl，将数据成员封装进一个声明了的结构体(不定义)中，再用指针指向这个结构体。因为&quot;Widget.h&quot;中没有使用这些类型，所以就不用包含这些头文件，对这些头文件做修改不影响包含&quot;Widget.h&quot;的源代码，提高了编译效率。</p>
<p>但注意Impl是一个只声明而未定义的类型(<em>incomplete type</em>)，只有少数对它的行为是合法的，比如声明指向它的指针。以上代码只完成了声明，之后需要进行定义：</p>
<pre><code>#include &quot;Widget.h&quot;     // In impl. file &quot;Widget.cpp&quot;.
#include &quot;Gadget.h&quot;
#include &lt;string&gt;

struct Widget::Impl {   // Define Impl.
    std::string name;
    Gadget g;
};

Widget::Widget() : pImpl(new Impl)
{}

Widget::~Widget() {
    delete pImpl;
}
</code></pre>
<p>通过<em>Pimpl</em>，分离了头文件&quot;Widget.h&quot;对于&quot;Gadget.h&quot;的依赖。于是当Gadget.h的内容发生变化时，只需要重新编译&quot;Widget.cpp&quot;，而不需要重新编译其它包含&quot;Widget.h&quot;的用户源代码，提高了编译期间的效率。</p>
<h2 id="use-stdunique_ptr-instead-of-raw-pointer"><a class="header" href="#use-stdunique_ptr-instead-of-raw-pointer">Use <em>std::unique_ptr</em> instead of raw pointer</a></h2>
<p>在<em>Pimpl</em>中，使用智能指针<em>std::unique_ptr</em>替代裸指针会产生一个编译错误<em>cannot delete an incomplete type</em>：</p>
<pre><code>class Widget {          // In header &quot;Widget.h&quot;.
public:
    Widget();
    ...
private：
    struct Impl;        // Declare implementation struct.
    std::unique_ptr&lt;Impl&gt; pImpl;        // and *std::unique_ptr* to it.
}
</code></pre>
<p>然后定义：</p>
<pre><code>#include &quot;Widget.h&quot;     // In impl. file &quot;Widget.cpp&quot;.
#include &quot;Gadget.h&quot;
#include &lt;string&gt;

struct Widget::Impl {   // Define Impl.
    std::string name;
    Gadget g;
};

Widget::Widget() : pImpl(std::make_unique&lt;Impl&gt;()){}    // Create std::unique_ptr.
</code></pre>
<p>因为<em>std::unique_ptr</em>可以自动管理资源，所以我们理应可以不再自行定义析构函数，而交给编译器自行实现，这是没有问题的，问题在于在哪实现。我们无法对一个<em>incomplete type</em>的变量进行如<em>delete</em>和<em>sizeof</em>之类的操作，编译错误意味着生成析构函数参与编译的位置处Impl还没有被定义。</p>
<p>对编译错误信息层层查看可以发现：编译器默认生成的析构函数时内联的，内联位置Impl还没有被定义，而析构函数调用<em>std::unique_ptr</em>的析构，<em>std::unique_ptr</em>的析构又会对Impl进行默认的<em>delete</em>，最后static_assert进行对象是否为<em>imcomplete type</em>的判断时出现了fail。</p>
<p>解决这个问题只要对析构函数进行显示的定义即可：</p>
<pre><code>class Widget {          // In header &quot;Widget.h&quot;.
public:
    Widget();
    ~Widget();          // Declare destructor.
    ...
private：
    struct Impl;        // Declare implementation struct.
    std::unique_ptr&lt;Impl&gt; pImpl;        // and *std::unique_ptr* to it.
}
</code></pre>
<p>然后定义：</p>
<pre><code>#include &quot;Widget.h&quot;     // In impl. file &quot;Widget.cpp&quot;.
#include &quot;Gadget.h&quot;
#include &lt;string&gt;

struct Widget::Impl {   // Define Impl.
    std::string name;
    Gadget g;
};

Widget::Widget() : pImpl(std::make_unique&lt;Impl&gt;()){}    // Create std::unique_ptr.

Widget::~Widget() = default;    // Default destructor.
</code></pre>
<p>因为显式定义了析构函数，所以move操作都不会被编译器生成；所以如果需要支持move操作，需要显式定义：</p>
<pre><code>class Widget {          // In header &quot;Widget.h&quot;.
public:
    Widget();
    ~Widget();          // Declare destructor.
    
    Widget(Widget&amp;&amp; rhs) = default;     // Wrong.
    Widget&amp; operator=(Widget&amp;&amp; rhs) = default;  // Wrong.
    ...
private：
    struct Impl;        // Declare implementation struct.
    std::unique_ptr&lt;Impl&gt; pImpl;        // and *std::unique_ptr* to it.
}
</code></pre>
<p>移动赋值函数需要销毁当前对象持有的Impl；移动构造函数默认生成的异常处理中包含了对Impl的销毁，因此上述代码不能够通过编译，处理方法同析构函数：</p>
<pre><code>class Widget {          // In header &quot;Widget.h&quot;.
public:
    Widget();
    ~Widget();          // Declare destructor.
    
    Widget(Widget&amp;&amp; rhs);
    Widget&amp; operator=(Widget&amp;&amp; rhs);
    ...
private：
    struct Impl;        // Declare implementation struct.
    std::unique_ptr&lt;Impl&gt; pImpl;        // and *std::unique_ptr* to it.
}
</code></pre>
<p>然后定义：</p>
<pre><code>#include &quot;Widget.h&quot;     // In impl. file &quot;Widget.cpp&quot;.
#include &quot;Gadget.h&quot;
#include &lt;string&gt;

struct Widget::Impl {   // Define Impl.
    std::string name;
    Gadget g;
};

Widget::Widget() : pImpl(std::make_unique&lt;Impl&gt;()){}    // Create std::unique_ptr.

Widget::~Widget() = default;    // Default destructor.
Widget::Widget(Widget&amp;&amp; rhs) = default;
Widget&amp; Widget::operator=(Widget&amp;&amp; rhs) = default;
</code></pre>
<p>如果Impl中的成员支持copy操作，那么Widget也可以支持copy操作：1、因为编译器无法自行实现包含<em>move-only</em>类型成员的类的copy操作，2、即使编译器能够实现，也只能进行浅层拷贝，无法进行深层拷贝；所以需要手动实现copy操作：</p>
<pre><code>class Widget {          // In header &quot;Widget.h&quot;.
public:
    Widget();
    ~Widget();          // Declare destructor.
    
    Widget(Widget&amp;&amp; rhs);
    Widget&amp; operator=(Widget&amp;&amp; rhs);
    Widget(const Widget&amp; rhs);
    Widget&amp; operator=(const Widget&amp; rhs);
    ...
private：
    struct Impl;        // Declare implementation struct.
    std::unique_ptr&lt;Impl&gt; pImpl;        // and *std::unique_ptr* to it.
}
</code></pre>
<p>然后定义：</p>
<pre><code>#include &quot;Widget.h&quot;     // In impl. file &quot;Widget.cpp&quot;.
#include &quot;Gadget.h&quot;
#include &lt;string&gt;

struct Widget::Impl {   // Define Impl.
    std::string name;
    Gadget g;
};

Widget::Widget() : pImpl(std::make_unique&lt;Impl&gt;()){}    // Create std::unique_ptr.

Widget::~Widget() = default;    // Default destructor.
Widget::Widget(Widget&amp;&amp; rhs) = default;
Widget&amp; Widget::operator=(Widget&amp;&amp; rhs) = default;

Widget::Widget(const Widget&amp; rhs) : pImpl(nullptr) {
    if(rhs.pImpl) pImpl = std::make_unique&lt;Impl&gt;(*rhs.pImpl);
}
Widget&amp; Widget::operator=(const Widget&amp; rhs) {
    if(!rhs.pImpl) pImpl.reset();
    else if(!pImpl) pImpl = std::make_unique&lt;Impl&gt;(*rhs.pImpl);
    else *pImpl = *rhs.pImpl;
    return *this;
}
</code></pre>
<p>copy操作的定义中需要考虑传入参数的情况、现对象的情况、指针为空的情况。总之，得益于编译器对Impl自动实现的一系列copy操作，使得函数的实现变得十分简单。</p>
<h2 id="when-using-stdshared_ptr"><a class="header" href="#when-using-stdshared_ptr">When using <em>std::shared_ptr</em></a></h2>
<p><em>Pimpl</em>的实现一般使用<em>std::unique_ptr</em>因为其指针逻辑很显然是独占的，但也可以考虑一下使用<em>std::shared_ptr</em>的情况：</p>
<pre><code>class Widget {          // In header &quot;Widget.h&quot;.
public:
    Widget();
    ...
private：
    struct Impl;        // Declare implementation struct.
    std::shared_ptr&lt;Impl&gt; pImpl;        // and *std::unique_ptr* to it.
}
</code></pre>
<p>然后定义：</p>
<pre><code>#include &quot;Widget.h&quot;     // In impl. file &quot;Widget.cpp&quot;.
#include &quot;Gadget.h&quot;
#include &lt;string&gt;

struct Widget::Impl {   // Define Impl.
    std::string name;
    Gadget g;
};

Widget::Widget() : pImpl(std::make_shared&lt;Impl&gt;()){}    // Create std::shared_ptr.
</code></pre>
<p>可以发现使用<em>std::shared_ptr</em>不再有上述繁杂的特殊函数定义，之所以如此：<br />
<em>std::shared_ptr</em>和<em>std::unique_ptr</em>的<em>deleter</em>的实现方式不同，<em>deleter</em>的类型是<em>std::unique_ptr</em>的一部分，所以<em>deleter</em>再编译期就可以连接上<em>std::unique_ptr</em>，这样具有更好的运行期空间时间效率；而<em>std::shared_ptr</em>不同，<em>deleter</em>其实是<em>std::shared_ptr</em>实例的一部分，会有更大的数据结构和运行期成本，但是<em>deleter</em>不必要在编译期就被连接上。</p>
<h2 id="things-to-remember-19"><a class="header" href="#things-to-remember-19">Things to Remember</a></h2>
<ul>
<li><em>Pimpl</em>是一项通过减少编译头文件间(类用户代码和类实现)依赖来降低编译成本的技术。</li>
<li>对于使用<em>std::unique_ptr</em>的<em>Pimpl</em>，需要手动定义类特殊函数来支持实现，尽量使用编译器的默认实现。</li>
<li>对于<em>std::shared_ptr</em>没有上述要求。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="item23-understand-stdmove-and-stdforward"><a class="header" href="#item23-understand-stdmove-and-stdforward">Item23: Understand <em>std::move</em> and <em>std::forward</em></a></h1>
<p>C++11的一大特性就是引入了右值引用(<em>rvalue reference</em>)，移动语义(Move Semantics)与完美转发(Perfect Forwarding)就是由右值引用联结起来的：</p>
<ul>
<li>移动语义(<em>move semantics</em>)：让编译器进行“移动”而不是“拷贝”操作来减少运行成本；同时也可以实现move-only类型。</li>
<li>完美转发(<em>perfect forwarding</em>)：使得函数模板能够“完美”的转发参数给内层函数。</li>
</ul>
<p>但是注意移动语义并不移动、完美转发也并不完美、&quot;type&amp;&amp;&quot;也不代表右值。</p>
<h2 id="stdmove-and-stdforward"><a class="header" href="#stdmove-and-stdforward"><em>std::move</em> and <em>std::forward</em></a></h2>
<p>C++11提供了<em>std::move</em>和<em>std::forward</em>，用于指示<em>move semantics</em>和<em>perfect forwarding</em>。<br />
但是<em>std::move</em>不移动任何东西、<em>std::forward</em>也不转发任何东西，甚至在运行时刻不做任何事情，不产生额外的代码。<em>std::move</em>和<em>std::forward</em>只是一个用于强制转换的函数模板。</p>
<ul>
<li><em>std::move</em>无条件地将参数转换为右值</li>
<li><em>std::forward</em>只在特殊情况下，进行强制转换</li>
</ul>
<h2 id="how-stdmove-works"><a class="header" href="#how-stdmove-works">How <em>std::move</em> Works</a></h2>
<p><em>std::move</em>的C++11实现：</p>
<pre><code>template&lt;typename T&gt;
stuct remove_reference {
    using type = T;
};

template&lt;typename T&gt;
stuct remove_reference&lt;T&amp;&gt; {
    using type = T;
};

template&lt;typename T&gt;
stuct remove_reference&lt;T&amp;&amp;&gt; {
    using type = T;
};

template&lt;typename T&gt;
typename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; param) {
    using Type = typename remove_reference&lt;T&gt;::type&amp;&amp;;
    return static_cast&lt;Type&gt;(param);
}
</code></pre>
<p>从实现可以看出，不论传入参数是右值还是左值(注意万能引用)，<em>std::move</em>通过<em>remove_reference</em>移除引用，然后强制转换得到右值引用作为返回值返回；重要的一点在于当右值引用作为函数值返回时，返回值是一个右值。<br />
C++14可以有更简便的实现：</p>
<pre><code>template&lt;typename T&gt;
decltype(auto) move(T&amp;&amp; param) {
    using Type = remove_reference_t&lt;T&gt;&amp;&amp;;
    return static_cast&lt;Type&gt;(param);
}
</code></pre>
<p><em>std::move</em>其实是指示当前变量希望被进行<em>move</em>操作。<br />
这是一个支持从<em>std::string</em>构造的类，传入参数采用值传递，见Item41。</p>
<pre><code>class Annotation {
public:
    explicit Annotation(std::string text): val(text);
    ...
private:
    std::string val;
}
</code></pre>
<p>当然传入参数应当是不变的：</p>
<pre><code>class Annotation {
public:
    explicit Annotation(const std::string text): val(text) {};
    ...
private:
    std::string val;
}
</code></pre>
<p>然后我们希望能够支持从string中move而不是copy字符串:</p>
<pre><code>class Annotation {
public:
    explicit Annotation(const std::string text): val(std::move(text) {};
    ...
private:
    std::string val;
}
</code></pre>
<p>这看起来没有问题，通过<em>std::move</em>强制转化为右值，调用<em>std::string</em>的移动构造函数，但其实不然：</p>
<p>问题的关键就在于text是一个const变量：</p>
<pre><code>class string {
public:
    ...
    string(const string&amp; rhs);
    string(string&amp;&amp; rhs);
    ...
}
</code></pre>
<p>从<em>std::string</em>的构造函数可以看出，移动构造函数不能接收*const std::string&amp;&amp;*的右值，反而复制构造函数能够接受这样的右值，所以最终进行的是copy而不是move。从该例子可以看出：</p>
<ul>
<li>如果希望使用<em>move operation</em>，就不要将变量声明为const。const的<em>move</em>最终匹配上的是<em>copy</em>。</li>
<li><em>std::move</em>只是进行了强制转换，指示该对象适合进行<em>move</em>，并不代表最终的操作是<em>move</em>。</li>
</ul>
<h2 id="how-stdforward-works"><a class="header" href="#how-stdforward-works">How <em>std::forward</em> Works</a></h2>
<p><em>std::move</em>是无条件的强制转换，而<em>std::forward</em>进行的是有条件的强制转换：</p>
<pre><code>template&lt;typename T&gt;
constexpr T&amp;&amp; forward(typename remove_reference&lt;T&gt;::type&amp; param) {
    // forward an lvalue as either an lvalue or an rvalue
    return static_cast&lt;T&amp;&amp;&gt;(param);
}

tempalte&lt;typename T&gt;
constexpr T&amp;&amp; forward(typename remove_reference&lt;T&gt;::type&amp;&amp; param) {
    // forward an rvalue as an rvalue
    static_assert(!is_lvalue_reference&lt;T&gt;::value, &quot;bad forward call&quot;);
    return static_cast&lt;T&amp;&amp;&gt;(param);
}
</code></pre>
<p>关于参数的完美转发，即有如下函数：</p>
<pre><code>template&lt;class T&gt;
void wrapper(T&amp;&amp; arg) 
{
    // arg is always lvalue
    foo(std::forward&lt;T&gt;(arg)); // Forward as lvalue or as rvalue, depending on T
}
</code></pre>
<p>参数arg的类型可以称作<em>forwarding reference</em>，这是<em>std::forward</em>实现完美转发的前提。
通过一层调用后arg对于内层函数总是一个左值，所以参数的完美转发使用前一个<em>std::forward</em>定义，但是模板参数T包含了原传入参数的信息实现完美转发：</p>
<ul>
<li>当传入参数为rvalue，T总是为非引用类型，返回的将会是T&amp;&amp;，是一个rvalue。</li>
<li>当传入参数为lvalue，T总是为左值引用类型(包含const等限定)，返回的将会是T&amp;，是一个lvalue。</li>
</ul>
<p>如下代码：</p>
<pre><code>void process(const Widget&amp; lval);   // copy
void process(Widget&amp;&amp; rval);        // move

template&lt;typename T&gt;
void UseProcess(T&amp;&amp; param) {
    process(std::forward&lt;T&gt;(param));
}

Widget w;
UseProcess(w);          // use copy version.
UseProcess(std::move(w));   // use move version.
</code></pre>
<h2 id="things-to-remember-20"><a class="header" href="#things-to-remember-20">Things to Remember</a></h2>
<ul>
<li><em>std::move</em>只是将对象无条件强制转换为右值，并没有<em>move</em>。</li>
<li><em>std::forward</em>只是有条件的强制转换对象，并没有<em>forward</em>。</li>
<li><em>std::move</em>和<em>std::forward</em>在运行期没有作用，只是对编译的一种指示。</li>
</ul>
<h1 id="item24-distinguish-universal-references-from-rvalue-references"><a class="header" href="#item24-distinguish-universal-references-from-rvalue-references">Item24: Distinguish Universal References From Rvalue References</a></h1>
<p>在C++中，&quot;&amp;&amp;&quot;是具有迷惑性的：</p>
<pre><code>void f(Widget&amp;&amp; param);
Widget&amp;&amp; var1 = Widget();
template&lt;typename T&gt;
void f(std::vector&lt;T&gt;&amp;&amp; param);

auto&amp;&amp; var2 = var1;
template&lt;typename T&gt;
void f(T&amp;&amp; param);      
</code></pre>
<p>前3个声明，&quot;&amp;&amp;&quot;指代的是右值引用，而后两个并不是，它指代的是左值或者是右值，即万能引用(<em>universal reference</em> or <em>forwarding reference</em>)。它不仅可以绑定rvalue，也可以绑定lvalue；不仅可以绑定const，也可以绑定non-const；不仅可以绑定volatile，也可以绑定non-volatile。</p>
<h2 id="universal-reference-and-template-deduce"><a class="header" href="#universal-reference-and-template-deduce"><em>Universal Reference</em> and Template Deduce</a></h2>
<p><em>Universal Reference</em>主要出现在两种情况，都属于类型推断：<br />
作为函数模板参数时：</p>
<pre><code>template&lt;typename T&gt;
void f(T&amp;&amp; param);
</code></pre>
<p>作为auto推断时:</p>
<pre><code>auto&amp;&amp; var2 = var1;
</code></pre>
<p><em>universal reference</em>的推断结果由initializer决定：当initializer是一个左值时，<em>universal reference</em>就是左值引用；当initializer是右值时，<em>universal reference</em>就是右值引用。</p>
<pre><code>Widget w;
f(w);       // lvalue passed to f; param's type is Widget&amp;.
f(std::move(w));    // rvalue passed to f; param's type is Widget&amp;&amp;.
</code></pre>
<p>万能引用一定是与类型推断相关的，但是存在类型推断并不一定满足万能应用，引用的声明形式也是很重要的：</p>
<pre><code>template&lt;typename T&gt;
void f(std::vector&lt;T&gt;&amp;&amp; param);     // rvalue reference.

std::vector&lt;int&gt; v;
f(v);        // error! cannot bind lvalue to rvalue reference.
</code></pre>
<p>该声明不满足T&amp;&amp;的形式，同时还有：</p>
<pre><code>template&lt;typename T&gt;
void f(const T&amp;&amp; param);        // rvalue reference.
</code></pre>
<p>万能引用适配const和non-const的情况，上述参数声明也不是万能引用。</p>
<pre><code>template&lt;class T, class Allocator = allocator&lt;T&gt;&gt;
class vector {
    ...
    void push_back(T&amp;&amp; x);

    template&lt;class... Args&gt;
    void emplace_back(Args&amp;&amp;... args);
}
</code></pre>
<p>该形式，push_back看上去满足万能引用的形式，但是没有用到类型推断。当定义一个vector：</p>
<pre><code>std::vector&lt;Widget&gt; v;
</code></pre>
<p>类型推断出T为Widget，而push_back对应就有了实现:</p>
<pre><code>void push_bakc(Widget&amp;&amp; x);     // rvalue reference.
</code></pre>
<p>再emplace_back，仍然需要类型推断：</p>
<pre><code>template&lt;class... Args&gt;
void emplace_back(Args&amp;&amp;... args);      // universal reference.
</code></pre>
<p>所以一个满足参数万能引用的函数模板有如下形式：</p>
<pre><code>template&lt;typename T&gt;
void foo(T&amp;&amp; x);        // x is a universal reference.
</code></pre>
<h2 id="universal-reference-and-auto-deduce"><a class="header" href="#universal-reference-and-auto-deduce"><em>Universal Reference</em> and Auto Deduce</a></h2>
<p>auto类型推断也可以实现<em>universal reference</em>。因为auto的推断结果和模板的推断基本上一样，所以auto的<em>universal reference</em>有如下形式：</p>
<pre><code>auto&amp;&amp; ref = exp;
</code></pre>
<p>auto的万能引用不如模板的普遍，但是十分实用，特别是在C++14引入了lambda表达式的auto参数：</p>
<pre><code>auto FuncInvocation = 
    [](auto&amp;&amp; func, auto&amp;&amp;... params) {
        ...
        // Invoke func on params.
        std::forward&lt;decltype(func)&gt;(func)(std::forward&lt;decltype(params)&gt;(params)...);
        ...
    }
</code></pre>
<p>func是<em>universal reference</em>，params是<em>universal reference</em>的一个包；在函数内进行完美转发。</p>
<p>万能引用的背后其实是引用折叠(<em>reference collapsing</em>)机制在起作用，Item28。通过区分<em>rvalue reference</em>和<em>universal reference</em>使得代码更加具有抽象意义，减少定义模糊。</p>
<h2 id="things-to-remember-21"><a class="header" href="#things-to-remember-21">Things to Remember</a></h2>
<ul>
<li><em>universal reference</em>有两种表达形式，分别在模板推断和auto推断中。</li>
<li>类型推断是<em>universal reference</em>的前提，不存在类型推断<em>type&amp;&amp;<em>就是</em>rvalue reference</em>。</li>
<li>当<em>universal reference</em>绑定左值时，结果为左值引用；当<em>universal reference</em>绑定右值时，结果为右值引用。</li>
</ul>
<h1 id="item25-use-stdmove-on-rvalue-references-stdforward-on-universal-references"><a class="header" href="#item25-use-stdmove-on-rvalue-references-stdforward-on-universal-references">Item25: Use <em>std::move</em> on rvalue References, <em>std::forward</em> on Universal References</a></h1>
<p><em>rvalue references</em>总是和可以<em>move</em>的对象绑定在一起：</p>
<pre><code>class Widget {
public:
    Widget(Widget&amp;&amp; rhs);   // move constructor. rhs definitely  
                            //refers to an object eligible to moveing.
    ...
};
</code></pre>
<p>所以总是可以对rhs引用的对象进行移动，所以移动构造函数就应该进行这样的实现，对可移动的数据成员进行移动：</p>
<pre><code>class Widget {
public:
    Widget(Widget&amp;&amp; rhs) : 
        name(std::move(rhs.name)), pImpl(std::move(rhs.pImpl)){}
    ...
private:
    std::string name
    std::shared_ptr&lt;Impl&gt; pImpl;
};
</code></pre>
<p><em>universal references</em>(<em>forwarding references</em>)指代其绑定的对象有可能可以进行<em>move</em>：</p>
<pre><code>class Widget {
public:
    template&lt;typename T&gt;
    void setName(T&amp;&amp; newName) {     // newName might be moving-able.
        name = std::forward&lt;T&gt;(newName);
    }
};
</code></pre>
<h2 id="why-do-so"><a class="header" href="#why-do-so">Why do so</a></h2>
<p>对<em>rvalue reference</em>使用<em>std::forward</em>是可以的，因为<em>std::forward</em>可以实现<em>std::move</em>，但是这样的代码可读性差，易出错；对<em>universal reference</em>使用<em>std::mvoe</em>也是可以的，但是后果很严重，因为有可能篡改一些<em>lvalue</em>。</p>
<p>比如以下代码，可以通过编译：</p>
<pre><code>class Widget {
public:
    template&lt;typename T&gt;
    void setName(T&amp;&amp; newName) {
        name = std::move(newName);
    }
};

std::string getWidgetName();
Widget w;
auto n = getWidgetName();       // n is lvalue.
w.setName(n);                   // Move n to w.name.
                                // Now n is unknown.
</code></pre>
<p>也有认为可以通过重载函数替代模板和万能引用来实现：</p>
<pre><code>class Widget {
public:
    void setName(const std::string&amp; newName) {
        name = newName;                 // copy version.
    }
    void setName(std::string&amp;&amp; newName) {
        name = std::move(newName);      // move version.
    }
};
</code></pre>
<p>这样的代码好像可以替代模板与万能引用，但其实有许多缺点：<br />
使用两个函数替代一个函数带来更多的维护成本；同时原版本的实现更加有效率：<br />
假设有如下代码：</p>
<pre><code>w.setName(&quot;some string&quot;);
</code></pre>
<p>&quot;some string&quot;是一个字符串字面值，前一个版本可以生成函数：</p>
<pre><code>void setName(char&amp; newName[12]) {
    name = newName;
}
</code></pre>
<p>这个函数可以直接将字符串传给name的赋值操作符，而后一个版本需要先构造newName，然后将newName传给移动赋值操作符，这就比原版本多出了需要更多的操作，更低的效率。但是致命的还不在这两条原因。</p>
<p>如果函数的参数数量增加，甚至用上了可变参数，重载的方法将无法使用，因为为了覆盖所有情况需要重载2^n个函数，所以只能使用<em>universal reference</em>的方法实现。</p>
<h2 id="when-use-reference-more-than-one-times"><a class="header" href="#when-use-reference-more-than-one-times">When Use reference More Than One Times</a></h2>
<p>有时传入的<em>rvalue reference</em>或者<em>universal reference</em>可能需要多次使用，<em>std::move</em>和<em>std::forward</em>应该只用在最后一次调用：</p>
<pre><code>template&lt;typename T&gt;
void setSignText(T&amp;&amp; text) {
    sign.setText(text);
    auto now = std::chrono::system_clock::now();
    signHistory.add(now, std::forward&lt;T&gt;(text));
}
</code></pre>
<p>原因很简单，在最后一次使用之前我们需要保证引用中的内容不能被移走。<em>std::move</em>在某些情况下，应该被<em>std::move_if_noexcept</em>替代。</p>
<h2 id="return-value-and-rvo"><a class="header" href="#return-value-and-rvo">Return Value and <em>RVO</em></a></h2>
<p>如果函数是以值返回，如果想要返回的对象是绑定在<em>rvalue reference</em>或者<em>universal reference</em>，应该使用<em>std::move</em>和<em>std::forward</em>包装返回的引用：</p>
<pre><code>Matrix operator(Matrix&amp;&amp; lhs, const Matrix&amp; rhs) {
    lhs += rhs;
    return std::move(lhs);      // move lhs into return value.
}
</code></pre>
<p>通过这样，如果Matrix是可移动的，可以把参数右值lhs移动到返回的临时对象中去，对比不用的<em>std::move</em>：</p>
<pre><code>Matrix operator(Matrix&amp;&amp; lhs, const Matrix&amp; rhs) {
    lhs += rhs;
    return lhs;     // copy lhs to return value.
}
</code></pre>
<p>如果不用<em>std::move</em>，那么进行的就是copy，而lhs是一个建议进行移动的对象，增加了拷贝成本。</p>
<p>如果Matrix不支持移动，那么使用<em>std::move</em>的版本也能够成功匹配上复制操作，如果未来Matrix支持了移动操作，那么该函数的代码也不需要重新修改，增加了代码的可维护性。</p>
<p>同样的，对于<em>universal reference</em>：</p>
<pre><code>template&lt;typename T&gt;
Fraction reduceAndCopy(T&amp;&amp; frac) {
    frac.reduce();
    return std::forward&lt;T&gt;(frac);   // move rvalue into return  
                                    // value. copy lvalue into return value.
}
</code></pre>
<p>注意以上条件限于<em>reference</em>，而不是<em>local variable</em>，而且是按值返回：</p>
<pre><code>Widget makeWidget {
    ...
    Widget w;
    return w;       // RVO.
}

Widget makeWidget {
    ...
    Widget w;
    return std::move(w);        // move.
}
</code></pre>
<p>对于<em>local variable</em>，不要在return中使用<em>std::move</em>和<em>std::forward</em>，因为这阻止了编译器的优化(<em>Return Value Optimization</em>).</p>
<p>RVO：编译器在用于返回的局部变量类型与返回类型一致的情况下可以省略<em>return value</em>的copy：这个局部变量包括return语句中创建的临时对象。有时RVO特指对临时对象的返回，而NRVO指代对<em>named value</em>的返回。</p>
<p>如果使用<em>std::move</em>阻止了RVO，反而多了移动操作，因为std::move(w)其实是一个指向<em>local variable</em>的引用，不满足<em>RVO</em>的条件。</p>
<p>但同时RVO是一项标准建议的优化，并不是标准(尽管大多数编译器都支持这门优化)。当没有RVO的时候，编译器会被要求使用<em>move</em>而不是<em>copy</em>进行返回，所以在return中使用<em>std::move</em>是徒劳无功的。</p>
<p>同样的理由可以用于返回<em>by-value parameter</em>的情形，因为parameter是不会进行RVO的，但是编译器会主动使用<em>move</em>而不是<em>copy</em>返回这个值，所以没有必要使用<em>std::move</em>：</p>
<pre><code>Widget makeWidget(Widget w) {
    ...
    return w;       // by-value parameter of same type of return.
}
</code></pre>
<p>编译器会自动进行如下的实现:</p>
<pre><code>Widget makeWidget(Widget w) {
    ...
    return std::move(w);        // treat w as rvalue.
}
</code></pre>
<p>对于返回<em>local variable</em>使用<em>std::move</em>，并不能优化代码，反而禁止了编译器的优化。只有某些情况下对<em>skocal variable</em>使用<em>std::move</em>才有意义(比如传入某些函数，而你已经不再需要这个变量了)。所以不要对return的变量使用<em>std::move</em>。</p>
<h2 id="things-to-remember-22"><a class="header" href="#things-to-remember-22">Things to Remember</a></h2>
<ul>
<li>在最后一次使用引用的时候，对<em>rvalue reference</em>使用<em>std::move</em>,对<em>universal reference</em>使用<em>std::forward</em>。</li>
<li>对于返回<em>rvalue reference</em>和<em>universal reference</em>，执行第一条规则。</li>
<li>对于返回局部变量或者按值传递参数，不要使用<em>std::move</em>或者<em>std::forward</em>，这禁止了RVO。</li>
</ul>
<h1 id="item26-avoid-overloading-on-universal-references"><a class="header" href="#item26-avoid-overloading-on-universal-references">Item26: Avoid Overloading on Universal References</a></h1>
<h2 id="use-perfect-forwarding-template"><a class="header" href="#use-perfect-forwarding-template">Use <em>perfect forwarding template</em></a></h2>
<p><em>perfect forwarding template</em>具有超广的适应性和良好的性能，见如下实现：</p>
<pre><code>class NameLog {
public:
    ...
    void logAndAdd(const std::string&amp; name) {
        auto now = std::chrono::system_clock::now();
        log(now, &quot;logAndAdd&quot;);
        names.emplace(name);
    }
private:
    std::multiset&lt;std::string&gt; names;
};
</code></pre>
<p>函数logAndAdd的参数为<em>const std::string&amp;</em>，可以绑定以下对象：</p>
<pre><code>std::string myname(&quot;Darla&quot;);

NameLog l;

l.logAndAdd(myname);          // pass lvalue std::string.
l.logAndAdd(std::string(&quot;David&quot;));      // pass rvalue std::string.
l.logAndAdd(&quot;shanshan&quot;);                // pass string literal.
</code></pre>
<p>第一个传值将myname(lvalue)绑定给name，最后在函数内部作为emplace的函数参数，调用<em>std::string</em>的复制构造函数，基本没有可优化的余地；第二个传值将一个rvalue绑定给name，最后在函数内部作为emplace的函数参数，调用<em>std::string</em>的复制构造函数，这里显然可以调用<em>std::string</em>的移动构造函数来节省时间；第三个传值多了一个临时对象的创建，见Item25。使用<em>perfect forwarding template</em>，可以完美优化传值：</p>
<pre><code>template&lt;typename T&gt;
void logAndAdd(T&amp;&amp; name) {
    auto now = std::chrono::system_clock::now();
    log(now, &quot;logAndAdd&quot;);
    names.emplace(std::forward&lt;T&gt;(name));
}
</code></pre>
<p>第一个传值不变；第二个传值可以使用移动构造函数，第三个传值可以调用<em>std::string</em>的以字符串为参数的构造函数，避免临时对象的构造，完美提升代码效率。</p>
<h2 id="do-not-overloading-perfect-forwarding-template"><a class="header" href="#do-not-overloading-perfect-forwarding-template">Do Not overloading <em>perfect forwarding template</em></a></h2>
<p>为<em>perfect forwarding template</em>重载函数是十分危险的，比如为logAndAdd重载一个以index为参数的函数：</p>
<pre><code>void logAndAdd(int idx) {
    auto now = std::chrono::system_clock::now();
    log(now, &quot;logAndAdd&quot;);
    names.emplace(nameFromIdx(idx));
}

l.logAndAdd(22);        // call the non-template version.

l.logAndAdd(22U);       // call the template version. error.
</code></pre>
<p>可以看到只有完美匹配上非模板的版本，才能正确的实现意图。所以重载<em>perfect forwarding template</em>函数是非常危险的，因为这个模板很容易实现一些非计划的重载，</p>
<p>由于构造函数经常是重载函数，使用<em>perfect forwarding constructor</em>也是非常危险的：</p>
<pre><code>class Person {
public:
    template&lt;typename T&gt;
    explicit Person(T&amp;&amp; n)
        : name(std::forward&lt;T&gt;(n));
    explicit Person(int idx)
        : name(nameFromIdx(idx));
    Person(const Person&amp; rhs);
    Person(Person&amp;&amp; rhs);
private:
    std::string name;
};
</code></pre>
<p>因为<em>perfect forwarding template</em>会和其他构造函数产生竞争。</p>
<pre><code>Person p(&quot;Nancy&quot;);

auto cloneOfP(p);       // create new Person from p, template consturctor.
</code></pre>
<p>因为<em>perfect forwarding template</em>生成了比复制构造函数匹配优先级更高的函数:</p>
<pre><code>explicit Person(Person&amp; n)
    : name(std::forward&lt;Person&amp;&gt;(n));       // have high priority.
</code></pre>
<p>只有这个调用是使用复制构造函数：</p>
<pre><code>const Person cp(&quot;const Nancy&quot;);

auto cloneOfP(cp)       // use copy ctor.
</code></pre>
<p>同理，继承类的拷贝和移动构造函数不使用基类的拷贝和移动构造函数，而是使用基类的<em>perfect forwarding constructor</em>,因为传入的参数并不是完美契合基类的拷贝和移动构造函数。</p>
<pre><code>class SpecialPerson : public Person {
public:
    SpecialPerson(const SpecialPerson&amp; rhs)
        : Person(rhs) {
        ...
    }

    SpecialPerson(SpecialPerson&amp;&amp; rhs)
        : Person(std::move(rhs)) {
        ...
    }
};
</code></pre>
<p>所以有可能的化，避免重载一切<em>perfect forwarding template</em>，这不是一个良好的设计，容易带来出人意料的后果。但如果不可避免的要重载，解决方案见Item27。</p>
<h2 id="things-to-remember-23"><a class="header" href="#things-to-remember-23">Things to Remember</a></h2>
<ul>
<li>重载<em>perfect forwarding template</em>会使得<em>perfect forwarding template</em>在某些出人意料的情况下被调用。</li>
<li><em>perfect forwarding constructor</em>不是一个良好的设计，会与其他的构造函数产生不可预料的竞争与替代，这种情况在继承类调用基类构造函数时也会发生。</li>
</ul>
<h1 id="item27-familiarize-yourself-with-alternatives-to-overloading-on-universal-reference"><a class="header" href="#item27-familiarize-yourself-with-alternatives-to-overloading-on-universal-reference">Item27: Familiarize Yourself With Alternatives to Overloading on Universal Reference</a></h1>
<p>Item26阐明了同时使用<em>perfect forwarding template</em>和<em>overloading function</em>是很危险的。所以当碰见这种情况的时候一般有以下几种方法：</p>
<ul>
<li><em>Abandon overloading</em>：放弃重载，使用不同的函数名分别实现<em>perfect forwarding template</em>和其他函数的功能。</li>
<li><em>Pass by const T&amp;</em>：放弃<em>perfect forwarding template</em>，使用*const T&amp;*传参，缺点是不够高效，性能明显有损耗。</li>
<li><em>Pass by value</em>：放弃<em>perfect forwarding template</em>，使用按值传参，见Item41。</li>
</ul>
<p>那当不可避免的同时使用<em>perfect forwarding template</em>和<em>overloading function</em>的时候，应该如何实现？</p>
<h2 id="using-tag-dispatch"><a class="header" href="#using-tag-dispatch">Using <em>Tag Dispatch</em></a></h2>
<p>接着Item26的例子：<br />
第一种方法，为函数加上标签。函数的外层封装依旧不变，因为这是面向用户代码的，那么目标就是通过函数内部自动甄别传入参数的类型，来调用相应的重载，那么实现如下：</p>
<pre><code>class NameLog {
public:
    ...
template&lt;typename T&gt;
void logAndAdd(T&amp;&amp; name) {
    logAndAddImpl(std::forward&lt;T&gt;(name), std::is_integaral&lt;std::remove_reference_t&lt;T&gt;&gt;());
}
private:
    std::multiset&lt;std::string&gt; names;
};
</code></pre>
<p><em>std::is_integral</em>是一个<em>type trait</em>，可以无视<em>cv-qualifier</em>来判断一个类型是否为整数，使用<em>std::remove_reference</em>来移除引用，最后调用<em>call</em>操作符产生一个<em>tag</em>，传个内层函数：</p>
<pre><code>template&lt;typename T&gt;
void logAndAddImpl(T&amp;&amp; name, std::true_type) {
    auto now = std::chrono::system_clock::now();
    log(now, &quot;logAndAdd&quot;);
    names.emplace(nameFromIdx(idx));
}

template&lt;typename T&gt;
void logAndAddImpl(T&amp;&amp; name, std::false_type) {
    auto now = std::chrono::system_clock::now();
    log(now, &quot;logAndAdd&quot;);
    names.emplace(std::forward&lt;T&gt;(name));
}
</code></pre>
<p><em>std::false</em>和<em>std::true_type</em>就是所谓的<em>tag</em>，可以帮助决定最终调用哪一个函数，注意没有为<em>tag</em>声明参数名：因为<em>tag</em>只是用于提示编译器最后调用哪个函数，在运行期间不起任何作用，最后有可能可以被编译器优化取代，这正是我们所期待的，这项设计被称为<em>tag dispatch</em>。</p>
<h2 id="constraining-template-that-take-universal-references"><a class="header" href="#constraining-template-that-take-universal-references">Constraining template that take <em>universal references</em></a></h2>
<p>注意使用<em>tag dispatch</em>的基石是使用单个函数(非重载)作为用户端的API，但对于特殊函数，这是无法实现的，比如构造函数。Item26提到<em>perfect forwarding template</em>是十分贪婪的，经常能够完美匹配传入参数，而在匹配竞争中受到不合理的调用。这个时候，我们就希望限定<em>perfect forwarding template</em>在某些情况下起作用，而不是总是能够被匹配上。</p>
<pre><code>std::enable_if&lt;condition&gt;::type
</code></pre>
<p>这项技术的关键就是<em>SFINAE</em>。在标准库中给出了<em>std::enable_if</em>，它在条件正确的情况下，会有类型成员<em>value</em>，而在条件错误的情况下，没有这个成员。</p>
<pre><code>class Person {
public:
    template&lt;typename T, 
             typename = std::enable_if_t&lt;!std::is_same_v&lt;Person, std::decay_t&lt;T&gt;&gt;&gt;&gt;
    explicit Person(T&amp;&amp; n)
        : name(std::forward&lt;T&gt;(n)) {}
    explicit Person(int idx)
        : name(nameFromIdx(idx)) {}
private:
    std::string name;
};
</code></pre>
<p><em>std::enable_if_t</em>可以得到<em>std::enable_if</em>的类型成员<em>value</em>；<em>std::is_same_v</em>可以得到一个bool值反应两个模板参数是否同类型；<em>std::decay_t</em>可以得到类型T退化后的类型(删除<em>cv-qualifier</em>和引用，对数组和函数退化为指针)。当传入一个希望使用copy或者move构造函数的参数，<em>perfect forwarding template</em>参与匹配，但是<em>std::enable_if</em>没有类型成员value，匹配失败但是不报错(<em>SFINAE</em>)，最后这个匹配被踢出匹配队列，拷贝构造函数或者移动构造函数当选。</p>
<p>但是可以发现仍然不能解决继承带来的匹配竞争，因为基类和继承类在<em>std::is_same_v</em>中得到的是false:</p>
<pre><code>class Person {
public:
    template&lt;typename T, 
             typename = std::enable_if_t&lt;!std::is_base_of_v&lt;Person, std::decay_t&lt;T&gt;&gt;&gt;&gt;
    explicit Person(T&amp;&amp; n)
        : name(std::forward&lt;T&gt;(n)) {}
    explicit Person(int idx)
        : name(nameFromIdx(idx)) {}
private:
    std::string name;
};   
</code></pre>
<p><em>std::is_base_of_v</em>可以判断后一个类型是否为前一个类型的继承类，如果是用户定义类型同类型也被判断为true(内置类型为false)。最后在加上整数判断:</p>
<pre><code>class Person {
public:
    template&lt;typename T, 
             typename = std::enable_if_t&lt;!std::is_base_of_v&lt;Person, std::decay_t&lt;T&gt;&gt; &amp;&amp;
             !std::is_integral_v&lt;std::remove_reference_t&lt;T&gt;&gt; &gt;&gt;
    explicit Person(T&amp;&amp; n)
        : name(std::forward&lt;T&gt;(n)) {}
    explicit Person(int idx)
        : name(nameFromIdx(idx)) {}
private:
    std::string name;
};       
</code></pre>
<h2 id="trade-offs"><a class="header" href="#trade-offs">Trade-offs</a></h2>
<p>所有方法中，采用<em>perfect forwarding template</em>的方法应该比其他方法更加高效，理由在Item26中说过。但是<em>perfect forwarding template</em>也有劣势。其一有些参数无法进行完美转发，见Item30。其二就是C++虐心的错误消息了：</p>
<pre><code>Person p(u&quot;Konrad Zuse&quot;);   // const char16_t
</code></pre>
<p>u&quot;Konrad Zuse&quot;是不匹配string的构造函数的，这样会抛出错误消息。但是这个错误是在多层转发之后才能发现的，会导致错误信息可读性极差。</p>
<p>在这个例子中，我们知道参数是用于初始化<em>std::string</em>的，所以可以使用<em>static_assert</em>进行检查:</p>
<pre><code>class Person {
public:
    template&lt;typename T, 
             typename = std::enable_if_t&lt;!std::is_base_of_v&lt;Person, std::decay_t&lt;T&gt;&gt; &amp;&amp;
             !std::is_integral_v&lt;std::remove_reference_t&lt;T&gt;&gt; &gt;&gt;
    explicit Person(T&amp;&amp; n)
        : name(std::forward&lt;T&gt;(n)) {
            static_assert(
                std::is_constructible_v&lt;std::string T&gt;,
                &quot;Parameter n cannot be used to construct a std::string&quot;
            );
        }
    explicit Person(int idx)
        : name(nameFromIdx(idx)) {}
private:
    std::string name;
};
</code></pre>
<p><em>std::is_constructible</em>是用于检测initializer的类型是否可以用于构造另一个类型的。这能给我们一个特殊的错误提示，但是可惜的是<em>static_assert</em>的出现位置晚于构造，因为构造函数先构造对象后执行函数体。</p>
<h2 id="things-to-remember-24"><a class="header" href="#things-to-remember-24">Things to Remember</a></h2>
<ul>
<li>解决<em>perfect forwarding template</em>和<em>overloading</em>的矛盾，可以有以下解决办法：放弃重载、用按常右值引用传参、用按值传参、使用<em>tag dispatch</em>。</li>
<li>可以使用<em>SFINAE</em>限制<em>perfect forwarding template</em>的应用场景。</li>
<li><em>perfect forwarding template</em>具有更高的效率，但是易错难用。</li>
</ul>
<h1 id="item28-understand-reference-collapsing"><a class="header" href="#item28-understand-reference-collapsing">Item28: Understand <em>Reference Collapsing</em></a></h1>
<p><em>universal reference</em>当接收左值时，表现为左值引用，接收右值时，表现为右值引用。其背后的内在机制是<em>reference collapsing</em>，即引用折叠。</p>
<pre><code>template&lt;typename T&gt;
void func(T&amp;&amp; param);
</code></pre>
<p>当param是一个左值时，T为左值引用；当param是一个右值时，T为非引用类型:</p>
<pre><code>Widget widgetFactory();
Widget w;
func(w);                    // T deduced to be Widget&amp;.
func(widgetFactory());      // T deduced to be Widget.
</code></pre>
<h2 id="reference-collapsing"><a class="header" href="#reference-collapsing"><em>Reference Collapsing</em></a></h2>
<p>注意在C++中，定义实实在在的&quot;引用的引用&quot;是非法的：</p>
<pre><code>int x;
auto&amp; &amp; rx = x;     // error.
</code></pre>
<p>但是在函数模板中，会发生<em>reference collapsing</em>引用折叠：</p>
<pre><code>template&lt;typename T&gt;
void func(T&amp;&amp; param);

func(w);        // T is Widget&amp;, T&amp;&amp; is Widget&amp; &amp;&amp;?
</code></pre>
<p>引用折叠的机制很简单，两个引用只要其中一个为左值引用，则折叠为左值引用；若两个引用均为右值引用，则折叠为右值引用：</p>
<pre><code>func(w);        // T is Widget&amp;, T&amp;&amp; is Widget&amp;(&amp; &amp;&amp; collapse to &amp;).
</code></pre>
<p>再看看<em>std::forward</em>如何工作：</p>
<pre><code>Widget fparam;

template&lt;typename T&gt;
void f(T&amp;&amp; fparam) {
    someFunc(std::forward&lt;T&gt;(fparam));
}

template&lt;typename T&gt;
T&amp;&amp; std::forward(remove_reference_t&lt;T&gt;&amp; param) {
    return static_cast&lt;T&amp;&amp;&gt;(param);
}
</code></pre>
<p>当<em>fparam</em>是一个左值时，T为Widget&amp;，生成<em>std::forward&lt;Widget&amp;&gt;</em>:</p>
<pre><code>Widget&amp; &amp;&amp; std::forward(Widget&amp; param) {
    return static_cast&lt;Widget&amp; &amp;&amp;&gt;(param);
}
</code></pre>
<p><em>reference collapsing</em>：</p>
<pre><code>Widget&amp; std::forward(Widget&amp; param) {
    return static_cast&lt;Widget&amp;&gt;(param);
}
</code></pre>
<p>函数返回一个左值引用，是一个左值(rvalue)。
当<em>fparam</em>是一个右值时，T为Widget，生成<em>std::forward<Widget></em>:</p>
<pre><code>Widget&amp;&amp; std::forward(Widget&amp; param) {
    return static_cast&lt;Widget&amp;&amp;&gt;(param);
}
</code></pre>
<p>函数返回一个右值引用，是一个右值(消亡值xvalue)。</p>
<p><em>reference collapsing</em>发生在4种语法环境中：其一就是上面的模板实例化；其二是<em>auto</em>生成类型时。因为auto的类型推断和template基本相同，所以<em>reference collapsing</em>也类似：</p>
<pre><code>auto&amp;&amp; w1 = w;  // auto is Widget&amp;, auto&amp;&amp; is Widget&amp;, reference collapsing happen.
auto&amp;&amp; w2 = widgetFactory();    // auto is Widget, auto&amp;&amp; is Widget&amp;&amp;, no reference collapsing.
</code></pre>
<p><em>universal reference</em>只是一个概念上的抽象，绕开繁杂的类型推断和引用折叠，所以<em>universal reference</em>不是新的引用，只是由以下两点原因作用而成的：</p>
<ul>
<li>因为类型推断区分了<em>lvalue</em>和<em>rvalue</em>，前者推断为T&amp;；后者推断为T。</li>
<li><em>reference collapsing</em>发生。</li>
</ul>
<p>另外还有两种发生<em>reference collapsing</em>的场景：其三，使用<em>typedefs</em>和<em>alias declarations</em>；</p>
<pre><code>template&lt;typename T&gt;
class Widget {
public:
    typedef T&amp;&amp; RvalueRefToT;
    ...
}

Widget&lt;int&amp;&gt; w;

typedef int&amp; &amp;&amp; RvalueRefToT;   // reference collapsing happen.

typedef int&amp; RvalueRefToT;
</code></pre>
<p>其四，使用<em>decltype</em>：当涉及<em>decltype</em>的类型分析时，出现指向引用的引用，发生<em>reference collapsing</em>。</p>
<h2 id="things-to-remember-25"><a class="header" href="#things-to-remember-25">Things to Remember</a></h2>
<ul>
<li><em>reference collapsing</em>在四种场景中发生：模板实例化，<em>auto</em>类型生成，<em>typedefs</em>和<em>alias declarations</em>，<em>decltype</em></li>
<li><em>reference collapsing</em>发生时，其中一个引用是左值引用，则为左值引用；任意一个引用为右值引用，则为右值引用。</li>
<li><em>universal reference</em>的条件：类型推断区分了<em>lvalue</em>和<em>rvalue</em>，前者推断为T&amp;；后者推断为T；<em>reference collapsing</em>。</li>
</ul>
<h1 id="item29-assume-that-move-operations-are-not-present-not-cheap-and-not-used"><a class="header" href="#item29-assume-that-move-operations-are-not-present-not-cheap-and-not-used">Item29: Assume That Move Operations Are Not Present, Not Cheap, And Not Used</a></h1>
<p><em>move semantics</em>是C++11的一块重要的拼图，它带来了更高效的拷贝操作，更准确的拷贝语义。但是<em>move semantics</em>并不像想象中的那么高效、普遍。</p>
<ul>
<li>许多类型不支持移动操作</li>
<li>许多类型的移动操作并不如想象中的高效</li>
</ul>
<p>首先许多类型是不支持<em>move semantics</em>的。C++标准库在C++11进行了一次彻底的翻新，许多类型都加入了更加高效的移动操作，但也有许多类型并没有。<br />
所有C++11的标准模板库中的容器都支持移动操作，但是并不是所有容器的移动操作都是高效的：可能因为这类容器根本无法支持高效的移动操作；也可能因为容器元素无法配合容器实现高效的移动。</p>
<p>比如<em>std::array</em>，其实是一个带有STL接口的原生数组。其他STL容器的元素大都是储存在堆上的，而<em>std::array</em>是存储在栈上的。所以<em>std::vector</em>的移动，本质上只需要改变标记元素位置用的若干个指针就可以，复杂度O(1)。而<em>std::array</em>的移动，需要依次调用每一个元素的移动，复杂度O(n):</p>
<pre><code>std::vector&lt;Widget&gt; vw1;
...
auto vw2 = std::move(vw1);  // move vw1 into vw2. runs in constant time. only ptrs in vw1 and vw2 are modified.

std::array&lt;Widget, 10000&gt; aw1;
...

auto aw2 = std::move(aw1);  // move aw1 into aw2. runs in linear time. All elements in aw1 are move into aw2.
</code></pre>
<p>再看Widget的拷贝操作，如果Widget的移动比拷贝高效，那么上述容器的移动依旧是比拷贝要高效的，所以std::array确实需要支持移动语义。</p>
<p>再看另一个例子<em>std::string</em>。<em>std::string</em>支持短字符串优化<em>small string optimization</em>(SSO)。如果<em>std::string</em>中的字符串足够小，那么字符串的存储将不会分配在堆上，而是分配在一块内置buffer上。所以对于小字符串的移动并不比拷贝高效。</p>
<p>即使有些类支持高效的移动操作，最后依旧可能被耗时的拷贝操作所替代。见Item14.有些容器操作要求强异常安全保证，只有当移动操作声明不抛出异常的情况下，才会使用<em>move</em>代替<em>copy</em>。</p>
<p>以下应用场景，<em>move semantics</em>不会有利于程序的效率:</p>
<ul>
<li>No move operations：类型不支持move。</li>
<li>Move not faster：move并不比copy快。</li>
<li>Move not usable：场景要求move操作不会抛出异常，然而move并没有声明<em>noexcept</em>。</li>
<li>Source object is lvalue：除了个别例外，只有右值可以用作移动的来源。</li>
</ul>
<h2 id="things-to-remember-26"><a class="header" href="#things-to-remember-26">Things to Remember</a></h2>
<ul>
<li>总是假定<em>move operations</em>不存在、不效率、不可用。</li>
<li>在确认可以使用<em>move semantics</em>的情况下，无视上一条。</li>
</ul>
<h1 id="item30-familiarize-yourself-with-perfect-forwarding-failure-cases"><a class="header" href="#item30-familiarize-yourself-with-perfect-forwarding-failure-cases">Item30: Familiarize Yourself With <em>perfect forwarding</em> Failure Cases.</a></h1>
<p>完美转发意味着不仅仅转发对象，而且转发对象的值类型(左值还是右值？)，对象的cv-限定(const or volatile)。而<em>universal reference</em>的类型推断包含了对象的该类信息，帮助我们转发这些信息。</p>
<pre><code>template&lt;typename T&gt;
void fwd(T&amp;&amp; param) {
    f(std::forward&lt;T&gt;(param));      // forward it to f.
}

template&lt;typename... Args&gt;
void fwd(T&amp;&amp; param...) {
    f(std::forward&lt;T&gt;(param)...);   // forward package to f.
}
</code></pre>
<p>但是完美转发并不总是成功转发的。比如fwd传入参数不符合f的要求就会导致转发的失败。还有一些参数碍于某些语言特性，不能够通过完美转发：</p>
<ul>
<li>模板无法推断当前类型</li>
<li>编译器推断类型不符合内层函数的参数要求</li>
</ul>
<h2 id="braced-initializer"><a class="header" href="#braced-initializer"><em>Braced Initializer</em></a></h2>
<p>比如f有如下形式：</p>
<pre><code>void f(const std::vector&lt;int&gt;&amp; v);
</code></pre>
<p>对f传入<em>braced initializer</em>是能够通过编译的：</p>
<pre><code>f({1, 2, 3});       // fine.
</code></pre>
<p>但是如果进行完美转发，结果是失败</p>
<pre><code>fwd({1, 2, 3});     // failure.
</code></pre>
<p>前者，<em>braced initializer</em>能够对参数vector<int>进行初始化。但是后者先要通过模板的类型推断，但是模板是无法对<em>braced initialzer</em>进行推断的(见Item2)。</p>
<p>使用<em>braced initializer</em>就属于编译器无法推断模板类型。</p>
<p>Item2中提到，auto可以对<em>braced initializer</em>进行推断，所以以下代码可以将<em>braced initializer</em>推断为<em>std::initialzer_list</em>通过编译。</p>
<pre><code>auto il = {1, 2, 3};
fwd(il);        // fine.
</code></pre>
<h2 id="0-or-null-as-null-pointer"><a class="header" href="#0-or-null-as-null-pointer">0 or NULL as null Pointer</a></h2>
<p>Item8解释了0和宏NULL和空指针的关系。对于模板而言，类型推断总是把0和NULL推断为整型(通常为int)。所以使用0和NULL也是无法完美转发的，属于第二种错误：</p>
<pre><code>void f(void* p);
fwd(0);             // failure.
fwd(NULL);          // failure.
fwd(nullptr);       // fine.
</code></pre>
<h2 id="declaration-only-integral-static-const-and-constexpr-data-member"><a class="header" href="#declaration-only-integral-static-const-and-constexpr-data-member">Declaration-only Integral <em>static const</em> and <em>constexpr</em> Data Member</a></h2>
<p>一般来说，不需要定义<em>static const</em>或者<em>static constepxr</em>的值，只需要声明就行。因为编译器会进行<em>const propagation</em>，从而不需要为这类变量开拓空间：</p>
<pre><code>class Widget {
public:
    static const std::size_t MinVals = 28;  // declare, not define.
}
</code></pre>
<p>对于调用该变量的函数，编译器会使用常量直接去补充参数：</p>
<pre><code>void f(std::size_t val);

f(Widget::MinVals);     // fine.
</code></pre>
<p>但是对于完美转发就不行了，因为没有定义该变量，所以一切有关于对该变量的地址操作都是非法的。而完美转发模板对该参数的推断会是一个引用。</p>
<pre><code>fwd(Widget::MinVals);   // T is const size_t&amp;. error should not link.
</code></pre>
<p>所以该操作是无法通过链接的。</p>
<p>但是这是对于标准而言，而许多编译器都会通过上述代码，但是这毕竟是不符合标准的，为了上述代码的可移植性，应当加入对该变量的定义:</p>
<pre><code>constexpr std::size_t Widget::MinVals;      // in cpp.
</code></pre>
<p>注意定义不应该重复初始化，初始化应该只存在于一个地方。</p>
<h2 id="overload-function-names-and-template-names"><a class="header" href="#overload-function-names-and-template-names">Overload Function Names and Template Names</a></h2>
<p>假如有以下接收函数指针为参数的函数：</p>
<pre><code>void f(int(*pf)(int));
</code></pre>
<p>当然可以忽略指针：</p>
<pre><code>void f(int(pf)(int));
</code></pre>
<p>有以下两个过程函数:</p>
<pre><code>int processVal(int val);        // ver.1
int processVal(int val, int priority);  // ver.2
</code></pre>
<p>调用f:</p>
<pre><code>f(processVal);      // fine. use ver.1.

fwd(processVal);    // error! which processVal？
</code></pre>
<p>要注意到完美转发模板终究只是一个模板，它不会顾及自己内部，只会先进行参数推断，再生成实例，才有内部实现。</p>
<p>解决这个问题，可以先将重载函数绑定给一个固定函数类型的指针上或者进行强制转化，再进行传参：</p>
<pre><code>int(*pf)(int) = processVal;
fwd(pf);

fwd(static_cast&lt;int(*)(int)&gt;(processVal));
</code></pre>
<h2 id="bitfields"><a class="header" href="#bitfields"><em>Bitfields</em></a></h2>
<p>比如有以下位域定义：</p>
<pre><code>struct IPv4Header {
    std::uint32_t   version:4,
                    IHL:4,
                    DSCP:6,
                    ECN:2,
                    totalLength:16;
}；

void f(std::size_t sz);

IPv4Header h;

f(h.totalLength);       // fine. implicit conversion happen
fwd(h.totalLength);     // error.
</code></pre>
<p>这个问题类似于<em>braced initializer</em>，模板无法对位域进行类型推断，同时没有任何引用和指针可以指向位域。所以解决方案就是将位域拷贝出来并做强制转换：</p>
<pre><code>auto length = static_cast&lt;std::uint16_t&gt;(h.totalLength);
fwd(length);
</code></pre>
<h2 id="things-to-remember-27"><a class="header" href="#things-to-remember-27">Things to Remember</a></h2>
<ul>
<li>完美转发通常在两种场景下失败：无法推断类型和“错误”推断类型。</li>
<li>常见的失败有：<em>braced initializer</em>、<em>0 or NULL as null pointer</em>、<em>declaration-only const static data member</em>、<em>template and overloaded funciton names</em>、<em>bitfields</em># Item31: Avoid Default Capture Mode</li>
</ul>
<p><em>lambda</em>表达式并没有给C++带来什么新的东西，但是极大的简化了工作，快速生成临时对象(比如<em>trivial predicates</em>)，对于STL的使用意义重大。关于<em>lambda</em>主要有以下几点概念:</p>
<ul>
<li><em>lambda expression</em>：单纯的<em>lambda</em>表达式。</li>
<li><em>closure</em>：由<em>lambda</em>生成的运行时对象，包含有由捕捉模式规定的数据块。</li>
<li><em>closure class</em>：<em>closure</em>对应的类，由编译器自动生成。</li>
</ul>
<h2 id="capture-mode"><a class="header" href="#capture-mode">Capture Mode</a></h2>
<ul>
<li>identifier：拷贝捕获</li>
<li>identifier...	：拷贝捕获包</li>
<li>identifier initializer  (C++14)：初始化拷贝捕获</li>
<li>&amp;identifier：引用捕获</li>
<li>&amp;identifier...：引用捕获包</li>
<li>&amp;identifier initializer	(C++14)：初始化引用捕获</li>
<li>this：引用捕获母对象</li>
<li>*this	(C++17)：拷贝捕获母对象</li>
</ul>
<p>如果默认引用捕获，则特化捕获不能再是引用；如果默认捕获是拷贝，则特化捕获必须是引用或者*this，每个捕获只能出现一次。</p>
<h2 id="avoid-default-reference-capture"><a class="header" href="#avoid-default-reference-capture">Avoid Default Reference Capture</a></h2>
<p>C++11为<em>lambda</em>提供了两种捕捉模式：by-value和by-reference。默认的<em>by-reference</em>有可能导致悬空引用。这是因为一旦引用对象的生命比<em>lambda</em>要短，就会导致<em>lambda</em>内部的引用悬空：</p>
<pre><code>using FilterContainer = std::vector&lt;std::function&lt;bool(int)&gt;&gt;;      // a container class for callable object.

FilterContainer filters     // container.
filters.emplace_back(
    [](int value){ return value % 5 == 0; }
);
</code></pre>
<p>如果<em>lambda</em>中的常数使用一个捕获数，捕获模式采用默认引用捕获：</p>
<pre><code>void addDivsorFilter() {
    auto calc1 = computeVal1();
    auto calc2 = computeVal2();

    auto divisor = computeDivisor(calc1, calc2);

    filters.emplace_back(
        [&amp;](int value){ return value % divisor == 0; }      // divisor may be dangle!
    );
}
</code></pre>
<p>默认采用引用捕获的一大缺点就是上述bug难以发现，因为没有明确divisor是一个引用：</p>
<pre><code>filters.emplace_back(
    [&amp;divisor](int value){ return value % divisor == 0; }      // divisor may be dangle!
);  
</code></pre>
<p>虽然这样的代码依旧是错误的，但是至少对divisor是一个引用有足够的提示。当然如果<em>lambda</em>执行时间得当如下述代码依旧是安全的：</p>
<pre><code>template&lt;typename C&gt;
void workWithContainer(const C&amp; container) {
    auto calc1 = computeVal1();
    auto calc2 = computeVal2();
    auto divisor = computeDivisor(calc1, calc2);
    if(std::all_of(
        std::begin(container), std::end(container), [&amp;](const typename C::value_type&amp; value){ return value % divisor == 0; })
    ) {
        ...
    }
}
</code></pre>
<p>但如果<em>lambda</em>表达式如果希望被复用，经过copy到其他环境下使用，就会发生错误。
同时C++14支持了lambda的参数推断，所以参数列表可以简化：</p>
<pre><code>if(std::all_of(
    std::begin(container), std::end(container), [&amp;](const auto&amp; value){ return value % divisor == 0; })
)
</code></pre>
<h2 id="avoid-default-value-capture"><a class="header" href="#avoid-default-value-capture">Avoid Default Value Capture</a></h2>
<p>对之前的<em>lambda</em>的容器类使用默认值捕获，就避免了引用悬空的问题：</p>
<pre><code>filters.emplace_back(
    [=](int value){ return value % divisor == 0; }      // divisor may be dangle!
);  
</code></pre>
<p>但是默认值捕获，可能会导致指针悬空：</p>
<pre><code>filters.emplace_back(
    [=](int value){ return value % *pdivisor == 0; }      // pdivisor may be dangle!
);
</code></pre>
<p>当然不要使用裸指针，使用智能指针可以避免这个问题，但是我们不总是能够避免使用裸指针，最突出的情况就是this指针。假设有如下情况：</p>
<pre><code>class Widget {
public:
    ...
    void addFilter() const;

private:
    int divisor;
};

void Widget::addFilter() const {
    filters.emplace_back(
        [=](int value){ return value % divisor == 0; }      // pass compile, but not safe. 
    );
}
</code></pre>
<p>我们无法捕获类的数据成员，只能捕获local object，所以以下代码是会报错的：</p>
<pre><code>filters.emplace_back(
    [divisor](int value){ return value % divisor == 0; }      // cannot capture divisor. divisor is a member.
);
</code></pre>
<p>由于this是一个局部变量，使用默认捕获相当于捕获了引用捕获了this，编译器会使用this-&gt;divisor替代divisor：</p>
<pre><code>filters.emplace_back(
    [this](int value){ return value % divisor == 0; }      // not safe.
);
</code></pre>
<p>那么如果对象Widget已经销毁，捕获的this悬空，再次调用容器中的<em>lambda</em>将会不安全。这种错误十分危险：</p>
<pre><code>void doSomeWork() {
    auto pw = std::make_unique&lt;Widget&gt;();
    pw-&gt;addFilter();
    ...                 // destory Widget; now filters holds dangling pointer.
}
</code></pre>
<p>该问题的解决方案就是进行拷贝：</p>
<pre><code>void Widget::addFilter() const {
    auto divisorCopy = divisor;
    filters.emplace_back(
        [divisorCopy](int value){ return value % divisorCopy == 0; }     // copy the divisor.
    );
}
</code></pre>
<p>C++17提供了拷贝捕获整个对象，这里不赘述。使用默认捕获十分危险，因为很容易导致一些难以发现的错误。</p>
<h2 id="use-init-capture-and-take-notice-of-static"><a class="header" href="#use-init-capture-and-take-notice-of-static">Use Init Capture and Take Notice of Static</a></h2>
<p>C++14提供了初始化捕获：</p>
<pre><code>void Widget::addFilter() const {
    filters.emplace_back(
        [divisorCopy = divisor](int value){ return value % divisorCopy == 0; }     // copy the divisor.
    );
}
</code></pre>
<p><em>lambda</em>只能捕获automatic storage duration的变量，即，static变量lambda不会捕获：</p>
<pre><code>template&lt;typename C&gt;
void workWithContainer(const C&amp; container) {
    static auto calc1 = computeVal1();
    static auto calc2 = computeVal2();
    static auto divisor = computeDivisor(calc1, calc2);
    if(std::all_of(
        std::begin(container), std::end(container), 
        [=](const auto&amp; value){ return value % divisor == 0; })
        // capture nothing.
    ) {
        ...
    }
    divisor++;
}
</code></pre>
<h2 id="things-to-remember-28"><a class="header" href="#things-to-remember-28">Things to Remember</a></h2>
<ul>
<li>默认引用捕获可能导致悬空引用。</li>
<li>默认拷贝捕获可能导致悬空指针(特别是this)，而且错误的指示<em>lambda</em>完全<em>self-contained</em>。</li>
</ul>
<h1 id="item32-use-init-capture-to-move-objects-into-closures"><a class="header" href="#item32-use-init-capture-to-move-objects-into-closures">Item32: Use Init Capture to Move Objects Into Closures</a></h1>
<p>C++11的<em>lambda</em>中无法移动一个对象进入<em>closure</em>，C++14中提供了一个新的机制，使得移动对象进入闭包变为可能，即<em>init capture</em>。<em>init capture</em>可以表达除了默认捕捉以外的所有形式的捕捉。</p>
<h2 id="init-capture"><a class="header" href="#init-capture"><em>Init Capture</em></a></h2>
<p><em>init capture</em>具有两个部分：一是闭包中的变量名，二是初始化闭包中变量的表达式。</p>
<pre><code>class Widget {
public:
    ...
    bool isValidated() const;
    bool isProcessed() const;
    bool isArchived() const;
    ...
private:
    ...
};

auto pw = std::make_unique&lt;Widget&gt;();

auto func = [pw = std::move(pw)]{
    return pw-&gt;isValidated() &amp;&amp; pw-&gt;isArchived();
}
</code></pre>
<p>通过初始化捕捉就可以把变量移动到闭包中去。通过初始化捕捉还可以实现表达式的捕捉：</p>
<pre><code>auto func = [pw = std::make_unique&lt;Widget&gt;()]{
    return pw-&gt;isValidated() &amp;&amp; pw-&gt;isArchived();
}
</code></pre>
<p>原本<em>lambda</em>是无法捕捉一个表达式的，通过初始化捕捉可以捕捉一个表达式的值，又称初始化捕捉为<em>generalized lambda capture</em>。</p>
<h2 id="how-to-achieve-move-capture-in-c11"><a class="header" href="#how-to-achieve-move-capture-in-c11">How to Achieve move-capture in C++11</a></h2>
<p><em>lambda</em>并不是一个全新的功能，<em>lambda</em>能做的任何事，使用<em>callable class</em>都可以实现:</p>
<pre><code>class IsValandArch {
public:
    using DataType = std::unique_ptr&lt;Widget&gt;;
    explicit IsValAndArch(DataType&amp;&amp; ptr):
        pw(std::move(ptr)){}
    bool operator()() const {
        return pw-&gt;isValidated() &amp;&amp; pw-&gt;isArchived();
    }
private:
    DataType pw;
};

auto func = IsValAndArch(std::make_unique&lt;Widget&gt;());
</code></pre>
<p>同时还可以利用<em>std::bind</em>和<em>lambda</em>的参数：</p>
<pre><code>std::vector&lt;double&gt; data;

auto func = [data = std::move(data)]{...};      // C++14 style.

auto func = std::bind(
    [](const std::vector&lt;double&gt;&amp; data){...}, 
    std::move(data))                            // C++11 style.
</code></pre>
<p>称第二种对象为<em>bind object</em>，注意到bind使用<em>const reference</em>做类型声明。这是因为在C++14的形式中，data是拷贝捕获，而<em>lambda</em>默认const，所以捕获参数不能被修改，在C++11的版本中，变量data模拟了被捕获变量，也应该是const的。</p>
<pre><code>auto func = [data = std::move(data)]() mutable {...};

auto func = std::bind(
    [](std::vector&lt;double&gt;&amp; data) mutable {...}, 
    std::move(data))
</code></pre>
<p>以上两个<em>mutable lambda</em>是类似实现。待捕捉对象先通过<em>bind</em>,<em>bind object</em>中包含<em>lambda</em>的一个<em>closure</em>。所以闭包的生命周期和<em>bind object</em>一样。</p>
<h2 id="things-to-remember-29"><a class="header" href="#things-to-remember-29">Things to Remember</a></h2>
<ul>
<li>使用C++14中的<em>init cpature</em>移动捕捉对象或者捕获表达式。</li>
<li>C++11可以通过<em>callable class</em>或者<em>std::bind</em>实现。</li>
</ul>
<h1 id="item33-use-decltype-on-auto-parameters-to-forward-them"><a class="header" href="#item33-use-decltype-on-auto-parameters-to-forward-them">Item33: Use <em>decltype</em> on <em>auto&amp;&amp;</em> Parameters to Forward Them</a></h1>
<p>C++14带来了<em>generic lambda</em>：</p>
<pre><code>auto f = [](auto x){ return normalize(x); };
</code></pre>
<p>其闭包相当于：</p>
<pre><code>class SomeCompilerGeneratedClassName {
public:
    template&lt;typename T&gt;
    auto operator()(T x) const {
        return normalize(x);
    }
}
</code></pre>
<p><em>lambda</em>起到的作用相当于将参数x转发给内部函数normalize，如果需要完美转发，结构应该如下：</p>
<pre><code>auto f = [](auto&amp;&amp; x){ return normalize(std::forward&lt;?&gt;(x)); };
</code></pre>
<p>问题转化为如何填入<em>std::forward</em>的模板参数。因为auto和模板的类型推断基本一致，所以x的类型就包含了传入参数的<em>value category</em>。通过Item3可知道，使用<em>decltype</em>帮助推断传入的x的<em>value category</em>。</p>
<p>如果x绑定一个左值，那么x就是decltype(x)就会产生左值引用类型；如果x绑定一个右值，decltype(x)就会产生一个右值引用类型，这与模板直接传入值类型不同，hui发生<em>reference collapsing</em>,再看<em>std::forward</em>。</p>
<pre><code>template&lt;typename T&gt;
T&amp;&amp; forward(std::remove_reference_t&lt;T&gt;&amp; param) {
    return static_cast&lt;T&amp;&amp;&gt;(param);
}
</code></pre>
<p>如果传入右值，使用decltype(x)作为<em>std::forward</em>的模板参数，那么T = Widget&amp;&amp;，并发生<em>reference collapsing</em>，和直接传入值类型(T = Widget)一样：</p>
<pre><code>Widget&amp;&amp; forward(Widget&amp; param) {
    return static_cast&lt;Widget&amp;&amp;&gt;(param);
}
</code></pre>
<p>这样通过decltype(x)作为<em>std::forward</em>的模板参数也可以实现完美转发：</p>
<pre><code>auto f = [](auto&amp;&amp; x){ 
    return normalize(std::forward&lt;decltype(x)&gt;(x));
};
</code></pre>
<p>对于传入参数包：</p>
<pre><code>auto f = [](auto&amp;&amp;... xs){ 
    return normalize(std::forward&lt;decltype(xs)&gt;(xs)...); 
};    
</code></pre>
<h2 id="things-to-remember-30"><a class="header" href="#things-to-remember-30">Things to Remember</a></h2>
<ul>
<li>使用auto&amp;&amp;(<em>universal reference</em>)和<em>decltype</em>实现<em>lambda</em>的完美转发。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML">
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      processEscapes: true},
      jax: ["input/TeX","input/MathML","input/AsciiMath","output/CommonHTML"],
      extensions: ["tex2jax.js","mml2jax.js","asciimath2jax.js","MathMenu.js","MathZoom.js","AssistiveMML.js", "[Contrib]/a11y/accessibility-menu.js"],
      TeX: {
      extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"],
      equationNumbers: {
      autoNumber: "AMS"
      }
    }
  });
</script>
<h1 id="背景"><a class="header" href="#背景">背景</a></h1>
<p>多租环境下，同一个资源会被多个租户同时占用，不同租户对服务的请求彼此会相互竞争。在多租环境下，我们一般期望有以下的特性：</p>
<ul>
<li>Resource Isolation：资源的有限隔离。
<ul>
<li>不同特性租户彼此资源隔离，尽量减少对彼此之间的影响。</li>
</ul>
</li>
<li>Fairness Schedule：公平调度：
<ul>
<li>不同租户能够公平的分享资源，不能仅仅是不饿死；类似的需求的租户要有基本一致的用户体验。</li>
</ul>
</li>
<li>Smooth latency：稳定平滑的延迟：
<ul>
<li>单个租户看到的响应延迟尽可能稳定，不要出现突发的变化。
为了实现以上的需求，我们有多种手段：限流（Rate Limiting），隔离（isolation），调度（schedule）,调权（priority），相互支撑来达到目标。这次我们核心先介绍调度手段如何达成目标。</li>
</ul>
</li>
</ul>
<h1 id="多租场景下的调度模型"><a class="header" href="#多租场景下的调度模型">多租场景下的调度模型</a></h1>
<p><img src="Multi-Tenant/./assets/Multi-Tenant/scheduling%20model.png" alt="" /></p>
<p>如上图所示，用户A、B、C分别发出请求：</p>
<ul>
<li>Queuing过程：这个过程主要控制如何入队，一般由于Scheduler有调度上限，因此在容量打满后，Queuing还有额外的行为，如Blocking/Droping/Timeout等等。不是本文的重点。</li>
<li>Schduling过程：这个过程主要控制如何出队，核心的决策方案会同时受到生产和消费两端的特性影响，是调度需要解决的核心问题。</li>
</ul>
<h2 id="fifo-or-priorityqueue"><a class="header" href="#fifo-or-priorityqueue">FIFO or PriorityQueue</a></h2>
<p>最简单的调度方式，这个情况下Scheduler本质上是一个Queue或者PriorityQueue。</p>
<p><img src="Multi-Tenant/./assets/Multi-Tenant/fifo.png" alt="" /></p>
<p>由于调度只是简单的将入队位置忠实的反应出来，所以最终我们看到的调度结果受非常多因素影响，比如：</p>
<ul>
<li>锁竞争时的唤醒顺序。</li>
<li>用户请求调用并发度。</li>
<li>权重插队。
所以导致我们最终的调度结果完全不满足多租环境下的公平性。</li>
</ul>
<h2 id="user-round-robin-queue"><a class="header" href="#user-round-robin-queue">User Round-Robin Queue</a></h2>
<p>为了解决这种完全不可控的场景，最简单的方案是引入一个轮询机制。</p>
<ul>
<li>每个用户单独维护一个队列。</li>
<li>Scheduler依照顺序依次轮询每个队列，并取出一个请求作为下一个请求。</li>
</ul>
<p><img src="Multi-Tenant/./assets/Multi-Tenant/user%20round%20robin%20queue.png" alt="" /></p>
<p>可以看到出队顺序确实更加公平了，但是如果每个请求的开销并不那么一致呢？</p>
<p><img src="Multi-Tenant/./assets/Multi-Tenant/user%20round%20robin%20queue%202.png" alt="" /></p>
<ul>
<li>用户A发出的请求需要两倍于B和C的时间。</li>
<li>最终的调度结果导致A占用了50%的资源，而B和C只能占用25%。</li>
</ul>
<h2 id="gpsgeneralized-processor-sharing"><a class="header" href="#gpsgeneralized-processor-sharing">GPS（generalized processor sharing）</a></h2>
<p>GPS（generalized processor sharing）是一个理想的公平调度模型，可以理解成流式的，任意的任意大小的时间间隔内，服务方都按照权重公平的进行资源占用。</p>
<ul>
<li>如下图，S1这个租户占用0.5的权重，其他10个用户分别占用0.05的权重。理想的GPS服务如右图所示。</li>
</ul>
<p><img src="Multi-Tenant/./assets/Multi-Tenant/gps.png" alt="" /></p>
<p>但是真实世界中，请求都是有最小不可分割的大小，而且过小的请求粒度对系统会造成额外的上下文切换成本。因此公平调度是尽可能逼近GPS模型，在尽可能小的粒度上公平。</p>
<h2 id="fair-queuingfq"><a class="header" href="#fair-queuingfq">Fair Queuing(FQ)</a></h2>
<p>为了要达成公平，就必须区分每个请求的开销：</p>
<ul>
<li>引入一个虚拟时钟来标识每个请求的消耗（比如请求的包体大小或者请求耗时等，核心是开发者希望在哪个层面上达到公平）。</li>
<li>同时系统按照自己预估负载能力向前推动时钟（类似于令牌桶，可以是承载的流量大小，CPU周期等等）。</li>
<li>并按照以下规则给所有入队的消息标识标记上如下属性。
<ul>
<li>$A_f^j$：租户f 第j个到达的请求的到达对应的虚拟时钟时间。</li>
<li>$L_f^j$：租户f 第j个到达请求的资源消耗大小。</li>
<li>$S_f^j=max(A_f^j, F_f^{j-1})$：租户f 第j个请求的启动虚拟时钟时间。
<ul>
<li>可以看出当$S_f^j=F_f^{j-1}$时：队列出现了积压。</li>
</ul>
</li>
<li>$F_f^j=S_f^j + L_f^j$：租户f 第j个请求预计的完成虚拟时钟时间。</li>
</ul>
</li>
<li>调度器按照$F_f^j$的从小到大的顺序出队。</li>
</ul>
<p><img src="Multi-Tenant/./assets/Multi-Tenant/fq.png" alt="" /></p>
<ul>
<li>最终，按长期的平均下来，A/B/C分别占用33%的资源。</li>
</ul>
<h2 id="weighted-fair-queuing-wfq"><a class="header" href="#weighted-fair-queuing-wfq">Weighted Fair Queuing (WFQ)</a></h2>
<p>更进一步，如果我们希望不同的租户具备不同的调度权重呢？我们只需要在$F_f^j$中引入调权因子$W_f$。</p>
<ul>
<li>$F_f^j=max(A_f^j, F_f^{j-1}) + L_f^j/W_f$
在上面的Case中，如果我们将B租户增加两倍权重：</li>
</ul>
<p><img src="Multi-Tenant/./assets/Multi-Tenant/wfq.png" alt="" /></p>
<p>就可以达到B用户占用50%资源，而A/C用户各占用25%资源了。</p>
<h2 id="worst-case-fair-weighted-fair-queuing-wf²q"><a class="header" href="#worst-case-fair-weighted-fair-queuing-wf²q">Worst-Case Fair Weighted Fair Queuing (WF²Q)</a></h2>
<p>WF²Q是WFQ的拓展版本，用于解决极端情况下的不公平，由于WFQ引入了权重，$F_f^j$不再能反应真实的请求结束时间，重新考虑GPS的场景：</p>
<ul>
<li>由于S1的10倍权重占用，导致S1的前9个请求的$F_f^j$都小于其他租户同时到达的$F_f^j$，WFQ最终会调度出后面这个结果：其他租户的响应时间都增加了10倍。</li>
</ul>
<p><img src="Multi-Tenant/./assets/Multi-Tenant/wfq1.png" alt="" /><img src="Multi-Tenant/./assets/Multi-Tenant/wfq2.png" alt="" /></p>
<p>WF²Q为了解决这个问题，添加出队约束：</p>
<ul>
<li>只有当$S_f^j \le V_{now}$时，才允许这个任务被调度。</li>
</ul>
<p><img src="Multi-Tenant/./assets/Multi-Tenant/wfq3.png" alt="" /></p>
<p>相较于WFQ，WF²Q的结果更加接近于GPS模型，在更小的粒度上实现了公平。</p>
<h1 id="wfq在多租场景中应用的挑战"><a class="header" href="#wfq在多租场景中应用的挑战">WFQ在多租场景中应用的挑战</a></h1>
<p>上面的方案貌似让我们找到了完美的解决方案，但是在实际的多租场景中，直接应用WFQ依旧有不小的挑战。</p>
<h2 id="并发"><a class="header" href="#并发">并发</a></h2>
<p>Scheduler的下游是一般是一个并发单元，可以并行处理多个任务。（WFQ这类算法一般都是为了串行调度设计的，如网络连接层的包转发，对并发场景的新问题并没有特别的优化），我们拓展一下上面的实验：</p>
<ul>
<li>A和B两个租户一直在发小的请求；C和D两个租户一直在发高耗时的请求。</li>
<li>W1和W2分别是系统中的两个并发单元。
如果直接使用WFQ，我们会得到如下的调度结果：</li>
</ul>
<p><img src="Multi-Tenant/./assets/Multi-Tenant/wfq4.png" alt="" /></p>
<ul>
<li>A和B用户的请求，会被C和D用户的请求Block，从而观察到请求响应的剧烈波动，称之为bursty schedule。</li>
</ul>
<p>在无并发的场景下，我们无法做更深入的优化，但是在并发的场景下，我们有如下的优化空间：</p>
<p><img src="Multi-Tenant/./assets/Multi-Tenant/wfq5.png" alt="" /></p>
<ul>
<li>耗时小和耗时大的请求会分别在两个并发单元中调度，从而彼此观察到的响应波动的比例大幅度缩减，称之为smooth schedule。</li>
</ul>
<h3 id="请求开销的浮动易变方差极大"><a class="header" href="#请求开销的浮动易变方差极大">请求开销的浮动易变（方差极大）</a></h3>
<p>不同租户的不同请求的资源开销与耗时跨度极大（可能是3-4个数量级的差距，）
如图是论文作者在Azure Storage多租服务上的统计：</p>
<p><img src="Multi-Tenant/./assets/Multi-Tenant/l1.png" alt="" /><img src="Multi-Tenant/./assets/Multi-Tenant/l2.png" alt="" /></p>
<p>浮动越大（方差越大），越容易让调度器调度出bursty schedule。</p>
<h2 id="未知的资源开销"><a class="header" href="#未知的资源开销">未知的资源开销</a></h2>
<p>用户请求的资源开销和耗时难以预测，并且绝大多数请求都是不可预测的（如图是论文作者在Azure Storage上统计的某个API的开销，可以看到标准差极大）。
由于资源开销未知，我们就必须引入一个模型或者规则去估计资源开销来达成公平调度。一旦我们错误的低估了一些请求的开销，将会导致这些请求block住整个调度系统，造成低开销的请求饥饿，造成bursty schedule。</p>
<h1 id="two-dimension-fair-queuing"><a class="header" href="#two-dimension-fair-queuing">Two dimension Fair Queuing</a></h1>
<h2 id="2dfq"><a class="header" href="#2dfq">2DFQ</a></h2>
<p>WFQ不能实现平滑调度的核心原因是所有并发单元都是平等的，因此租户的任务总是可以阻塞住任意一个并发单元，当所有并发单元都被高消耗的任务阻塞住时，调度就不再平滑了。而2DFQ的思路就是让工作线程之间分个等级，部分工作线程负载调度高耗时的任务，剩余的线程负责调度低消耗的任务，从而让调度变得平滑。</p>
<p>2DFQ在WF²Q上进一步修改约束：</p>
<ul>
<li>有$n$个并发工作单元，并且按固定下标$W_0,W_1,...W_{n-1}$排列。</li>
<li>在$W_i$上，只有当$S_f^j \le V_{now}-L_f^j \times \frac{i}{n}$时，才允许这个任务被调度。</li>
</ul>
<p><img src="Multi-Tenant/./assets/Multi-Tenant/2dfq1.png" alt="" /></p>
<ul>
<li>$W_0$这个并发单元的行为和WF²Q是完全一致的，所以他不会区分高开销和低开销任务。</li>
<li>$W_1$这个并发单元会倾向于调度低耗时任务，因为它们的允许调度的阈值更小。</li>
</ul>
<h2 id="with-evaluation-2dfqe"><a class="header" href="#with-evaluation-2dfqe">With Evaluation (2DFQ^e)</a></h2>
<p>2DFQ优化了平滑调度的问题，但是还有另一个挑战就是我们总是无法合理的估计一个请求对应的资源开销。
一般都是通过历史某个时间窗口的请求记录来调整这个估计值，但是在特定的用户调用顺序下，极易出现错误的估计造成bursty schedule。</p>
<h3 id="bookkeeping-retroactive-charging"><a class="header" href="#bookkeeping-retroactive-charging">Bookkeeping: Retroactive Charging</a></h3>
<p>在2DFQ和WFQ中，我们使用 $F_f^j=max(A_f^j, F_f^{j-1}) + L_f^j/W_f$计算一个请求的完成虚拟时钟时间。在未知资源开销的情况下，调整如下定义：</p>
<ul>
<li>$L_f^j$：租户f在第j次请求时的估算资源开销。</li>
<li>$C_f^j$：租户f在第j次请求时的实际资源开销。</li>
<li>如果$C_f^j&gt;L_f^j$，系统需要额外计算开销，否则系统需要返回给租户未使用的开销，即租户后续任务的开始与结束时间都调整$(C_f^j-L_f^j)/W_f$。</li>
</ul>
<h3 id="pessimistic-cost-estimation"><a class="header" href="#pessimistic-cost-estimation">Pessimistic Cost Estimation</a></h3>
<p>在2DFQ中，</p>
<ul>
<li>如果高估了任务开销$C_f^j&lt;L_f^j$：则低开销任务会从低耗时任务工作线程转移到高耗时工作线程，只会影响当前任务的响应速度，而不会影响其他低开销存量任务的响应速度。</li>
<li>如果低估了任务开销$C_f^j&lt;L_f^j$：则高开销任务会从高耗时任务工作线程转移到低耗时工作线程，会影响其他低开销存量任务的响应速度。</li>
</ul>
<p>所以2DFQ^e采用悲观开销预估：</p>
<ul>
<li>租户对应的某类请求总是维护一个最高开销值，$L_f^{max}$作为未知请求的开销预估。</li>
<li>在Bookkeeping时，
<ul>
<li>如果$C_f^j&gt;L_f^{max}$，则$L_f^{max}=C_f^j$。</li>
<li>否则，$L_f^{max}= \alpha L_f^{max}, \alpha&lt;1$。
变量α用于控制悲观估计的收敛的激进程度，这个值必须是一个比较靠近1的值。</li>
</ul>
</li>
<li>α越接近1，收敛越慢，越不容易产生bursty schedule，但是当前租户的响应耗时恢复会偏长。</li>
<li>否则，容易产生bursty schedule，当前租户的响应耗时恢复会更短。</li>
</ul>
<h3 id="bookkeeping-refresh-charging"><a class="header" href="#bookkeeping-refresh-charging">Bookkeeping: Refresh Charging</a></h3>
<p>当一个租户长时间发出低开销请求时，$L_f^{max}$会是一个低估值，如果用户切换到高开销请求的状态时，如果并发度过高，还是会导致bursty schedule。</p>
<ul>
<li>原论文给出方案是定时刷新，让估计重回到悲观状态，比如10ms一次。</li>
<li>我觉得高开销任务可以通过定时器触发感知，而不需要定时刷新。</li>
</ul>
<h1 id="limitation"><a class="header" href="#limitation">Limitation</a></h1>
<p>以上的调度器都是针对 work-conserving 系统描述的效果。</p>
<ul>
<li>work-conserving：系统的所有工作单元（Thread）总是在工作，只要调度器内有在等待的任务。（充分利用资源）</li>
<li>non-work-conserving：系统的所有工作单元不总是在工作，可能会休息一段时间，等待任务积压调度。（允许资源浪费）</li>
</ul>
<p>因此这类调度器都只能在work-conserving系统出现积压backlogged的时候生效，在一个系统资源未打满的环境中，调度策略都会退化，不生效。</p>
<h1 id="reference"><a class="header" href="#reference">Reference</a></h1>
<ul>
<li><a href="Multi-Tenant/">https://en.wikipedia.org/wiki/Generalized_processor_sharing</a></li>
<li><a href="Multi-Tenant/">https://webhostinggeeks.com/blog/what-is-weighted-fair-queuing/</a></li>
<li><a href="Multi-Tenant/">https://www.cs.cmu.edu/~hzhang/papers/INFOCOM96.pdf</a></li>
<li><a href="Multi-Tenant/">https://dl.acm.org/doi/10.1145/2934872.2934878</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
